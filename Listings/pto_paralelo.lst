C51 COMPILER V9.59.0.0   PTO_PARALELO                                                      09/15/2020 15:49:48 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE PTO_PARALELO
OBJECT MODULE PLACED IN .\Objects\pto_paralelo.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE pto_paralelo.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\pto_paralelo.lst) TABS(2) OBJECT(.\Objects\pto_paralelo.obj)

line level    source

   1          #include <pto_paralelo.h>
   2          #include <reg51.h>
   3          
   4          extern void Delay (void);
   5          extern void Delay_20us(unsigned int cnt);
   6          extern void off_Timer0_Interrup(void);
   7          extern void on_Timer0_Interrup(void);
   8          extern void          _nop_     (void);
   9          extern void Block_read_Clock(unsigned char *datos_clock);
  10          extern char lee_clk (unsigned char dir_clk);
  11          extern int sprintf  (char *, const char *, ...);
  12          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  13          extern void Debug_Dividir_texto();
  14          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  15          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  16          
  17          /*pines del pto paralelo*/
  18          sbit port_clk = P3^4;       //Recepcion AUX                     *
  19          sbit busy = P3^3;           /*bussy de Entrada Interrupcion del Procesador principal      */
  20          sbit ready = P3^2;          //Salida. solicitud envio Datos             *
  21          sbit rx_in_data = P0^6;       //Indicador de Rx Transporte o Lectura Wiegand      *
  22          sbit led_err_imp = P0^2;      //Error   
  23          
  24          #define MAX_DAT_BUFF    40
  25          #define TIME_WBUS       20000
  26          #define STX             02 
  27          #define ETX             03 
  28          #define EE_ID_CLIENTE           0x0000
  29          #define EE_ID_PARK              0x0002
  30          
  31          /*definicion de variable globales*/
  32          //extern int ID_CLIENTE;            
  33          //extern int COD_PARK;
  34          
  35          /*------------------------------------------------------------------------------
  36          
  37          Recibe informacion del Mc principla por pto paralelo
  38          retorna:
  39          num_data= numero de caracteres recibidos
  40          buffer_port= apuntador donde se almacena el dato recibido
  41          busy=0    significa que el principla me transmite una cadena de datos
  42          Ready=0   significa que estoy listo para recibir los datos
  43          time_out= es el tiempo de espera que le damos al ciclo de reloj en alto si se pasa el tiempo se sale por f
             -in de la transmicion 
  44          num_data= es numero de datos recibidos 
  45          rx_in_data= 0 prende el led que estoy recibiendo un dato (1) termina la recepcion del dato
  46          
  47          ------------------------------------------------------------------------------*/
  48          unsigned char recibe_port(unsigned char *buffer_port)
  49          {
  50   1      
  51   1        unsigned int count;
  52   1        unsigned char time_out,num_data;
  53   1        unsigned int T_ANCHO=160;
C51 COMPILER V9.59.0.0   PTO_PARALELO                                                      09/15/2020 15:49:48 PAGE 2   

  54   1        unsigned char data_temp=0;
  55   1      
  56   1        
  57   1        if (busy==0)
  58   1        {
  59   2          
  60   2          off_Timer0_Interrup();
  61   2          num_data=0;
  62   2          rx_in_data=0;
  63   2          time_out=0;
  64   2          ready=0;
  65   2        
  66   2      //-----------------------------------------------------------------
  67   2          count=T_ANCHO;
  68   2          while ((busy==0)&&(time_out==0))
  69   2          {
  70   3            if(port_clk==1)
  71   3            {
  72   4              
  73   4              count--;
  74   4              if (count==0)
  75   4              {
  76   5                time_out=1;
  77   5                break;
  78   5              }
  79   4            }
  80   3            else 
  81   3            {
  82   4              if (num_data<MAX_DAT_BUFF)
  83   4              {
  84   5                
  85   5                while(port_clk==0)
  86   5                {
  87   6                  
  88   6                  data_temp=P2 & 0xff;
  89   6                
  90   6                }
  91   5                  *buffer_port=data_temp;
  92   5                  buffer_port++;
  93   5                  num_data++; 
  94   5                  count=T_ANCHO;
  95   5              }
  96   4              else{break;}
  97   4            }
  98   3          }
  99   2      
 100   2      
 101   2          ready=1;
 102   2          rx_in_data=1;
 103   2        }
 104   1        on_Timer0_Interrup();
 105   1           
 106   1        return num_data;
 107   1      }
 108          
 109          /*-------------------------------------------------------------------------------------------
 110          
 111          Rutina de envio de datos pto paralelo
 112          
 113          -------------------------------------------------------------------------------------------*/
 114          void  send_port(unsigned char *buffer_port, unsigned char length_char)
 115          {
C51 COMPILER V9.59.0.0   PTO_PARALELO                                                      09/15/2020 15:49:48 PAGE 3   

 116   1       
 117   1        long int cont;
 118   1        unsigned char timeOut,length;
 119   1        
 120   1        length=length_char;
 121   1      
 122   1        ready=1;                                        // Genera interrupcion al Principal
 123   1        port_clk=1;                                     // El que transmite debe fijar primero el Clk en 1
 124   1        rx_in_data=0;                                   // Led de visualizacion   ON
 125   1        timeOut=0;                                      // Tiempo de Espera
 126   1        ready=0;                                        // Genera interrupcion al Principal
 127   1        cont=TIME_WBUS;
 128   1      
 129   1        while ((busy==1)&&(timeOut==0))                 //Espera reconocimiento INT por entrada busy
 130   1        {
 131   2          ready=0;
 132   2          port_clk=1;
 133   2          cont--;
 134   2          if (cont==0)
 135   2          {
 136   3            timeOut=1;
 137   3            led_err_imp=0;                              // LED ERROR
 138   3          }
 139   2        }
 140   1        if ((timeOut==0)&&(busy==0))
 141   1        {
 142   2            
 143   2          
 144   2          do 
 145   2          {
 146   3            
 147   3                P2=*buffer_port;
 148   3                Pulso_Bus();
 149   3                buffer_port++;
 150   3            
 151   3                length_char--;
 152   3          }while (length_char);
 153   2            
 154   2          }
 155   1      
 156   1        P2=0XFF;
 157   1        ready=1;
 158   1        port_clk=1;
 159   1        rx_in_data=1;                                   //Led de visualizacion  OFF
 160   1        Delay_20us(98);
 161   1            
 162   1          
 163   1      }
 164          /*-------------------------------------------------------------------------------------------
 165          Funcion q arma la trama a transmitir pto paralelo trama g
 166          -------------------------------------------------------------------------------------------*/ 
 167          /*
 168          void Trama_pto_Paralelo(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd)
 169          {
 170            unsigned char Buffer_port[30];
 171            unsigned char j=3;
 172            Buffer_port[0]=STX;                               /*inicio de cmd STx*/
 173          /*  Buffer_port[1]=cmd;                               /*cmd*/
 174          /*  Buffer_port[2]=21;                                /*numero de digitos de transmicion NO IMPORTA NO ES VALIDADO EN PRINC
             -IPAL*/
 175          /*  do
 176            {
C51 COMPILER V9.59.0.0   PTO_PARALELO                                                      09/15/2020 15:49:48 PAGE 4   

 177             Buffer_port[j++]=*buffer_S1_B0;                  /*ticket*/
 178          //    buffer_S1_B0++;
 179            //}while (*buffer_S1_B0!=0);
 180            
 181            //if(*(buffer_S1_B2+5)!=0)                          /*MF_DCTO           0x05        Tipo de descuento (00)sin descuento, (01xx 
             -xxxx) 0x40 fija fecha de salida,
 182          //                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto po
             -r dinero */
 183            //{
 184              //Buffer_port[j++]='-';                           /*separador del descuento*/
 185            //  Buffer_port[j++]=*(buffer_S1_B2+5)+0x30;        /*descuento pasado a ascii*/
 186          //  }
 187            //else
 188            //{
 189              //Buffer_port[j++]='-';                           /*separador del descuento*/
 190              //Buffer_port[j++]='0';
 191            //}
 192            //if(*(buffer_S1_B2+9)==0)                          /*MF_IN_PAGO        0x09  */  
 193            //{
 194              //Buffer_port[j++]='-';                           /*separador de la fecha de entrada*/
 195              //Buffer_port[j++]=*(buffer_S1_B2+0)+0x030;       /*año de entrada*/
 196              //Buffer_port[j++]=*(buffer_S1_B2+1)+0x030;       /*mes de entrada*/
 197              //Buffer_port[j++]=*(buffer_S1_B2+2)+0x030;       /*dia de entrada*/
 198              //Buffer_port[j++]=*(buffer_S1_B2+3)+0x030;       /*hora de entrada*/
 199              //Buffer_port[j++]=*(buffer_S1_B2+4)+0x030;       /*minutos de entrada*/
 200            //}
 201              //Buffer_port[j++]='.';                           /*separador tipo de vehiculo*/
 202                                                              /*MF_TIPO_VEHICULO  0x08              tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 
             -tractomula*/
 203              
 204              //if(*(buffer_S1_B2+8)!=0)
 205              //{
 206                //Buffer_port[j++]='M';                         /*moto*/
 207              //}
 208              //else
 209              //{
 210              //  Buffer_port[j++]='C';                         /*carro*/
 211            //  }
 212              //Buffer_port[j++]=ETX; 
 213              //Buffer_port[2]=j;
 214              
 215              //ready=0;
 216                //while(busy==0);
 217              //send_port(Buffer_port,j);                         /*trama transmitida pto paralelo*/
 218              
 219                //Debug_Dividir_texto();                                              /*division del texto */
 220                        
 221            //    DebugBufferMF(Buffer_port,j,1);   
 222              //  Debug_Dividir_texto();  
 223          //}
 224          
 225          /*-------------------------------------------------------------------------------------------
 226          Funcion q arma la trama a transmitir pto paralelo trama P
 227          -------------------------------------------------------------------------------------------*/ 
 228          //void Trama_pto_Paralelo_P(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd)
 229          //{
 230            
 231          //static unsigned char Buffer_port[30];
 232          //  unsigned char j=3;
 233          //  Buffer_port[0]=STX;                               /*inicio de cmd STx*/
 234          //  Buffer_port[1]=cmd;                               /*cmd*/
 235          //  Buffer_port[2]=21;                                /*numero de digitos de transmicion NO IMPORTA NO ES VALIDADO EN PRINC
C51 COMPILER V9.59.0.0   PTO_PARALELO                                                      09/15/2020 15:49:48 PAGE 5   

             -IPAL*/
 236          //  do
 237          //  {
 238          //   Buffer_port[j++]=*buffer_S1_B0;                  /*ticket*/
 239          //    buffer_S1_B0++;
 240          //  }while (*buffer_S1_B0!=0);
 241          //  Buffer_port[2]=j-3;
 242          //  if(*(buffer_S1_B2+5)!=0)                          /*MF_DCTO           0x05        Tipo de descuento (00)sin descuento, (01xx 
             -xxxx) 0x40 fija fecha de salida,
 243          //                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto po
             -r dinero */
 244          //  {
 245          //    Buffer_port[j++]='-';                           /*separador del descuento*/
 246          //    Buffer_port[j++]=*(buffer_S1_B2+5)+0x30;        /*descuento pasado a ascii*/
 247          //  }
 248            
 249            /*
 250            if(*(buffer_S1_B2+9)&0x0f==0x0f)                  /*MF_IN_PAGO        0x09  */  
 251            //{
 252            //  Buffer_port[j++]='-';                           /*separador de la fecha de entrada*/
 253            //  Buffer_port[j++]=*(buffer_S1_B2+0)+0x030;       /*año de entrada*/
 254            //  Buffer_port[j++]=*(buffer_S1_B2+1)+0x030;       /*mes de entrada*/
 255            //  Buffer_port[j++]=*(buffer_S1_B2+2)+0x030;       /*dia de entrada*/
 256            //  Buffer_port[j++]=*(buffer_S1_B2+3)+0x030;       /*hora de entrada*/
 257            //  Buffer_port[j++]=*(buffer_S1_B2+4)+0x030;       /*minutos de entrada*/
 258            //}
 259            
 260            //  Buffer_port[j++]='.';                           /*separador tipo de vehiculo*/
 261                                                              /*MF_TIPO_VEHICULO  0x08              tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 
             -tractomula*/
 262              
 263            //  if(*(buffer_S1_B2+8)!=0)
 264            //  {
 265            //    Buffer_port[j++]='M';                         /*moto*/
 266            //  }
 267            //  else
 268            //  {
 269            //    Buffer_port[j++]='C';                         /*carro*/
 270            //  }
 271              //Buffer_port[j++]=ETX; 
 272              
 273            //  ready=0;
 274                //while(busy==0);
 275            //  send_port(Buffer_port,j);                         /*trama transmitida pto paralelo*/
 276            //    Debug_Dividir_texto();                                              /*division del texto */
 277                        
 278            //    DebugBufferMF(Buffer_port,j,1);   
 279            //    Debug_Dividir_texto();  
 280              
 281                
 282          //}
 283          
 284          /*-------------------------------------------------------------------------------------------
 285          Funcion q arma la trama a transmitir pto paralelo trama 
 286          C = cajero
 287          s =
 288          -------------------------------------------------------------------------------------------*/ 
 289          //void Trama_pto_Paralelo_C_s(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2)
 290          //{
 291          //  unsigned char Buffer_port[30];
 292          //  unsigned char j=2;
 293          //  Buffer_port[0]=STX;                               /*inicio de cmd STx*/
C51 COMPILER V9.59.0.0   PTO_PARALELO                                                      09/15/2020 15:49:48 PAGE 6   

 294            //Buffer_port[1]=cmd;                               /*cmd*/
 295            
 296          //  do
 297            //{
 298            // Buffer_port[j++]=*buffer_S1_B0;                  /*ticket*/
 299            //  buffer_S1_B0++;
 300            //}while (*buffer_S1_B0!=0);
 301            
 302            
 303                  
 304            
 305            
 306            //if(*(buffer_S1_B2+5)!=0)                          /*MF_DCTO           0x05        Tipo de descuento (00)sin descuento, (01xx 
             -xxxx) 0x40 fija fecha de salida,
 307          //                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto po
             -r dinero */
 308            //{
 309              //Buffer_port[j++]='-';                           /*separador del descuento*/
 310              //Buffer_port[j++]=*(buffer_S1_B2+5)+0x30;        /*descuento pasado a ascii*/
 311            //}
 312            //else
 313            //{
 314            //  Buffer_port[j++]='-';                           /*separador del descuento*/
 315            //  Buffer_port[j++]='0';
 316            //}
 317            //if((*(buffer_S1_B2+9)&0x0f)==0x0f)                  /*MF_IN_PAGO=0x09       si es =0x0f fue liquidado en cajero   */
             -  
 318            //{
 319              //Buffer_port[1]='C';
 320            //}
 321            //else
 322            //{
 323            //  Buffer_port[1]='s';
 324            //}
 325            //  Buffer_port[j++]='-';                           /*separador de la fecha de entrada*/
 326            //  Buffer_port[j++]=*(buffer_S1_B2+0)+0x030;       /*año de entrada*/
 327            //  Buffer_port[j++]=*(buffer_S1_B2+1)+0x030;       /*mes de entrada*/
 328            //  Buffer_port[j++]=*(buffer_S1_B2+2)+0x030;       /*dia de entrada*/
 329            //  Buffer_port[j++]=*(buffer_S1_B2+3)+0x030;       /*hora de entrada*/
 330            //  Buffer_port[j++]=*(buffer_S1_B2+4)+0x030;       /*minutos de entrada*/
 331            
 332          //    Buffer_port[j++]='.';                           /*separador tipo de vehiculo*/
 333                                                              /*MF_TIPO_VEHICULO  0x08              tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 
             -tractomula*/
 334              
 335            //  if(*(buffer_S1_B2+8)!=0)
 336              //{
 337                //Buffer_port[j++]='M';                         /*moto*/
 338              //}
 339              //else
 340              //{
 341              //  Buffer_port[j++]='C';                         /*carro*/
 342              //}
 343              //Buffer_port[j++]=ETX; 
 344              //while(busy==0);
 345              //send_port(Buffer_port,j);                         /*trama transmitida pto paralelo*/
 346              
 347            
 348          //}
 349          
 350          /*-------------------------------------------------------------------------------------------
 351          Funcion q arma la trama a transmitir pto paralelo trama g
C51 COMPILER V9.59.0.0   PTO_PARALELO                                                      09/15/2020 15:49:48 PAGE 7   

 352          -------------------------------------------------------------------------------------------*/ 
 353          //void Trama_pto_Paralelo_new(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd)
 354          //{
 355          //  unsigned char Buffer_port[30];
 356          //  unsigned char j=2;
 357            
 358          //  Buffer_port[0]=STX;                               /*inicio de cmd STx*/
 359          //  Buffer_port[1]=cmd;                               /*cmd*/
 360          
 361          //  do
 362          //  {
 363          //   Buffer_port[j++]=*buffer_S1_B0;                  /*ticket*/
 364          //    buffer_S1_B0++;
 365          //  }while (*buffer_S1_B0!=0);
 366            
 367          //  if(*(buffer_S1_B2+5)!=0)                          /*MF_DCTO           0x05        Tipo de descuento (00)sin descuento, (01xx 
             -xxxx) 0x40 fija fecha de salida,
 368            //                                                  10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto po
             -r dinero */
 369          //  {
 370          //    Buffer_port[j++]='-';                           /*separador del descuento*/
 371          //    Buffer_port[j++]=*(buffer_S1_B2+5)+0x30;        /*descuento pasado a ascii*/
 372          //  }
 373          //  else
 374          //  {
 375          //    Buffer_port[j++]='-';                           /*separador del descuento*/
 376          //    Buffer_port[j++]='0';
 377          //  }
 378            
 379          //  if((*(buffer_S1_B2+9)&0x0f)==0x0f)                  /*MF_IN_PAGO=0x09       si es =0x0f fue liquidado en cajero   */
             -  
 380          //  {
 381            //  Buffer_port[1]='C';
 382          //  }
 383          //  else
 384          //  {
 385          //    Buffer_port[1]='s';
 386          //  }
 387            
 388          //    Buffer_port[j++]='-';                           /*separador de la fecha de entrada*/
 389          //    Buffer_port[j++]=*(buffer_S1_B2+0)+0x030;       /*año de entrada*/
 390          //    Buffer_port[j++]=*(buffer_S1_B2+1)+0x030;       /*mes de entrada*/
 391          //    Buffer_port[j++]=*(buffer_S1_B2+2)+0x030;       /*dia de entrada*/
 392          //    Buffer_port[j++]=*(buffer_S1_B2+3)+0x030;       /*hora de entrada*/
 393          //    Buffer_port[j++]=*(buffer_S1_B2+4)+0x030;       /*minutos de entrada*/
 394          //    Buffer_port[j++]='-'; 
 395              
 396          //    Block_read_Clock_Hex(Buffer_port+j);
 397              
 398          //    Buffer_port[j++]=Buffer_port[j]+ 0x30;
 399          //    Buffer_port[j++]=Buffer_port[j]+ 0x30;
 400          //    Buffer_port[j++]=Buffer_port[j]+ 0x30;
 401          //    Buffer_port[j++]=Buffer_port[j]+ 0x30;
 402          //    Buffer_port[j++]=Buffer_port[j]+ 0x30;
 403              
 404              
 405            
 406          //    Buffer_port[j++]='.';                           /*separador tipo de vehiculo*/
 407                                                              /*MF_TIPO_VEHICULO  0x08              tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 
             -tractomula*/
 408              
 409          //    if(*(buffer_S1_B2+8)!=0)
C51 COMPILER V9.59.0.0   PTO_PARALELO                                                      09/15/2020 15:49:48 PAGE 8   

 410          //    {
 411          //      Buffer_port[j++]='M';                         /*moto*/
 412          //    }
 413          //    else
 414          //    {
 415          //      Buffer_port[j++]='C';                         /*carro*/
 416          //    }
 417          //    Buffer_port[j++]=ETX; 
 418            
 419              
 420          //    ready=0;
 421          //      while(busy==0);
 422          //    send_port(Buffer_port,j);                         /*trama transmitida pto paralelo*/
 423              
 424          //      Debug_Dividir_texto();                                              /*division del texto */
 425                        
 426          //      DebugBufferMF(Buffer_port,j,1);   
 427          //      Debug_Dividir_texto();  
 428          //}
 429          
 430          
 431          
 432          /*-------------------------------------------------------------------------------------------
 433          Reloj del pto paralelo
 434          -------------------------------------------------------------------------------------------*/
 435          void Pulso_Bus(void)
 436          {
 437   1        port_clk=0;
 438   1        Delay_20us(33);
 439   1        port_clk=1;
 440   1        Delay_20us(33);                 /*wait_ancho*/
 441   1      }
 442          /*-------------------------------------------------------------------------------------------
 443          Envia msj de error visualizar en el lcd del micro principal
 444          -------------------------------------------------------------------------------------------*/
 445          void send_portERR(unsigned char cod_err)
 446          {
 447   1        unsigned char timeOut;
 448   1        long int cont;
 449   1        
 450   1        port_clk=1;                                   /*Reloj del pto paralelo El que transmite debe fijar primero el Clk en 1*/
 451   1        rx_in_data=0;                                 //Led de visualizacion  ON
 452   1        timeOut=0;
 453   1        cont=15000;
 454   1        
 455   1        P2=cod_err;
 456   1        ready=0;                                      //Genera interrupcion al Principal
 457   1        while ((busy==1)&&(timeOut==0))               //Espera reconocimiento INT por entrada busy
 458   1        {
 459   2          cont--;
 460   2          if (cont==0)
 461   2          {
 462   3            timeOut=1;
 463   3          }
 464   2        }
 465   1        if ((timeOut==0)&&(busy==0))
 466   1        {
 467   2              P2=cod_err;
 468   2            Pulso_Bus();
 469   2        }
 470   1        ready=1;
 471   1        port_clk=1;
C51 COMPILER V9.59.0.0   PTO_PARALELO                                                      09/15/2020 15:49:48 PAGE 9   

 472   1        rx_in_data=1;                                   //Led de visualizacion  OFF
 473   1      
 474   1        P2=0XFF;
 475   1      
 476   1        Delay_20us(98); 
 477   1        Delay_20us(98); 
 478   1        
 479   1      }
 480          /*-------------------------------------------------------------------------------------------
 481          Condiciones de Inicio del pto paralelo
 482          -------------------------------------------------------------------------------------------*/
 483          void cond_ini_pto()
 484          { 
 485   1        
 486   1        port_clk=1;
 487   1        ready=1;
 488   1        rx_in_data=1;
 489   1        P2=0xff;
 490   1      }
 491          /*------------------------------------------------------------------------------
 492          Funcion q carga el reloj y lo envia por el pto paralelo
 493          msj informativo con el pulsador funcion 
 494          ------------------------------------------------------------------------------*/
 495          void load_and_send_info_reloj()
 496          {
 497   1        unsigned char buffer_info[11];
 498   1        
 499   1          buffer_info[0]=STX;                   /*STX*/
 500   1          
 501   1          buffer_info[1]='i';                   /*se envia el cmd*/
 502   1          
 503   1          Block_read_Clock(buffer_info+2);      /*año, mes,dia, hora, minutos, segundos*/
 504   1          buffer_info[8]=lee_clk(0x8b);         //Dia semana
 505   1          buffer_info[9]=ETX;                   //ETX
 506   1      
 507   1         
 508   1      
 509   1          send_port(buffer_info,10);
 510   1      }
 511          
 512          /*------------------------------------------------------------------------------
 513          procedimiento que transmite por el pto paralelo ID_cliente,COD_park
 514          con el pulsador funcion
 515          ------------------------------------------------------------------------------*/ 
 516          void load_and_send_id_cod()
 517          {
 518   1      unsigned char buffer_info[11];
 519   1      unsigned char buf[4];
 520   1      unsigned char i,k;
 521   1      unsigned char ID_CLIENTE;
 522   1      unsigned char COD_PARK;     
 523   1          k=0;
 524   1          ID_CLIENTE=rd_eeprom(0xa8,EE_ID_CLIENTE); 
 525   1          COD_PARK=rd_eeprom(0xa8,EE_ID_PARK);
 526   1          buffer_info[0]=STX;                       //STX
 527   1          buffer_info[1]='D';                       // nombre del comando de id_cliente, cod_park
 528   1          sprintf(buf,"%d",ID_CLIENTE);             /*ID_CLIENTE lo paso a strim */
 529   1          for(i=2;;i++)
 530   1          {
 531   2            if(buf[k] !=0)                          /*alamaceno id del clinete en el buffer*/
 532   2            {
 533   3            buffer_info[i]=buf[k] ;                 /*almaceno el dato en el buffer*/
C51 COMPILER V9.59.0.0   PTO_PARALELO                                                      09/15/2020 15:49:48 PAGE 10  

 534   3            k++;
 535   3            }
 536   2              else {buffer_info[i]=';'; i++; break;}  /*le pongo un  separador */
 537   2              
 538   2           }
 539   1        
 540   1        
 541   1           sprintf(buf,"%d",COD_PARK);                /*cod_park lo paso a strim*/
 542   1          
 543   1          for(k=0;;i++)
 544   1          {
 545   2            if(buf[k] !=0)
 546   2            {
 547   3            buffer_info[i]=buf[k] ;                   /*lo almaceno en el  buffer*/
 548   3            k++;
 549   3            }else {buffer_info[i]=';'; i++; break;}
 550   2           }
 551   1        
 552   1        
 553   1            buffer_info[i]=ETX;                     //ETX
 554   1            send_port(buffer_info,i);                 /*se transmite informacion pt0 paralelo*/
 555   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    825    ----
   CONSTANT SIZE    =      3    ----
   XDATA SIZE       =   ----      54
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
