C51 COMPILER V9.59.0.0   MAIN                                                              05/21/2020 14:05:10 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /*------------------------------------------------------------------------------
   2          MAIN.C:  sistema verificador
   3          
   4          Diseñado Ing. Jaime Pedraza
   5          ------------------------------------------------------------------------------*/
   6          #include <main.h>
   7          /*------------------------------------------------------------------------------
   8          interrupcion por timer 
   9          ValTimeOutCom se decrementa cada overflow de la interrupcion
  10          Timer_wait    Incrementa cada overflow de la interrrupcion
  11          ------------------------------------------------------------------------------*/
  12           timer0_int() interrupt 1 using 2
  13              {
  14   1            
  15   1            ValTimeOutCom--;
  16   1            Timer_wait++;
  17   1            Timer_tivo++;
  18   1            TF0=0;
  19   1            
  20   1          }
  21          /*------------------------------------------------------------------------------
  22          ------------------------------------------------------------------------------*/
  23          void ini_timer(void)
  24          {
  25   1      
  26   1        TMOD=(TMOD & 0xF0) | 0x01;// configuro el reg TMOD sin precalador a 16 bits
  27   1          
  28   1        TH0=0X00;               //registro de la parte alta del timer0 de 16 bits                 *           
  29   1        TL0=0X00;               // registro de la parte baja del timer0
  30   1        TR0=1;                  // habilita el timer0 reg TCOM bit 4 para interrup
  31   1      
  32   1      }
  33          /*------------------------------------------------------------------------------
  34          ------------------------------------------------------------------------------*/
  35          void on_Timer0_Interrup(void)
  36          {
  37   1        TF0=0;                  //registro TCON bit 5 bandera de overflow 
  38   1        ET0=1;                  // enable interrupcion bit 1 del registro IENO
  39   1        
  40   1      }
  41          /*------------------------------------------------------------------------------
  42          ------------------------------------------------------------------------------*/
  43          void off_Timer0_Interrup(void)
  44          {
  45   1        ET0=0;                  // enable interrupcion bit 1 del registro IENO
  46   1        
  47   1      }
  48          /*------------------------------------------------------------------------------
  49          ------------------------------------------------------------------------------*/
  50          /*------------------------------------------------------------------------------
  51          _getkey waits until a character is received from the serial port.  This may not
  52          be the exact desired operation (for example if the buffer is empty, this
  53          function hangs waiting for a character to be received).
  54          ------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   MAIN                                                              05/21/2020 14:05:10 PAGE 2   

  55          char _getkey (void)
  56          {
  57   1      int k;
  58   1      
  59   1      do
  60   1        {
  61   2        k = com_getchar ();
  62   2        }
  63   1      while (k == -1);
  64   1      
  65   1      return ((unsigned char) k);
  66   1      }
  67          
  68          /*------------------------------------------------------------------------------
  69          ------------------------------------------------------------------------------*/
  70          char putchar (char c)
  71          {
  72   1      volatile unsigned int i;
  73   1      
  74   1      while (com_putchar (c) != 0)
  75   1        {
  76   2        for (i=0; i<1000; i++)
  77   2          {
  78   3          /*** DO NOTHING ***/
  79   3          }
  80   2        }
  81   1      
  82   1      return (c);
  83   1      }
  84          /*------------------------------------------------------------------------------
  85          escribir una cadena de datos por pto serie
  86          ------------------------------------------------------------------------------*/
  87          void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena)
  88          {
  89   1        unsigned char i,d;
  90   1          for(i=0;i<tamano_cadena;i++)
  91   1          {
  92   2            d=putchar(*buffer);
  93   2            buffer++;
  94   2          }
  95   1      }
  96          /*
  97          unsigned char recibe_cmd_LPR(unsigned char *buffer_cmd)
  98          {
  99             unsigned char j, MaxChrRx;
 100             unsigned int contador;
 101            
 102             bit time_out;
 103             
 104             MaxChrRx=11;
 105          
 106            
 107                for (j=0; j<MaxChrRx; j++)
 108                {
 109                  contador=0;
 110                  time_out=0;
 111                  while ((rx_ip==1)&&(time_out==0))
 112                  {
 113                    contador++;
 114                    if (contador>65000)
 115                    {
 116                      time_out=1;
C51 COMPILER V9.59.0.0   MAIN                                                              05/21/2020 14:05:10 PAGE 3   

 117                      
 118                    }       
 119                  }
 120                  if(time_out==1)break;
 121                    
 122                    *buffer_cmd=rx_Data();
 123                      buffer_cmd++;
 124                }
 125          
 126                *buffer_cmd=0;
 127                return j;
 128          }
 129          /*------------------------------------------------------------------------------
 130          Rutina de las condiciones iniciales del board
 131          ------------------------------------------------------------------------------*/
 132          void inicia_board(void)
 133          {
 134   1      cond_ini_tibbo();             /* inicia tibbo*/
 135   1      cond_ini_clock();             /* inicia clock*/
 136   1      cond_ini_pto();               /*Inicializacion del pto*/
 137   1      Atascado=0;                   /*prendo el verificador*/
 138   1      sel_com=1;                    /*seleccionar el pto serie */
 139   1      lock=0;                       /*barrera off*/ 
 140   1        
 141   1      }
 142          
 143          /*------------------------------------------------------------------------------
 144          Rutina que lee la eeprom, los bit de configuracion 
 145          ------------------------------------------------------------------------------*/
 146          void variable_inicio()
 147          {
 148   1        
 149   1        ID_CLIENTE=rd_eeprom(0xa8,EE_ID_CLIENTE); 
 150   1        COD_PARK=rd_eeprom(0xa8,EE_ID_PARK);
 151   1        T_GRACIA=rd_eeprom(0xa8,EE_TIEMPO_GRACIA);
 152   1        SIN_COBRO=rd_eeprom(0xa8,EE_SIN_COBRO);
 153   1        Debug_Tibbo=1;//rd_eeprom(0xa8,EE_DEBUG);
 154   1        USE_LPR=rd_eeprom(0xa8,EE_USE_LPR);
 155   1        COMPARACION_ACTIVA=rd_eeprom(0xa8,EE_CPRCN_ACTIVA);
 156   1        Raspberry = rd_eeprom(0xa8,EE_TIPO_PANTALLA);
 157   1        //CardAutomatic=01;                   /*0= con boton 1= es igual automatico*/
 158   1      }
 159          /*------------------------------------------------------------------------------
 160          Note that the two function above, _getkey and putchar, replace the library
 161          functions of the same name.  These functions use the interrupt-driven serial
 162          I/O routines in SIO.C.
 163          ------------------------------------------------------------------------------*/
 164          
 165          
 166          void main (void)
 167          {
 168   1        
 169   1        static unsigned char buffer[40];
 170   1        //unsigned char buffer_clock[]={0x02,0x31,0x48,0x32,0x32,0x2f,0x30,0x33,0x2f,0X32,0X30,0X31,0X39,0x20,0x3
             -1,0x31,0x3a,0x33,0x39,0x3a,0x30,0x30,0x20,0x34,0x03,0}; //dia,mes,año,hora,minutos,SEGUNDOS,Dia de la semana
 171   1        unsigned char S1_B2[]={0x13, 0x03, 0x1D, 0x0B, 0x0E, 00, 00, 00, 00, 00, 0x01, 0x13, 0x03, 0x1D, 0x0E, 0x
             -1D};
 172   1        unsigned char S1_B0[]={0x32, 0x31, 0x30, 0x37, 0x31, 0x35, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01};
 173   1        unsigned char Estado_Comunicacion_Secuencia_MF=SEQ_INICIO;
 174   1          char Length_trama;
 175   1      
 176   1        
C51 COMPILER V9.59.0.0   MAIN                                                              05/21/2020 14:05:10 PAGE 4   

 177   1      ini_timer();                                                              /* initialize interrupt timer0 */
 178   1      on_Timer0_Interrup();                                                     /* habilita el  timer0 */
 179   1      com_initialize ();                                                        /* initialize pto serie */
 180   1      com_baudrate ();                                                          /* setup for 9600 baud */
 181   1      inicia_board();                                                           /*Rutina de las condiciones iniciales del board*/
 182   1      EA = 1;                                                                   /* Enable Interrupts global*/
 183   1      
 184   1      time_bit();                                                               /*solo para pruebas*/
 185   1      Delay_20us(33);
 186   1      time_mbit();
 187   1      tx_aux('a');  
 188   1        
 189   1      sel_Funcion();                                                              /*el pulsador funcion es el cmd q da la entrada a programacio
             -n */
 190   1        
 191   1        if (DataIn==0)              
 192   1        {
 193   2        menu();                                                                   /*menu de configuracion*/
 194   2        }
 195   1        variable_inicio();                                                        /*leo y cargo  las variables de inicio de configuracion*/
 196   1      while(Secuencia_inicio_expedidor());                                        /* procedimiento de inicio de transporte (reset, y
             - grabar eeprom)*/
 197   1        ValTimeOutCom=TIME_CARD;
 198   1                                                    
 199   1        while (1)                                                                 /* Loop Principal               */  
 200   1        {   
 201   2        
 202   2        //  if(Tarjeta_on==1)
 203   2        //  {
 204   2      //     EstadoComSeqMF=SecuenciaExpedidor(EstadoComSeqMF);                                                 /* procedimiento del trans
             -porte*/  
 205   2        //  }
 206   2          //else
 207   2        //  {         
 208   2              if (rx_ip==0)                                                         /*pregunto si llega datos de monitor pto serie emulado*/
 209   2              {
 210   3              
 211   3               Length_trama=recibe_cmd_Monitor(buffer);                           /*recibe la trama en buffer y saco la longitud 
             -de la trama*/
 212   3               Debug_monitor(buffer,Length_trama);
 213   3              }
 214   2              
 215   2            
 216   2                
 217   2              Estado_Comunicacion_Secuencia_MF=SecuenciaExpedidorMF(Estado_Comunicacion_Secuencia_MF);          //Secuenc
             -iaExpedidor();
 218   2              
 219   2                  
 220   2                                                          
 221   2            
 222   2              if (busy==0)                                                          /*comunicacion con el pto paralelo*/
 223   2              {
 224   3            
 225   3              Length_trama=recibe_port(buffer);                                   /*recibe informacion del pto paralelo*/
 226   3              /*solo de prueba*/    
 227   3              Debug_pto_paralelo(buffer,Length_trama);          
 228   3                  
 229   3              Valida_Trama_Pto(buffer,Length_trama);                                /*valido la informacion recibida */
 230   3               
 231   3              }
 232   2            msj_lcd_informativo();                                                  /*muestra la informacion de  ID cliente, cod parque, fec
             -ha,comparacion*/
C51 COMPILER V9.59.0.0   MAIN                                                              05/21/2020 14:05:10 PAGE 5   

 233   2        
 234   2      
 235   2          //}
 236   2        }
 237   1      
 238   1      }
 239          
 240          /*------------------------------------------------------------------------------
 241          ------------------------------------------------------------------------------*/
 242          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    529    ----
   CONSTANT SIZE    =     32    ----
   XDATA SIZE       =    114      43
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =    100    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
