C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE CLOCK
OBJECT MODULE PLACED IN .\Objects\Clock.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Clock.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\Clock.lst) TABS(2) OBJECT(.\Objects\Clock.obj)

line level    source

   1          
   2          #include <Clock.h>
   3          #include <reg51.h>
   4          
   5          /*funcion prototipo*/
   6          extern void Delay (void);
   7          extern void Delay_20us(unsigned int cnt);
   8          extern void Debug_Fecha_actual(unsigned char *buffer);
   9          extern float pow   (float x, float y);
  10          extern void Debug_chr_Tibbo(unsigned char Dat);
  11          /*variables externas */
  12          extern unsigned char  Debug_Tibbo;
  13          
  14          sbit sck = P1^4 ;                 /* define I/O functions     */
  15          sbit io  = P1^5 ;
  16          sbit rst = P1^6 ;
  17          /*CMD DE ESCRITURA RELOJ*/
  18          #define WDIA            0x86
  19          #define WMES            0x88
  20          #define WANO            0x8C
  21          #define WHORA           0x84
  22          #define WMIN            0x82
  23          #define WSEG            0x80
  24          #define WDIA_SEMANA     0x8A
  25          /*CMD DE LECTURA DEL RELOJ*/
  26          #define RDIA            0x87
  27          #define RMES            0x89
  28          #define RANO            0x8D
  29          #define RHORA           0x85
  30          #define RMIN            0x83
  31          #define RSEG            0x81
  32          #define RDIA_SEMANA     0x8B
  33          
  34          #define True                    0x01
  35          #define False                   0x00
  36          
  37          enum Dia_Semana{
  38            Domingo=1,Lunes, Martes, Miercoles, Jueves, Viernes, Sabado 
  39          };
  40          
  41          
  42          unsigned char data_clk;
  43          //*********************************************************************************
  44          
  45          //*********************************************************************************
  46          void p_ck (void)
  47          {
  48   1          sck=1;
  49   1          Delay();
  50   1          sck=0;
  51   1      }
  52          //*********************************************************************************
  53          void eb_clk(char dir_clk) {
  54   1        int nbits;
C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 2   

  55   1        for (nbits=0; nbits<8; nbits++)
  56   1        {
  57   2          dir_clk >>=1;
  58   2          if (CY==1)
  59   2          { 
  60   3            io=1;
  61   3          }
  62   2          else
  63   2          {
  64   3            io=0;
  65   3          }
  66   2          p_ck();
  67   2        }
  68   1      }
  69          //*********************************************************************************
  70          char lee_clk (unsigned char dir_clk) {            
  71   1      int nbits;
  72   1        rst=1;
  73   1        Delay_20us(3);
  74   1        eb_clk(dir_clk);
  75   1        for (nbits=0; nbits<8; nbits++)
  76   1        {
  77   2          if (io==1) 
  78   2          {
  79   3          data_clk = data_clk | 0x80;
  80   3          if (nbits<=6) {
  81   4           data_clk >>=1;
  82   4           }
  83   3          }
  84   2          if (io==0)
  85   2          {
  86   3            data_clk = data_clk & 0x7F;
  87   3          if (nbits<=6) 
  88   3           {
  89   4            data_clk >>=1;
  90   4           }
  91   3          }
  92   2          p_ck();
  93   2          } 
  94   1        rst=0;
  95   1        return data_clk;
  96   1      }
  97          //*********************************************************************************
  98          void wr_clk (unsigned char dir_clk, unsigned char byte) {            
  99   1        rst=1;
 100   1        Delay_20us(3);
 101   1        eb_clk(dir_clk);
 102   1        dir_clk=byte;
 103   1        eb_clk(dir_clk);
 104   1        rst=0;
 105   1        
 106   1       }
 107          //****************************************************************************
 108           unsigned char two_one (unsigned char byte_h,unsigned char byte_l)
 109          {
 110   1        unsigned char byte_out;
 111   1        byte_h=byte_h&0x0f;
 112   1        byte_h<<=4;
 113   1        byte_l=byte_l&0x0f;
 114   1        byte_out=byte_h|byte_l;
 115   1        return byte_out;
 116   1      }
C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 3   

 117          /*------------------------------------------------------------------------------
 118          
 119          ------------------------------------------------------------------------------*/
 120          unsigned char validar_clk(unsigned char *datos_clock)
 121          {
 122   1        unsigned char validador=0;
 123   1        
 124   1        
 125   1          if ((*datos_clock >= '0') &&(*datos_clock <= '9'))                                /*valida el dia parte alta */
 126   1          {
 127   2          
 128   2             if ((*(datos_clock+1) >= '0') &&(*(datos_clock+1) <= '9'))                     /*valida el dia parte baja*/
 129   2            {
 130   3              
 131   3               if ((*(datos_clock+3) >= '0') &&(*(datos_clock+3) <= '9'))             /*valida el mes parte alta*/
 132   3              {
 133   4                if ((*(datos_clock+4) >= '0') &&(*(datos_clock+4) <= '9'))            /*valida el mes parte baja */
 134   4                {
 135   5                 if ((*(datos_clock+8) >= '0') &&(*(datos_clock+8) <= '9'))         /*año baja*/      
 136   5                  {
 137   6                   if ((*(datos_clock+0x0b) >= '0')&&(*(datos_clock+0x0b) <= '9'))          /*hora alta*/ 
 138   6                    {
 139   7                    if ((*(datos_clock+0x0c) >= '0') &&(*(datos_clock+0x0c) <= '9'))          /*hora baja*/ 
 140   7                      {
 141   8                     if ((*(datos_clock+0x0e) >= '0') &&(*(datos_clock+0x0e) <= '9'))       /*minutos alta*/
 142   8                        {
 143   9                      if ((*(datos_clock+0x0f) >= '0') &&(*(datos_clock+0x0f) <= '9'))        /*minutos baja*/
 144   9                        {
 145  10                       if ((*(datos_clock+0x11) >= '0') &&(*(datos_clock+0x11) <= '9'))       /*segundos alta*/
 146  10                            {
 147  11                        if ((*(datos_clock+0x12) >= '0') &&(*(datos_clock+0x12) <= '9'))        /*segundos baja*/
 148  11                          {
 149  12                          if ((*(datos_clock+0x14) >= '0') &&(*(datos_clock+0x14) <= '9'))        /*dia de la semana*/
 150  12                           {
 151  13                                  validador=0;
 152  13                           }
 153  12                              }
 154  11                              else
 155  11                              {
 156  12                                validador =1;
 157  12                              }
 158  11                            }
 159  10                            else
 160  10                            {
 161  11                              validador =1;
 162  11                          
 163  11                            }
 164  10                          }
 165   9                          else
 166   9                          {
 167  10                            validador =1;
 168  10                        
 169  10                          }
 170   9                      
 171   9                        }
 172   8                        else
 173   8                        {
 174   9                          validador =1;
 175   9                        
 176   9                        }
 177   8                      }
 178   7                      else
C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 4   

 179   7                      {
 180   8                        validador =1;
 181   8                        //break;
 182   8                      }
 183   7                    }
 184   6                    else
 185   6                    {
 186   7                      validador =1;
 187   7                      
 188   7                    }               
 189   6                  }
 190   5                  else
 191   5                  {
 192   6                    validador =1;
 193   6                    
 194   6                  }
 195   5                }
 196   4                
 197   4              }
 198   3              else
 199   3              {
 200   4                validador =1;
 201   4                
 202   4              }
 203   3            
 204   3            }
 205   2            
 206   2            else
 207   2            {
 208   3              validador =1;
 209   3            
 210   3            }
 211   2          
 212   2          }
 213   1          
 214   1          else 
 215   1          {
 216   2            validador =1;
 217   2            
 218   2          }
 219   1        
 220   1        return validador;
 221   1        
 222   1      }
 223          /*------------------------------------------------------------------------------
 224          Escribo el reloj en ascii en bloque 
 225          
 226          ------------------------------------------------------------------------------*/
 227          
 228          void Block_write_clock_ascii(unsigned char *datos_clock)  
 229          
 230          {     
 231   1        unsigned char temp;
 232   1      //dia,mes,año,hora,minutos,segundos,Dia de la semana 
 233   1          
 234   1            /*dia*/
 235   1            wr_clk(WDIA,two_one(*datos_clock,*(datos_clock+1)));                    //dia
 236   1            datos_clock++;
 237   1            datos_clock++;
 238   1            datos_clock++;
 239   1            /*mes*/
 240   1            wr_clk(WMES,two_one(*datos_clock,*(datos_clock+1)));                    //mes
C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 5   

 241   1            datos_clock++;
 242   1            datos_clock++;
 243   1            datos_clock++;
 244   1            datos_clock++;
 245   1            datos_clock++;
 246   1            /*año*/
 247   1            wr_clk(WANO,two_one(*datos_clock,*(datos_clock+1)));                    //año
 248   1            datos_clock++;
 249   1            datos_clock++;
 250   1            datos_clock++;
 251   1            /*hora*/
 252   1            wr_clk(WHORA,two_one(*datos_clock,*(datos_clock+1)));                   //hora
 253   1            datos_clock++;
 254   1            datos_clock++;
 255   1            datos_clock++;
 256   1            /*minutos*/
 257   1            wr_clk(WMIN,two_one(*datos_clock,*(datos_clock+1)));                    //minutos
 258   1            datos_clock++;
 259   1            datos_clock++;
 260   1            datos_clock++;
 261   1            /*segundos*/
 262   1            wr_clk(WSEG,two_one(*datos_clock,*(datos_clock+1)));                    //segundos
 263   1            datos_clock++;
 264   1            datos_clock++;
 265   1            datos_clock++;
 266   1            /*dia de la semana*/
 267   1            temp =*datos_clock & 0x07;
 268   1            wr_clk(WDIA_SEMANA,temp);                               //dia de la semana
 269   1        
 270   1      }
 271          /*------------------------------------------------------------------------------
 272          rutinas de conversiones  de bcd a hex
 273          ------------------------------------------------------------------------------*/
 274          unsigned char bcd_hex (unsigned char l_data)
 275           {
 276   1        unsigned char temp,j;
 277   1        temp=l_data;
 278   1        temp>>=4;
 279   1        temp=temp & 0x0f;
 280   1        if (temp!=0x00)
 281   1        {
 282   2          l_data=l_data & 0x0f;
 283   2          for (j=0;j<temp;j++)
 284   2          {
 285   3              l_data=l_data+0x0a;
 286   3          } 
 287   2        }
 288   1        return l_data;
 289   1       }
 290           /*------------------------------------------------------------------------------
 291           Rutina que convierte de Hex a bcd 
 292          ------------------------------------------------------------------------------*/
 293          unsigned char hex_bcd (unsigned char byte)
 294          {
 295   1        unsigned char nibble_h; 
 296   1        unsigned char nibble_l;
 297   1        unsigned char k,byte_out;
 298   1      
 299   1        nibble_h=0x00;
 300   1        nibble_l=0x00;
 301   1      
 302   1        for (k=0;k<byte;k++)
C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 6   

 303   1        {
 304   2          nibble_l=nibble_l+0x01;
 305   2          if (nibble_l==0x0a)
 306   2          {
 307   3            nibble_l=0x00;
 308   3            nibble_h=nibble_h+0x01;
 309   3          }
 310   2         }
 311   1         nibble_h<<=4;
 312   1         nibble_h=nibble_h & 0xf0;
 313   1         nibble_l=nibble_l & 0x0f;
 314   1         byte_out=(nibble_h | nibble_l);
 315   1         return byte_out;
 316   1        
 317   1      }
 318          void hex_ascii(unsigned char * datos,unsigned char * fecha_asii)
 319          {
 320   1        unsigned char dato;
 321   1        //unsigned fecha_asii[7];
 322   1        
 323   1          dato=hex_bcd (*datos);
 324   1          *fecha_asii=((dato&0xf0)>>4)| 0x30;     /*dato parte alta*/
 325   1          *(fecha_asii+1)=(dato&0x0f)| 0x30;            /*dato parte bajo*/
 326   1          datos++;
 327   1        
 328   1          dato=hex_bcd (*(datos));
 329   1            *(fecha_asii+2)=((dato&0xf0)>>4)| 0x30;     /*dato parte alta*/
 330   1            *(fecha_asii+3)=(dato&0x0f)| 0x30;            /*dato parte bajo*/
 331   1          datos++;
 332   1        
 333   1          dato=hex_bcd (*(datos));
 334   1            *(fecha_asii+4)=((dato&0xf0)>>4)| 0x30;     /*dato parte alta*/
 335   1            *(fecha_asii+5)=(dato&0x0f)| 0x30;            /*dato parte bajo*/
 336   1          
 337   1            *(fecha_asii+6)=0;
 338   1        
 339   1      }
 340          /*------------------------------------------------------------------------------
 341            CONVIERTE DE 1BYTE HEXADECIMAL A DECIMAL                      
 342          valorhex= pasa el byte en Hex y lo convierte en decimal
 343          buffer=   se debuelve la conversion en un arreglo en ascii
 344          ------------------------------------------------------------------------------*/
 345          void ByteHex_Decimal(unsigned char *buffer,unsigned char valorhex)
 346          {
 347   1        unsigned char numero, centena, decena;
 348   1      
 349   1        centena=0;
 350   1        decena=0;
 351   1        numero=valorhex;
 352   1      
 353   1        while (numero>=0x064)                           /* resto centena en ascii100*/
 354   1        {
 355   2          numero=numero-0x64;
 356   2          centena=centena+1;
 357   2        }
 358   1          *buffer=centena|0x30;
 359   1          buffer++;
 360   1        while (numero>=0x0a)                            /* resto 10 decena en ascii*/
 361   1        {
 362   2          numero=numero-0x0a;
 363   2          decena=decena+1;
 364   2        }
C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 7   

 365   1        *buffer=decena|0x30;
 366   1        buffer++;
 367   1        *buffer=numero|0x30;                            /*unidad en ascii */
 368   1        buffer++;
 369   1        *buffer= 0;
 370   1      
 371   1      }
 372          /*------------------------------------------------------------------------------
 373            CONVIERTE DE 2BYTE HEXADECIMAL A DECIMAL                      
 374          
 375          ------------------------------------------------------------------------------*/
 376          void Two_ByteHex_Decimal(unsigned char *buffer,unsigned char id_h,unsigned char id_l)
 377          {
 378   1        unsigned int valor,numero;
 379   1        unsigned char temp,dmil, mil, centena, decena;
 380   1      
 381   1        valor=0;
 382   1        dmil=0;
 383   1        mil=0;
 384   1        centena=0;
 385   1        decena=0;
 386   1        
 387   1         
 388   1        temp=id_h;
 389   1        temp=temp&0xf0;
 390   1        temp>>=4;
 391   1      
 392   1        valor=valor+(pow(16,3))*temp;
 393   1        temp=id_h;
 394   1        temp=temp&0x0f;
 395   1        valor=valor+(pow(16,2))*temp;
 396   1      
 397   1        temp=id_l;
 398   1        temp=temp&0xf0;
 399   1        temp>>=4;
 400   1        valor=valor+(pow(16,1))*temp;
 401   1        temp=id_l;
 402   1        temp=temp&0x0f;
 403   1        valor=valor+(pow(16,0))*temp;
 404   1        numero=valor;
 405   1      
 406   1        while (numero>=0x2710)        // resto 10.000 
 407   1        {
 408   2          numero=numero-0x2710;
 409   2          dmil=dmil+1;
 410   2        }
 411   1        *buffer=dmil|0x30;
 412   1          buffer++;
 413   1        while (numero>=0x03e8)        // resto 1.000
 414   1        {
 415   2          numero=numero-0x03e8;
 416   2          mil=mil+1;
 417   2        }
 418   1        *buffer=mil|0x30;
 419   1          buffer++;
 420   1        while (numero>=0x064)         // resto 100
 421   1        {
 422   2          numero=numero-0x64;
 423   2          centena=centena+1;
 424   2        }
 425   1        *buffer=centena|0x30;
 426   1          buffer++;
C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 8   

 427   1        while (numero>=0x0a)        // resto 10
 428   1        {
 429   2          numero=numero-0x0a;
 430   2          decena=decena+1;
 431   2        }
 432   1        *buffer=decena|0x30;
 433   1        buffer++;
 434   1        *buffer=numero|0x30;
 435   1        buffer++;
 436   1        *buffer=00;
 437   1        
 438   1      }
 439          /*------------------------------------------------------------------------------
 440           Lee el dato del reloj en bloque 
 441          ------------------------------------------------------------------------------*/
 442          void Block_read_clock_ascii(unsigned char *datos_clock)
 443          {
 444   1        unsigned char dato;
 445   1      
 446   1        //dia,mes,año,hora,minutos,segundos,Dia de la semana
 447   1          
 448   1          /*año*/
 449   1          dato=lee_clk(RANO);
 450   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 451   1          datos_clock++;
 452   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 453   1          datos_clock++;
 454   1        
 455   1        /*mes*/
 456   1          dato=lee_clk(RMES);
 457   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 458   1          datos_clock++;
 459   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 460   1          datos_clock++;    
 461   1      
 462   1          /*dia*/
 463   1          dato=lee_clk(RDIA);                       //;bcd_hex(lee_clk(DIA));
 464   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 465   1          datos_clock++;
 466   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 467   1          datos_clock++;
 468   1          
 469   1          
 470   1          /*hora*/            
 471   1          dato=lee_clk(RHORA);
 472   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 473   1          datos_clock++;
 474   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 475   1          datos_clock++;        
 476   1          
 477   1          /*minutos*/   
 478   1          dato=lee_clk(RMIN);   
 479   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 480   1          datos_clock++;
 481   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 482   1          datos_clock++;  
 483   1          *datos_clock=0;
 484   1                      
 485   1      } 
 486          
 487          void Block_read_Clock_Hex(unsigned char *datos_clock)
 488          {
C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 9   

 489   1        
 490   1        /*año*/
 491   1        *datos_clock=bcd_hex(lee_clk(RANO));      
 492   1         datos_clock++;
 493   1        /*mes*/
 494   1        *datos_clock=bcd_hex(lee_clk(RMES));      
 495   1         datos_clock++;
 496   1        /*Dia*/
 497   1        *datos_clock=bcd_hex(lee_clk(RDIA));      
 498   1         datos_clock++;
 499   1        /*hora*/  
 500   1        *datos_clock=bcd_hex(lee_clk(RHORA));     
 501   1         datos_clock++;
 502   1        /*minutos*/ 
 503   1        *datos_clock=bcd_hex(lee_clk(RMIN));      
 504   1         datos_clock++;
 505   1      
 506   1      }
 507          /*
 508          void Block_read_Clock_Hex_bcd(unsigned char *datos_clock)
 509          {
 510              
 511            /*año*/
 512            /**datos_clock=hex_bcd(lee_clk(RANO));      
 513             datos_clock++;
 514            /*mes*/
 515          /*  *datos_clock=hex_bcd(lee_clk(RMES));      
 516             datos_clock++;
 517            /*Dia*/
 518            /**datos_clock=hex_bcd(lee_clk(RDIA));      
 519             datos_clock++;
 520            /*hora*/  
 521            /**datos_clock=hex_bcd(lee_clk(RHORA));     
 522             datos_clock++;
 523            /*minutos*/ 
 524          /*  *datos_clock=hex_bcd(lee_clk(RMIN));      
 525             datos_clock++;
 526          }
 527          */
 528          /*------------------------------------------------------------------------------
 529           Lee el dato del reloj en bloque 
 530          ------------------------------------------------------------------------------*/
 531          void Block_read_Clock(unsigned char *datos_clock)
 532          {
 533   1        /*año*/ 
 534   1        *datos_clock=lee_clk(RANO);     
 535   1         datos_clock++;
 536   1        /*mes*/
 537   1        *datos_clock=lee_clk(RMES);     
 538   1         datos_clock++;
 539   1        /*Dia*/
 540   1        *datos_clock=lee_clk(RDIA);     
 541   1         datos_clock++;
 542   1        /*hora*/  
 543   1        *datos_clock=lee_clk(RHORA);      
 544   1         datos_clock++;
 545   1        /*minutos*/ 
 546   1        *datos_clock=lee_clk(RMIN);     
 547   1         datos_clock++;
 548   1        /*segundos*/  
 549   1        *datos_clock=lee_clk(RSEG);
 550   1        datos_clock++;
C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 10  

 551   1        *datos_clock=00;
 552   1          
 553   1      }
 554          void cond_ini_clock()
 555          {
 556   1        sck=0;          //Reloj
 557   1        rst=0;
 558   1        io=1;
 559   1      }
 560          
 561          /*------------------------------------------------------------------------------
 562          funcion q verifica la fecha maxima de salida 
 563          VERIFICA PAGO (sin_pago)....                                      
 564          SI PAGO, VERIFICA QUE LA FECHA MAX DE SALIDA NO EXCEDE A LA ACTUAL (acceso_ok)              
 565          (0) vencida
 566          (1) ok en rango
 567          
 568          ------------------------------------------------------------------------------*/
 569          char check_fechaOut(char *buffer)
 570          {
 571   1        unsigned long int fecha_inicio,fecha_fin;
 572   1        unsigned char datos_clk[6];
 573   1        char temp;
 574   1        
 575   1        
 576   1          Block_read_Clock_Hex(datos_clk);                              /*leo el clock actual*/
 577   1          fecha_inicio =  datos_clk[0] * 365 + datos_clk[1] * 30 + datos_clk[2] ;
 578   1          fecha_fin = *(buffer ) * 365 + *(buffer + 1) * 30  + *(buffer + 2);
 579   1          
 580   1            
 581   1          if (fecha_fin >= fecha_inicio )           
 582   1          {
 583   2            temp = True;
 584   2          }
 585   1          else
 586   1          {
 587   2            temp = False;
 588   2          }
 589   1            
 590   1      
 591   1        
 592   1        return temp;
 593   1      }
 594          
 595          //*******************************************************************************************
 596          /*
 597          void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos)
 598          {
 599          
 600          
 601            int ano_inT;
 602            bit bisiesto=0;
 603          
 604            unsigned char ano_out, mes_out, dia_out, hora_out, min_out;
 605            unsigned char Horas_Dcto, Minutos_Dcto, Xtemp; 
 606          
 607            bit Tiempo_Dcto=0;
 608          
 609          if ((*(buffer+0x0b)==0x00)&&(*(buffer+0x0c)==0x00)&&(*(buffer+0x0d)==0x00)&&(*(buffer+0x0e)==0x00)&&(*(buf
             -fer+0x0f)==0x00))
 610          {
 611          
C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 11  

 612          //--------------------------------------------------------------------------------------------------------
             -------------------------------------
 613          //  Descuento Maximo 999 minutos  = 16 Horas  39 Minutos
 614          //--------------------------------------------------------------------------------------------------------
             -------------------------------------
 615            if (Val_DctoMinutos >= 60 )
 616            {
 617              Horas_Dcto=Val_DctoMinutos/60;
 618              Minutos_Dcto=Val_DctoMinutos-(Horas_Dcto*60);
 619          
 620            }
 621            else
 622            {
 623              Minutos_Dcto=Val_DctoMinutos;
 624              Horas_Dcto=0;
 625            }
 626          //********************************************************************************************************
             -*************************************
 627          //  Aumenta Primero Minutos
 628          //--------------------------------------------------------------------------------------------------------
             --------------------------------------
 629            if (Minutos_Dcto!=0)
 630            {
 631              min_out=*(buffer+4)+Minutos_Dcto;         
 632              if (min_out>59)                   // Si los minutos no sube de 60 no hay que aumentar nada
 633              {
 634          //----------------------------------------------------
 635                Xtemp=(int)(min_out/60);          // Numero de Horas a aumentar
 636                min_out=min_out-(Xtemp*60);         // Total de minutos
 637          //----------------------------------------------------
 638                hora_out=*(buffer+3)+Xtemp;         /*horas*/
 639          /*
 640                if (hora_out>23)
 641                {
 642                  Xtemp= hora_out/24;             // Numero Dias a aumentar
 643                  hora_out=hora_out-(Xtemp*24);       // Total de Horas
 644          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 645                  dia_out=*(buffer+2)+Xtemp;
 646                  if ((*(buffer+1)==1)||(*(buffer+1)==3)||(*(buffer+1)==5)||(*(buffer+1)==7)||(*(buffer+1)==8)||(*(buffe
             -r+1)==10)||(*(buffer+1)==12))   // Meses de 31 dias
 647                  {
 648                    if (dia_out>31)
 649                    {
 650                      dia_out=dia_out-31;
 651                      mes_out=*(buffer+1)+1;
 652                      if (mes_out>12)
 653                      {
 654                        ano_out=*(buffer+0)+1;
 655                        mes_out=1;
 656                      }
 657                      else
 658                      {
 659                        ano_out=*(buffer+0);
 660                      }
 661                    }
 662                    else
 663                    {
 664                      mes_out=*(buffer+1);                        /*mes*/
 665            /*          ano_out=*(buffer+0);                        /*año*/
 666            /*        } 
 667                  }
C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 12  

 668                  else if ((*(buffer+1)==4)||(*(buffer+1)==6)||(*(buffer+1)==9)||(*(buffer+1)==11))                   // Meses de
             - 30 dias
 669                  {
 670                    if (dia_out>30)
 671                    {
 672                      dia_out=dia_out-30;
 673                      mes_out=*(buffer+1)+1;
 674                      ano_out=*(buffer+0);          
 675                    }
 676                    else
 677                    {
 678                      mes_out=*(buffer+1);
 679                      ano_out=*(buffer+0);  
 680                    }
 681          
 682                  }
 683                  else if (*(buffer+1)==2)                                        // Febtrero Es biciesto?
 684                  {
 685          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 686                    ano_inT=*(buffer+0)+2000;
 687                    bisiesto=0;
 688          
 689          /*
 690                    float flotante=12.345;
 691                    int entero;
 692          
 693                    entero=(int)flotante;
 694          */
 695            
 696          /*          division=(ano_inT/4);
 697                    intpart=division;
 698                    decpart= ano_inT - (intpart*4);
 699                    if (decpart==0)
 700                    {
 701                      division=(ano_inT/10);
 702                        intpart = division;
 703                        decpart = ano_inT - (intpart*10);
 704                      if (decpart==0)
 705                      {
 706                        division=(ano_inT/40);
 707                          intpart = division;
 708                          decpart = ano_inT - (intpart*40);
 709          
 710          
 711                        if (decpart==0)
 712                        {
 713                          bisiesto=1;
 714                        }
 715                        else
 716                        {
 717                          bisiesto=0;
 718                        }
 719                      }
 720                      else
 721                      {
 722                        bisiesto=1;
 723                      }
 724                    }
 725          */
 726          
 727            /*        if ((*(buffer+0)==16)||(*(buffer+0)==20)||(*(buffer+0)==24)||(*(buffer+0)==28)||(*(buffer+0)==32)||
C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 13  

             -(*(buffer+0)==36))
 728                    {
 729                      bisiesto=1;
 730                    }   
 731          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------          
 732                    if (bisiesto==1)
 733                    {
 734                      if (dia_out>29)
 735                      {
 736                        ano_out=*(buffer+0);
 737                        dia_out=dia_out-29;
 738                        mes_out=*(buffer+1)+1;
 739                    
 740                      }
 741                      else
 742                      {
 743                        ano_out=*(buffer+0);  
 744                        dia_out=dia_out;
 745                        mes_out=*(buffer+1);
 746                      }
 747                    }
 748                    else
 749                    {
 750                      if (dia_out>28)
 751                      {
 752                        dia_out=dia_out-28;
 753                        mes_out=*(buffer+1)+1;
 754                        ano_out=*(buffer+0);
 755                      }
 756                      else
 757                      {
 758                        dia_out=dia_out;
 759                        mes_out=*(buffer+1);
 760                        ano_out=*(buffer+0);  
 761                      }
 762                    }
 763          //--------------------------------------------------------------------------------------------------------
             --------------------------------------
 764                  }
 765                  else                                                // Error fecha
 766                  {
 767                    dia_out=dia_out;
 768                    mes_out=*(buffer+1);
 769                    ano_out=*(buffer+0);  
 770                  }
 771                }
 772                else
 773                {
 774                  dia_out=*(buffer+2);
 775                  mes_out=*(buffer+1);
 776                  ano_out=*(buffer+0);
 777                }
 778              }
 779              else
 780              {
 781                hora_out=*(buffer+3);
 782                dia_out=*(buffer+2);
 783                mes_out=*(buffer+1);
 784                ano_out=*(buffer+0);
 785              }
 786            }
C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 14  

 787            else
 788            {
 789              min_out=*(buffer+4);
 790              hora_out=*(buffer+3);
 791              dia_out=*(buffer+2);
 792              mes_out=*(buffer+1);
 793              ano_out=*(buffer+0);
 794            }
 795          //********************************************************************************************************
             -*************************************
 796          //  AUMENTA HORAS
 797          //--------------------------------------------------------------------------------------------------------
             --------------------------------------
 798              if (Horas_Dcto!=0)
 799              {
 800                  hora_out=hora_out+Horas_Dcto;
 801                  if (hora_out>23)
 802                  {
 803                    Xtemp= hora_out/24;             // Numero Dias a aumentar
 804                    hora_out=hora_out-(Xtemp*24);       // Total de Horas
 805            //-------------------------------------------------------------------------------------------------------
             ----------------------------------------
 806                    dia_out=dia_out+Xtemp;
 807                    if ((mes_out==1)||(mes_out==3)||(mes_out==5)||(mes_out==7)||(mes_out==8)||(mes_out==10)||(mes_out==12
             -))    // Meses de 31 dias
 808                    {
 809                      if (dia_out>31)
 810                      {
 811                        dia_out=dia_out-31;
 812                        mes_out=mes_out+1;
 813                        if (mes_out>12)
 814                        {
 815                          ano_out=ano_out+1;
 816                          mes_out=1;
 817                        }
 818                        else
 819                        {
 820                          ano_out=ano_out;
 821                        }
 822                      }
 823                    }
 824                    else if ((mes_out==4)||(mes_out==6)||(mes_out==9)||(mes_out==11))                   // Meses de 30 dias
 825                    {
 826                      if (dia_out>30)
 827                      {
 828                        dia_out=dia_out-30;
 829                        mes_out=mes_out+1;
 830                        ano_out=ano_out;          
 831                      }
 832                      else
 833                      {
 834                        mes_out=mes_out;
 835                        ano_out=ano_out;  
 836                      }
 837                    }
 838                    else if (mes_out==2)                                        // Febtrero Es biciesto?
 839                    {
 840          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 841                      ano_inT=ano_out+2000;
 842                      bisiesto=0;
 843          
C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 15  

 844          
 845          /*            division=(ano_inT/4);
 846                      intpart = division;
 847                      decpart= ano_inT - (intpart*4);
 848            
 849            
 850                      if (decpart==0)
 851                      {
 852                        division=(ano_inT/10);
 853                          intpart = division;
 854                          decpart = ano_inT - (intpart*10);
 855                        if (decpart==0)
 856                        {
 857                          division=(ano_inT/40);
 858                            intpart = division;
 859                            decpart = ano_inT - (intpart*40);
 860                          if (decpart==0)
 861                          {
 862                            bisiesto=1;
 863                          }
 864                          else
 865                          {
 866                            bisiesto=0;
 867                          }
 868                        }
 869                        else
 870                        {
 871                          bisiesto=1;
 872                        }
 873                      }
 874          */
 875            /*          if ((ano_out==16)||(ano_out==20)||(ano_out==24)||(ano_out==28)||(ano_out==32)||(ano_out==36))
 876                      {
 877                        bisiesto=1;
 878                      }   
 879          
 880          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------          
 881                      if (bisiesto==1)
 882                      {
 883                        if (dia_out>29)
 884                        {
 885                          dia_out=dia_out-29;
 886                          mes_out=mes_out+1;
 887                          ano_out=ano_out;            
 888                        }
 889                        else
 890                        {
 891                          dia_out=dia_out;
 892                          mes_out=mes_out;
 893                          ano_out=ano_out;
 894                        }
 895                      }
 896                      else
 897                      {
 898                        if (dia_out>28)
 899                        {
 900                          dia_out=dia_out-28;
 901                          mes_out=mes_out+1;
 902                          ano_out=ano_out;                          
 903                        }
 904                      }
C51 COMPILER V9.59.0.0   CLOCK                                                             07/14/2020 08:20:39 PAGE 16  

 905            //-------------------------------------------------------------------------------------------------------
             ----------------------------------------
 906                    }
 907            
 908                  }
 909              }
 910          
 911          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 912            *(buffer+0x0b)=ano_out;
 913            *(buffer+0x0c)=mes_out;
 914            *(buffer+0x0d)=dia_out;
 915            *(buffer+0x0e)=hora_out;
 916            *(buffer+0x0f)=min_out;   
 917          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 918            }
 919            
 920          
 921          }
 922          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2726    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      57
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
