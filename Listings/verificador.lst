C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERIFICADOR
OBJECT MODULE PLACED IN .\Objects\verificador.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verificador.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\verificador.lst) TABS(2) OBJECT(.\Objects\verificador.obj)

line level    source

   1          /*
   2              FUNCIONES PARA DISPENSADOR                                *
   3          */
   4          #include<verificador.h>
   5          #include <reg51.h>
   6          
   7          /*funciones prototipo externas */
   8          
   9          extern void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena);
  10          extern void EscribirCadenaSoft(unsigned char tamano_cadena,unsigned char tipo);
  11          
  12          
  13          extern void send_portERR(unsigned char cod_err);
  14          
  15          
  16          
  17          
  18          extern void PantallaLCD(unsigned char cod_msg);
  19          extern void PantallaLCD_LINEA_2(unsigned char cod_msg, unsigned char *buffer);
  20          
  21          //extern void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  22          
  23          
  24          /*funciones prototipo de clock*/
  25          
  26          extern void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos);
  27          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  28          void Block_read_clock_ascii(unsigned char *datos_clock);
  29          void ByteHex_Decimal(unsigned char *buffer,unsigned char valorhex);
  30          void Two_ByteHex_Decimal(unsigned char *buffer,unsigned char id_h,unsigned char id_l);
  31          extern char check_fechaOut(char *buffer);
  32          extern unsigned char lee_clk (unsigned char dir_clk);
  33          extern unsigned char bcd_hex (unsigned char l_data);
  34          extern void hex_ascii(unsigned char * datos,unsigned char * fecha_asii);
  35          extern void  hora_entrada_vehiculo(unsigned char *Atributos_Expedidor);
  36          
  37          extern void Cmd_Lpr_Int();
  38          extern void Delay_10ms(unsigned int cnt);
  39          
  40          /*funciones prototipo string */
  41          
  42          extern char  *strcat  (char *s1, const char *s2);
  43          extern char  *strcpy  (char *s1, const char *s2);
  44          extern unsigned int strlen  (const char *);
  45          extern char   strcmp  (const char *s1, const char *s2);
  46          
  47          /*funciones prototipo de EEprom*/
  48          
  49          extern unsigned char *Lee_No_Ticket();
  50          void Incremente_Ticket();
  51          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  52          
  53          /*funciones prototipo del transporte MODULO io_sensores*/
  54          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 2   

  55          extern unsigned char  ValidaSensoresPaso(void);
  56          unsigned char Valida_Sensor1_Auto();
  57          extern unsigned char Dir_board();
  58          extern void sel_Pulsa(void);
  59          void sel_Sensor2(void);
  60          char ValidaSensor(void);
  61          unsigned char Dir_Board_Monitor();
  62          extern void Botton ();
  63          
  64          /*funciones prototipo del transporte MODULO TIBBO*/
  65          
  66          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  67          extern void Debug_txt_Tibbo(unsigned char * str);
  68          extern void Debug_chr_Tibbo(unsigned char Dat);
  69          extern void Debug_HexDec(unsigned char xfc);
  70          extern void Debug_Buffer_rs232_lcd(unsigned char *str,unsigned char num_char);
  71          void Debug_txt_rs232(unsigned char * str);
  72          
  73          /*funciones prototipo del transporte MODULO LINTECH*/
  74          
  75          extern void Aut_Card_check_Status(void);
  76          extern void Check_Status(unsigned char Detalle);
  77          extern void Dwload_EEprom (void);
  78          extern void Mov_Card(unsigned char Posicion);
  79          extern void Card_Insercion(char Tipo);
  80          extern void RD_MF(unsigned char Sector, unsigned char Bloque);
  81          extern void WR_MF(unsigned char Sector, unsigned char Bloque,unsigned char *buffer);  
  82          extern void LoadVerify_EEprom(void);
  83          extern void Clave_Seguridad_S2(void);
  84          extern void Unique_Identifier_UID(void);
  85          extern void Power_off(void);
  86          
  87          /*funcion prototipo monitor*/
  88          
  89          extern void clear_placa();
  90          extern void Rx_Monitor();
  91          
  92          /*funcion prototipo pto paralelo*/
  93          
  94          void  send_port(unsigned char *buffer_port, unsigned char length_char);
  95          
  96          /*funcion prototipo programacion*/
  97          extern unsigned char *Addr_Horarios();
  98          
  99          extern int    atoi (const char *s1);
 100          /*io sensores */
 101          
 102          sbit DataIn = P1^1;         //  dato de las entradas    
 103          sbit sel_A = P3^5;          //Pulsador                        *
 104          sbit sel_B = P3^6;          //Entrada Sensor 2                    *
 105          sbit sel_C = P3^7;          //Entrada Sensor 1                    *
 106          
 107          sbit lock = P1^7;           //Relevo  
 108          sbit Atascado_GP0_PIN_3 = P0^3;       //Rele de on/off del verificador o transporte
 109          sbit led_err_imp = P0^2;      //Error   
 110          
 111          /*pines de ip tibbo*/
 112          
 113          sbit rx_ip = P0^0;    
 114          /*variables externas*/
 115          
 116          extern unsigned char g_cEstadoComSoft;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 3   

 117          extern unsigned char ValTimeOutCom;
 118          extern unsigned char g_cContByteRx;
 119          extern unsigned char xdata Buffer_Rta_Lintech[];
 120          
 121          extern unsigned int T_GRACIA;                                       /*tiempo de gracia del parqueo*/
 122          extern unsigned char Timer_wait;
 123          extern unsigned int  SIN_COBRO;
 124          extern unsigned char  Tarjeta_on;
 125          extern unsigned char cnt__ask_off;
 126          extern  unsigned char Tipo_Vehiculo;
 127          extern  unsigned char  Debug_Tibbo;                                                   /*variable q define expedicion de tarjetas 1=
             - automatico 0= a boton configurable en eeprom*/
 128          extern idata unsigned char placa[];
 129          extern unsigned char precarga;
 130          
 131          /*externo bit*/
 132          
 133          extern bit aSk;
 134          extern bit buffer_ready;
 135          extern bit placa_ready;
 136          extern bit    PULSADOR_BOTTON;
 137          extern bit pto_paraleo;
 138          
 139          /*----------------------------------------------------------------------------
 140          Definiciones de sequencias de verificador y expedidor
 141          ------------------------------------------------------------------------------*/
 142          
 143          #define SEQ_INICIO                      0X00  
 144          #define SEQ_RESPUESTA_TRANSPORTE        0X01
 145          #define SEQ_CMD_ACEPTADO                0x02
 146          #define SEQ_MOVER_CARD_RF               0x03
 147          //#define SEQ_CARD_INSERCION_ON           0x04
 148          #define SEQ_TIPO_CARD                   0X05
 149          #define SEQ_LOAD_PASSWORD               0X06
 150          #define SEQ_READ_SECTOR_BLOQUE          0X07
 151          #define SEQ_WRITE_SECTOR_BLOQUE         0X08
 152          #define SEQ_CAPTURE_CARD                0X09
 153          #define SEQ_CARD_INSERCION_OFF          0x0a
 154          #define SEQ_EXPULSAR_CARD               0x0b
 155          #define SEQ_LOAD_EEPROM                 0x0c
 156          #define SEQ_FRONT_CARD                  0x0d
 157          #define SEQ_ESPERA_VEHICULO_ENTRE       0x0e
 158          #define SEQ_DETAIL_CARD                 0x0f
 159          #define SEQ_PTO_PARALELO                0x10
 160          #define SEQ_WAIT_PLACA                  0x11
 161          #define SEQ_UID                         0X12
 162          #define SEQ_LPR                         0X13  
 163          #define SEQ_CLASE_TARJETAS                0X14
 164          #define SEQ_CAPTURE_CARD_LOOP           0X15
 165          #define SEQ_POWER_OFF                   0X16
 166          #define SEQ_POWER_ON                    0X17
 167          #define SEQ_SECOND_PASSWORD             0X18
 168          #define SEQ_PLACA                       0X19
 169          //#define SEQ_DETAIL_CARD_TRAMPA          0X1A
 170          #define SEQ_REELER_CARD_SECTOR1_BLOQUE1 0X1B
 171          #define SEQ_PRECARGA                    0X1C
 172          #define SEQ_INGRESO_PRECARGA            0X1D
 173          #define SEQ_PRESENCIA_VEHICULAR         0X1E
 174          
 175          /*----------------------------------------------------------------------------
 176          Definiciones de sequencias de tareas del verificador y expedidor
 177          ------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 4   

 178          #define TAREA_SENSORES_TRANSPORTE             0X00
 179          #define TAREA_PRESENCIA_VEHICULAR             0X01  
 180          #define TAREA_TIPO_TARJETA                    0X02
 181          #define TAREA_LECTURA_TARJETA_SECTOR_BLOQUE   0x03
 182          #define TAREA_WRITE_TARJETA_SECTOR_BLOQUE     0X04
 183          #define TAREA_OPEN_BARRERA                    0X05
 184          #define TAREA_WRITE_PLACA_CARD                0x06
 185          //#define TAREA_TIPO_MENSUAL                    0x07
 186          #define TAREA_UID                             0X08
 187          #define TAREA_PRESENCIA_ROTACION              0X09
 188          /*----------------------------------------------------------------------------
 189           definiciones de lintech en la inicializacion de expedidor o verificador
 190          ------------------------------------------------------------------------------*/
 191          
 192          #define INICIA_LINTECH          0x30
 193          #define SEQ_CAPTURE_DATOS_INI   0x31
 194          #define GRABA_EEPROM            0x32
 195          #define SEQ_CAPTURA_OK_EEPROM   0X33
 196          #define FIN_OK                  0x00
 197          
 198          
 199          #define True                    0x01
 200          #define False                   0x00
 201          /*----------------------------------------------------------------------------
 202           Definicion de datos asociados al buffer de resetcion del dato del trnasporte 
 203          
 204          ------------------------------------------------------------------------------*/
 205          
 206          
 207          #define ON    1
 208          #define OFF   0
 209          /*----------------------------------------------------------------------------
 210           ERRORES pto serie 
 211          
 212          ------------------------------------------------------------------------------*/
 213          #define REENVIA_TRAMA     0
 214          #define ESPERA_MAS_TIEMPO 1
 215          /*----------------------------------------------------------------------------
 216           definiciones de lintech en la inicializacion de expedidor o verificador
 217           funcion usada en lintech que me debuelve la respuesta de comunicacion del expedidor
 218           o verificador Trama_Validacion_P_N()
 219          RSPT_TRP_OK             (0) respuesta_transporte_oksignifica que la trama es valida y continua en el proceso
 220          NO_RSPD_TRP_PTO_COM     (1) no_responde_trasnporte_pto_com se cumple el tiempo de espera
 221          ESPR_RSPT_TRP_TRAMA     (2)Espera_respuesta_transporte_trama
 222          ERROR_TRP_TRAMA         (3) error_transpote_trama
 223          ------------------------------------------------------------------------------*/
 224          #define   RSPT_TRP_OK           0
 225          #define   NO_RSPD_TRP_PTO_COM   1
 226          #define   ESPR_RSPT_TRP_TRAMA   2
 227          #define   ERROR_TRP_TRAMA       3
 228          
 229          
 230          /*----------------------------------------------------------------------------
 231           definiciones de lintech en el comando Check_Status
 232          ------------------------------------------------------------------------------*/
 233          
 234          #define SENSOR_DETAIL       0x31
 235          #define SENSOR_NORMAL       0x30
 236          
 237          /*------------------------------------------------------------------------------
 238           definiciones de lintech en el comando Card_Insercion
 239          ------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 5   

 240          
 241          #define Habilita        0x30
 242          #define Inhabilita      0x31
 243          
 244          /*------------------------------------------------------------------------------
 245          Definicion de Lintech en el comando Inicializa
 246          ------------------------------------------------------------------------------*/
 247          
 248          #define TO_FRONT        '0'
 249          #define CAPTURE_BOX     '1'
 250          #define SIN_MOVIMIENTO  '3'
 251          
 252          /*------------------------------------------------------------------------------
 253          Definicion de Lintech en el comando mover tarjeta (Mov_Card)
 254          MovPos_Front        '0'   -> mueve  tarjeta al frente pero no la suelta
 255          MovPos_IC           '1'   ->mueve la tarjeta en posicion de read/write IC
 256          MovPos_RF           '2'   ->mueve tarjeta a RF card read/write
 257          MovPos_Capture      '3'   ->captura la tarjeta
 258          MovPos_EjectFront   '9'   ->lanza la tarjeta del mecanismo
 259          
 260          ------------------------------------------------------------------------------*/
 261          
 262          #define   MovPos_Front        '0'   
 263          #define   MovPos_IC           '1'
 264          #define   MovPos_RF           '2'
 265          #define   MovPos_Capture      '3'
 266          #define   MovPos_EjectFront   '9'
 267          
 268          /*------------------------------------------------------------------------------
 269          Definicion de la trama Lintech de las respuestas de los cmd
 270          ------------------------------------------------------------------------------*/
 271          
 272          #define Pos_Length          3
 273          #define Pos_TipoResp        4
 274          #define ERROR_COLLECT_CARD  6
 275          #define Pos_St0             7
 276          #define Pos_St1             8
 277          #define Pos_St2             9
 278          #define Pos_IniDatMF        0x0a
 279          #define Card_type_H         0x0a
 280          #define Card_type_L         0x0b
 281          #define Rtype               0x0A
 282          /*------------------------------------------------------------------------------
 283          Definicion del estado de st0,st1,st2 de la trama Lintech 
 284          NO_CARDS_IN_MCNSM -> No tiene tarjetas en el mecanismo      sto=0
 285          CARD_IN_MOUTH     -> hay una tarjeta dentro del bessel      st0=1
 286          CARD_OK_READ_RF   -> Tarjeta en posicion para leer/escribir dentro del mecanismo st0=2
 287          NO_HAVE_CARDS     -> no tiene tarjetas en el deposito st1=0
 288          LOW_NIVEL_CARDS   -> nivel bajo de tarjetas en el deposito  st1=1
 289          FULL_CARD         -> Deposito de tarjetas esta lleno        st1=2
 290          ------------------------------------------------------------------------------*/
 291          
 292          
 293          #define NO_CARDS_IN_MCNSM   '0'
 294          #define CARD_IN_MOUTH       '1'
 295          #define CARD_OK_READ_RF     '2'
 296          #define NO_HAVE_CARDS       '0'
 297          #define LOW_NIVEL_CARDS     '1'
 298          #define FULL_CARD           '2'
 299          /*----------------------------------------------------------------------------
 300          Comprobacion automatica del tipo de tarjeta 
 301          checking RF card type
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 6   

 302          Card_type_H   Card_type_L  explicacion
 303              0             0           tarjeta desconocida
 304              1             0           MF50
 305              1             1           MF70
 306              1             2           MF_UL
 307              2             0           TYPE_A_CPU
 308          ------------------------------------------------------------------------------*/
 309          #define MF50_HIGH             '1'
 310          #define MF50_LOW              '0'
 311          #define MF70                  '1'
 312          #define OPERATE_FAIL          0X6F
 313          
 314          /*----------------------------------------------------------------------------
 315          definicion de recepcion serial 
 316          ------------------------------------------------------------------------------*/
 317          
 318          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
 319          
 320          /*----------------------------------------------------------------------------
 321          tiempo de delay entre funciones
 322          ------------------------------------------------------------------------------*/
 323          
 324          #define   TIME_CARD         100   //50
 325          #define   TIME_WAIT         18
 326          #define   TIME_PULSADOR     5
 327          
 328          /*----------------------------------------------------------------------------
 329          definicion de datos de trama lintech
 330          ------------------------------------------------------------------------------*/
 331          
 332          
 333          #define   STX_LINTECH       0xf2
 334          
 335          /*----------------------------------------------------------------------------
 336          msj de lcd tarjeta y lcd serie
 337          ------------------------------------------------------------------------------*/
 338          /*Los cmd PRMR son enviados por el primario*/
 339          #define PRMR_ERROR_LOOP         0XE0
 340          #define ERROR_LOOP              170
 341          #define PRMR_ERROR_COD_PARK     0XE5
 342          #define ERROR_COD_PARK          171
 343          #define PRMR_TARJETA_INVALIDA   0XE1
 344          #define PULSE_BOTON             172
 345          #define PRMR_TARJETA_SIN_FORMATO  0xDF
 346          #define TARJETA_SIN_FORMATO       173
 347          
 348          #define PRMR_NO_CARD_MENSUAL          0XFC
 349          #define NO_CARD_MENSUAL         176
 350          #define TARJETA_INVALIDA        177
 351          
 352          #define PRMR_NO_ROTACION              0XFD
 353          
 354          #define PRMR_SIN_SALIDA             0XE9
 355          #define SIN_SALIDA              178
 356          #define REGISTRA_INGRESO        179
 357          
 358          #define PRMR_TARJETA_VENCIDA          0XEC
 359          #define TARJETA_VENCIDA         180
 360          #define PRMR_ERROR_TIPO_VEHICULO      0XF8
 361          #define PRMR_MENSUAL_FUERA_HORARIO    0Xb5
 362          #define MENSUAL_FUERA_HORARIO   181
 363          #define ERROR_MF1               0XE2
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 7   

 364          #define HORARIO_NO_PROG         182
 365          
 366          
 367          
 368          #define BIENVENIDO              0XFE
 369          #define NO_CARD                 0xFA  
 370          
 371          #define RETIRE_TARJETA          0XA1
 372          
 373          #define LOW_CARD                0x01
 374          
 375          #define AUDIO_ENTRADA     0XA0
 376          #define AUDIO_CAJA        0XA1
 377          #define AUDIO_GRACIAS     0XA2
 378          /*----------------------------------------------------------------------------
 379          definiciones para, el debuger. saber si la trama es enviada, o la trama es de respuesta
 380          ------------------------------------------------------------------------------*/
 381          
 382          #define   ENVIADOS          0X0
 383          #define   RESPUESTA         0X01
 384          #define   SIN_MSJ           0X02
 385          /*
 386          definicion  de daos del reloj
 387                    */
 388          
 389          #define RDIA            0x87
 390          #define RMES            0x89
 391          #define RANO            0x8D
 392          #define RDIA_SEMANA     0x8B
 393          #define RHORA           0x85
 394          #define RMIN            0x83
 395          #define Sabado          7
 396          #define Domingo         1
 397          /*----------------------------------------------------------------------------
 398          definiciones de la tarjeta MF tipo de cliente esto esta en la posicion (0) de la memoria MF
 399          (0) si el dato es cero esta inactiva
 400          (1) activa o ROTACION
 401          (2) mensualidad
 402          ------------------------------------------------------------------------------*/
 403          enum Tipos_MF_TIPO_TARJETA{
 404            INACTIVA,         
 405            ROTACION,           
 406            MENSUALIDAD,
 407            PREPAGO,
 408            CORTESIA,
 409            LOCATARIO,
 410            TARJETA_PERDIDA = 0X10,
 411            INHABILITADA = 0X11
 412          };
 413          /*----------------------------------------------------------------------------
 414          posicion de  MF  bloque 1 sector 1
 415          (0) tipo de tarjeta 
 416          (01) el id del cliente
 417          (03)codigo del parqueadero  
 418          ------------------------------------------------------------------------------*/
 419          #define   MF_TIPO_TARJETA   0X00
 420          #define   MF_COD_PARK       0x01      //MF_ID_CLIENTE
 421          #define   MF_ID_CLIENTE     0x03      //MF_COD_PARK
 422          
 423          /*----------------------------------------------------------------------------
 424          posicion de  MF bloque 2 sector 1
 425          (00) donde esta grabado la fecha de entrada (año,mes,dia,hora,minutos) estan en hex  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 8   

 426          (0b) donde esta grabado la fecha de salida (año,mes,dia,hora,minutos) estan en hex 
 427          ------------------------------------------------------------------------------*/
 428          
 429          #define   MF_FECHA_INT      0X00        /*año,mes,dia,hora,minutos*/
 430          
 431          
 432          #define   MF_DCTO           0x05        /*Tipo de descuento (00)sin descuento, (01xx xxxx) 0x40 fija fecha de salida
             -,
 433                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto por diner
             -o */
 434          #define   MF_LSB            0x06
 435          
 436          #define   MF_TIPO_VEHICULO  0x08              /*tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 tractomula*/
 437          
 438          #define   MF_IN_PAGO        0x09
 439          #define   MF_APB            0x0A            /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 440          
 441          #define   MF_FECHA_OUT      0X0B        /*año,mes,dia,hora,minutos*/
 442          
 443          #define   MF_MENSUAL_ANO      0X05
 444          #define   MF_MENSUAL_MES      0X06
 445          #define   MF_MENSUAL_DIA      0X07
 446          
 447          #define   MF_UID_0      0X04
 448          #define   MF_UID_1      0X05
 449          #define   MF_UID_2      0X06
 450          #define   MF_UID_3      0X07
 451          
 452          #define   MF_EXPIRA_ANO     0X08
 453          #define   MF_EXPIRA_MES     0X09
 454          #define   MF_EXPIRA_DIA     0X0A
 455          
 456          #define   HABILITA_ADDR     15
 457          #define   Segundo_Tiempo    16
 458          
 459          enum Hora_Minutos_addr{
 460            Hora_High_addr_Desde = 7, Hora_Low_addr_Desde = 8, Minutos_High_addr_Desde = 9, Minutos_Low_addr_Desde = 
             -10,
 461            Hora_High_addr_Hasta = 11, Hora_Low_addr_Hasta = 12, Minutos_High_addr_Hasta = 13, Minutos_Low_addr_Hasta
             - = 14
 462          };
 463          
 464          enum Estados_Expedidor{
 465           EstadoActual,
 466           EstadoPasado,
 467           EstadoFuturo,
 468           TareadelCmd  
 469          };
 470          enum expedidor {
 471           Sector,        
 472           Bloque,        
 473           Tipo_Tarjeta,
 474           Apb,
 475           Horario,
 476           Pico_Placa,
 477           Type_Vehiculo,
 478           Uid_0,
 479           Uid_1,
 480           Uid_2,
 481           Uid_3,
 482           Expira_ano,
 483           Expira_mes,
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 9   

 484           Expira_dia,
 485           DateTime_year,
 486           DateTime_month,
 487           DateTime_day,
 488           DateTime_hour,
 489           DateTime_minutes 
 490           
 491          };
 492          /*tipos de APB antipassback*/
 493          enum Tipos_MF_APB{
 494            
 495            APB_INICIADO,       
 496            APB_INT,              
 497            APB_OUT,              
 498            APB_NO              
 499          };
 500          /*tipo de vehiculo*/
 501          /*Sectores y bloques de Mf*/
 502          enum MF_Sector_Bloque{
 503            Sector_0,
 504            Sector_1,
 505            Sector_2,
 506            Bloque_0 = 0,
 507            Bloque_1 = 1,
 508            Bloque_2 = 2
 509          };
 510          /*comandos pto paralelo*/
 511          enum CMD_Trama_Pto_Paralelo{
 512            STX=02,
 513            CMD_PTO_PARALELO_EXPEDIDOR='a',
 514            ETX= 03,
 515            NULL=0,
 516            CMD_MONITOR_EXPEDIDOR='E',
 517            CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL='M'
 518          };
 519          enum EE_AntiPassBack{
 520            APB_INHABILITADO_SOFT,
 521            APB_HABILITADO_SOFT
 522          };  
 523          enum Tipos_Vehiculos{
 524              AUTOMOVIL,          
 525              MOTO,
 526              BICICLETA
 527          };  
 528          
 529          /*DATOS DE CONFIGURACION EEPROM*/
 530          #define EE_ID_CLIENTE           0x0000
 531          #define EE_ID_PARK              0x0002
 532          #define EE_DEBUG                0x0008
 533          #define EE_USE_LPR              0x000A
 534          #define EE_CARD_AUTOMATIC_BOTON 0x000f
 535          #define EE_HABILITA_APB         0x0010
 536          #define EE_PLACA                0X0011
 537          #define EE_VALIDA_TIPO_VEHICULO_MENSUAL 0X0014
 538          #define EE_HABILITA_APB_MENSUAL 0X0015
 539          #define EE_MENSUAL_BOCA_ON_OFF  0X0016
 540          #define EE_PRECARGA             0X0017
 541          
 542          /*----------------------------------------------------------------------------
 543          Definicion de varaibles globales del objeto
 544          ------------------------------------------------------------------------------*/
 545          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 10  

 546          static unsigned char Estado=INICIA_LINTECH;
 547          bit MenSual = False;                      /*bit que informa si esta activo mensual*/
 548          /*------------------------------------------------------------------------------
 549          
 550          ------------------------------------------------------------------------------*/
 551          /*unsigned char Captura_Expulsa()
 552          {
 553            unsigned char Estado_expedidor;
 554            
 555            
 556            if(MenSual !=  True)
 557            {
 558              Estado_expedidor=SEQ_CAPTURE_CARD_LOOP; //SEQ_CAPTURE_CARD;                                       
 559            }
 560            else
 561            {
 562            
 563            Estado_expedidor = SEQ_EXPULSAR_CARD;//SEQ_CARD_INSERCION_OFF;  
 564            } 
 565          
 566          
 567          return  Estado_expedidor;
 568          }*/
 569          /*------------------------------------------------------------------------------
 570          funcion que valida la trama del verificador o transporte lintech
 571          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 572          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 573          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
 574          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 575          
 576          
 577          ------------------------------------------------------------------------------*/
 578          
 579          char Trama_Validacion_P_N()
 580          {
 581   1        char Trama_Validacion_P_N=ESPR_RSPT_TRP_TRAMA;                                /*espera respuesta del transporte*/
 582   1            
 583   1            if ((ValTimeOutCom==1)||(buffer_ready==1)|| (ValTimeOutCom > TIME_CARD) )
 584   1            {
 585   2              if (buffer_ready==1)
 586   2              {
 587   3                buffer_ready=0;
 588   3                  
 589   3              
 590   3                if (Buffer_Rta_Lintech[Pos_TipoResp]=='P')
 591   3                {
 592   4                          
 593   4                  Trama_Validacion_P_N=RSPT_TRP_OK;                                       /*trama ok*/
 594   4                    
 595   4                }
 596   3                else if (Buffer_Rta_Lintech[Pos_TipoResp]=='N')
 597   3                {
 598   4                  
 599   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;                                 /*error de trama*/
 600   4                  
 601   4                }
 602   3                else
 603   3                {
 604   4                  Debug_txt_Tibbo((unsigned char *) "Respuesta  DESCONOCIDA \r\n");       /*la respuesta es desconocida*
             -/
 605   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;   
 606   4                  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 11  

 607   4                }
 608   3              }
 609   2              else
 610   2              {
 611   3                          
 612   3                Trama_Validacion_P_N=NO_RSPD_TRP_PTO_COM;                                 /*pto serie no responde */
 613   3                                                  
 614   3              }
 615   2      
 616   2            }
 617   1            
 618   1        return Trama_Validacion_P_N;
 619   1      }
 620          /*------------------------------------------------------------------------------
 621          funcion de error de respuesta pto serie
 622          
 623          variable en uart. cnt__ask_off=cuenta los numeros de error pto serie y reset de transporte 
 624          se limpia cuando llega la respuesta del transporte. 
 625          Rele_Atasco = es un I/O del Mc que activa / inhabilita el rele
 626          ON    (1) esta activo 
 627          OFF   (0) inhactivo 
 628          REENVIA_TRAMA   1
 629          ESPERA_MAS_TIEMPO 0
 630          cnt_espera_ask_on= cuenta el tiempo de ASK que esta activo,sin que le llegue
 631                             la trama completa, al  5 tiempos borra el ask y retrasmite el cmd
 632          
 633          error_rx_pto= (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 634                      = (1)= REENVIA_TRAMA reenvia la trama al transporte
 635          
 636          cnt__ask_off= varible global esta definida en pto serie y es un contador , que 
 637          se limpia cada vez que la trama a llegado completa y validada
 638          
 639          aSk= significa que llego al pto serie el 06 = ask donde el transporte dice que a recibido el cmd
 640          esta ejecutando y nos enviara la respuesta,necesita tiempo esta bit esta definino en el modulo uart es glo
             -bal
 641          
 642          ------------------------------------------------------------------------------*/
 643          unsigned char error_rx_pto(void)
 644          {
 645   1      
 646   1      static unsigned cnt_espera_ask_on=0;
 647   1      unsigned char error_rx_pto=ESPERA_MAS_TIEMPO;
 648   1      
 649   1          
 650   1                
 651   1            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...");
 652   1            Debug_chr_Tibbo (cnt__ask_off); 
 653   1            Debug_chr_Tibbo (cnt_espera_ask_on);
 654   1            Debug_chr_Tibbo (error_rx_pto);
 655   1            Debug_txt_Tibbo((unsigned char *) "\r\n");
 656   1            if (aSk==OFF)
 657   1            
 658   1            { 
 659   2                cnt__ask_off++;                                                                   /*cuento el error*/                                                               
 660   2              if(cnt__ask_off>=10)
 661   2              { 
 662   3                Debug_txt_Tibbo((unsigned char *) "ATASCADO RESET\r\n");                                                                      /*no conte
             -sta debe reset el transporte*/
 663   3                Atascado_GP0_PIN_3 = ON;                                                                    /*off el rele de reset del verificador*/    
 664   3                Delay_10ms(110);
 665   3                cnt__ask_off=0;                                                                   /*limpio ls errores*/
 666   3                cnt_espera_ask_on=0;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 12  

 667   3                error_rx_pto=ESPERA_MAS_TIEMPO;                                                   /**/
 668   3                Atascado_GP0_PIN_3 = OFF; 
 669   3                Delay_10ms(110);                                                                  /*On el rele de reset del verificador*/   
 670   3                ValTimeOutCom=TIME_CARD;
 671   3              }
 672   2              else;
 673   2              {
 674   3                error_rx_pto=REENVIA_TRAMA;                                                       /*1 reenvia trama*/
 675   3                ValTimeOutCom=TIME_CARD;
 676   3              }
 677   2            }                                                                                     /*aSk esta activo */
 678   1            else
 679   1            {
 680   2                cnt_espera_ask_on++;                                                              /*cuento n tiempos de ask para recibir el total de
             - la trama*/
 681   2              if(cnt_espera_ask_on>=1)
 682   2              {
 683   3                cnt__ask_off=0;                                                                   /*paso tiempo de espera y no se completo la trama 
 684   3                                                                                                  limpio los reg y reenvio la trama y ask=off*/
 685   3                cnt_espera_ask_on=0;
 686   3                error_rx_pto=REENVIA_TRAMA;
 687   3                aSk=OFF;
 688   3                ValTimeOutCom=TIME_CARD;
 689   3              }
 690   2              else
 691   2              {
 692   3                cnt__ask_off=0;                                                                   /*damos tiempo de espera de la trama del transporte*
             -/
 693   3                error_rx_pto=ESPERA_MAS_TIEMPO;;
 694   3                ValTimeOutCom=TIME_CARD;
 695   3              }
 696   2            }
 697   1              return (error_rx_pto);
 698   1      }
 699          /*------------------------------------------------------------------------------
 700          Funcion de respuesta a los cmd del transporte
 701          Retorna rta_cmd_transporte el estado en que queda
 702          Recibe tres datos unos es el 
 703          Estado_futuro= significa que la respuesta fue ok
 704          Estado_Error= en caso de que aya un error a que estado envia el codigo
 705          Estado_Actua= No ha llegado la respuesta y sigue en el mismo estado
 706          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 707          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 708          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
 709          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 710          
 711          (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 712          (1)= REENVIA_TRAMA reenvia la trama al transporte
 713          ------------------------------------------------------------------------------*/
 714          unsigned char   rta_cmd_transporte(unsigned char *secuencia_Expedidor )
 715          {
 716   1        unsigned char temp;
 717   1        unsigned char EstadoComSeqMF;
 718   1        
 719   1        
 720   1            
 721   1      if((temp=Trama_Validacion_P_N())!=RSPT_TRP_OK )
 722   1          {
 723   2            if(temp==ESPR_RSPT_TRP_TRAMA)                                                         /*no he recibido respuesta espero*/
 724   2            {
 725   3            EstadoComSeqMF= *(secuencia_Expedidor + EstadoActual);                              /*SEQ_RTA_CARD_POSno ha respon
             -dido*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 13  

 726   3            } 
 727   2            else if (temp==ERROR_TRP_TRAMA)
 728   2            {
 729   3            Debug_txt_Tibbo((unsigned char *) "RTA_CMD_ERROR\r\n");                             /* trama no valida respuesta inco
             -rrecta falla en la escritura */
 730   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 731   3            if(Buffer_Rta_Lintech[ERROR_COLLECT_CARD]==0x33)
 732   3              {
 733   4                Debug_txt_Tibbo((unsigned char *) "RTA_CMD_ERROR COLECTOR LLENO\r\n");  
 734   4              }
 735   3      
 736   3            EstadoComSeqMF=*(secuencia_Expedidor + EstadoPasado); 
 737   3            //EstadoComSeqMF=SEQ_INICIO ;                                                           /// (3) Trama invalida cmd (N)reenvio cmd*/ 
 738   3            }     
 739   2            else
 740   2            {
 741   3            /*Dispensador No Responde PTO SERIE ...*/
 742   3          
 743   3              if(temp=error_rx_pto()==ESPERA_MAS_TIEMPO)
 744   3              {
 745   4                EstadoComSeqMF=*(secuencia_Expedidor + EstadoActual); 
 746   4              }                                                                                     /*SEQ_RTA_CARD_POS;*/
 747   3              else                                                                                  //(temp=error_rx_pto()==REENVIA_TRAMA)
 748   3              {
 749   4                EstadoComSeqMF=*(secuencia_Expedidor + EstadoPasado);                                                     /*SEQ_INICIO*/
 750   4              }                                                 
 751   3            }       
 752   2          }
 753   1          else
 754   1          {
 755   2            
 756   2            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);
 757   2            EstadoComSeqMF=*(secuencia_Expedidor + EstadoFuturo); 
 758   2          }
 759   1        return EstadoComSeqMF;
 760   1      }
 761          
 762          /*------------------------------------------------------------------------------
 763          ------------------------------------------------------------------------------*/
 764          /*
 765          unsigned char Analiza_Presencia_Mensual()
 766          {
 767            unsigned char Estado_expedidor;
 768          
 769            
 770            if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 771              {
 772                if(rd_eeprom(0xa8,EE_MENSUAL_BOCA_ON_OFF) == True)  
 773                  {
 774                      MenSual = True;
 775                      Estado_expedidor = SEQ_TIPO_CARD;                 //SEQ_UID
 776                  }
 777                else
 778                  {
 779                    Estado_expedidor = SEQ_DETAIL_CARD_TRAMPA;
 780                  }
 781                
 782                
 783              }
 784            else
 785              { 
 786                
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 14  

 787                  send_portERR(PRMR_ERROR_LOOP);
 788                  PantallaLCD(ERROR_LOOP);
 789                  Estado_expedidor = SEQ_DETAIL_CARD_TRAMPA;
 790              }
 791            return Estado_expedidor;
 792          }*/
 793          /*------------------------------------------------------------------------------*/
 794          // analiza si tiene una tarjeta en la boca o en rf  para debolverla
 795          /*------------------------------------------------------------------------------*/
 796          
 797          //unsigned char Analiza_card_mount_rf()
 798          //{
 799          //unsigned char Estado_expedidor;
 800            //ValTimeOutCom=TIME_WAIT;
 801            //   if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                                //  se detecta la tarjeta en
             - la boca TARJETA EN BEZZEL
 802            //      {
 803                        /*hay una tarjeta en la boca del verificador */
 804            //            Debug_txt_Tibbo((unsigned char *) "Analiza_card_mount\r\n");                                //se envia msj al deb
             -uger q hay tarjeta en la boca
 805                                                                                                                    //se habilita recepcion de tarjetas por boca
 806            //            Estado_expedidor = SEQ_CARD_INSERCION_ON;                                                     //se trabaja mensual        
 807            //      }
 808            //      else if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF )  
 809                      
 810            //      {
 811            //            Debug_txt_Tibbo((unsigned char *)"Analiza_card_rf\r\n");
 812            //            Estado_expedidor=SEQ_EXPULSAR_CARD;
 813            //      }
 814                  
 815          
 816            //return Estado_expedidor;
 817          //}
 818          /*------------------------------------------------------------------------------*/
 819          
 820          /*------------------------------------------------------------------------------*/
 821          unsigned char Analiza_Presencia_rotacion()
 822          {
 823   1        unsigned char Estado_expedidor;
 824   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 825   1          {
 826   2            
 827   2            Estado_expedidor =SEQ_LPR; //SEQ_MOVER_CARD_RF;                 //SEQ_UID
 828   2          }
 829   1        else
 830   1          { 
 831   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 832   2              send_portERR(PRMR_ERROR_LOOP);
 833   2              PantallaLCD(ERROR_LOOP);
 834   2              ValTimeOutCom=TIME_WAIT ;
 835   2              Estado_expedidor = SEQ_PRESENCIA_VEHICULAR; //SEQ_EXPULSAR_CARD;
 836   2                    
 837   2          }
 838   1        return Estado_expedidor;
 839   1      }
 840          /*------------------------------------------------------------------------------
 841          Funcion numero unico de identificacion
 842          ------------------------------------------------------------------------------*/
 843          unsigned char Analiza_Uid_Card(unsigned char *Atributos_Expedidor )
 844          {
 845   1        unsigned char Estado_expedidor;
 846   1        unsigned char temp;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 15  

 847   1        unsigned char buffer_UID[17];
 848   1          if (Buffer_Rta_Lintech[Pos_Length] >= 0x0f)
 849   1            {
 850   2              
 851   2                for (temp=0; temp<16; ++temp)
 852   2                {
 853   3                  buffer_UID [temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                            /*almaceno la informacion de M
             -F en un arreglo*/
 854   3                 
 855   3                }
 856   2                
 857   2                Debug_txt_Tibbo((unsigned char *) "buffer_UID\r\n");
 858   2                DebugBufferMF(buffer_UID,16,RESPUESTA);
 859   2                
 860   2        
 861   2                Debug_txt_Tibbo((unsigned char *) "UID_CARD :");  
 862   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_0]));  
 863   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_1]));  
 864   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_2]));  
 865   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_3]));
 866   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
 867   2                
 868   2              *(Atributos_Expedidor + Uid_0) = buffer_UID [MF_UID_0];   
 869   2              *(Atributos_Expedidor + Uid_1) = buffer_UID [MF_UID_1];     
 870   2              *(Atributos_Expedidor + Uid_2) = buffer_UID [MF_UID_2];     
 871   2              *(Atributos_Expedidor + Uid_3) = buffer_UID [MF_UID_3]; 
 872   2              Estado_expedidor=SEQ_LPR;                                         ///SEQ_LOAD_PASSWORD;                                                       //SEQ_T
             -IPO_CARD;
 873   2            }   
 874   1            else
 875   1            {
 876   2              Estado_expedidor=SEQ_POWER_OFF;
 877   2            } 
 878   1            return Estado_expedidor;
 879   1      }
 880          /*------------------------------------------------------------------------------
 881          Se analiza si expulsa la tarjeta por boton o automatica
 882          ------------------------------------------------------------------------------*/
 883          unsigned char Ingreso_Vehiculo(void)
 884            {
 885   1          unsigned char CardAutomatic;  
 886   1          static unsigned char pulseboton=24;
 887   1          Debug_txt_Tibbo((unsigned char *) "SEQ_INGRESO_PRECARGA\r\n");
 888   1        
 889   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso si hay presencia
 890   1          {
 891   2            /*si hay presencia */
 892   2            CardAutomatic=rd_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON);  
 893   2              
 894   2            if (rx_ip==0)                                                         /*pregunto si llega datos de monitor pto serie emulado*/
 895   2              {
 896   3              
 897   3                 Rx_Monitor();
 898   3              
 899   3              }
 900   2            
 901   2            if (CardAutomatic==True)                                                    //se pregunta si expide la tarjeta automatica o por p
             -resionar el boton
 902   2              {
 903   3                Debug_txt_Tibbo((unsigned char *) "Tarjeta: Automatico\r\n");           //expide tarjetas automatico con p
             -resencia
 904   3                send_portERR(AUDIO_ENTRADA);                                                                      // muevo la tarjeta hasta el lector de
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 16  

             - rf
 905   3                Estado=SEQ_WAIT_PLACA;            //SEQ_LPR;                                                          //SEQ_MOVER_CARD_RF;                          
             -                      // valido el cmd enviado al verificador
 906   3               }
 907   2            else
 908   2              {   
 909   3            /*solo sale el msj pulse el boton una vez cada 24 veces */          
 910   3                  if (rx_ip==0)                                                         /*pregunto si llega datos de monitor pto serie emulado*/
 911   3                  {
 912   4                
 913   4                    Rx_Monitor();
 914   4                
 915   4                  }
 916   3                
 917   3                if(pulseboton >= 24)
 918   3                  { PantallaLCD(PULSE_BOTON); 
 919   4                    pulseboton=0;
 920   4                  }
 921   3                  else
 922   3                   {
 923   4                     pulseboton++;
 924   4                  
 925   4                   
 926   4                   }
 927   3                   Botton ();
 928   3                   if(PULSADOR_BOTTON == True)
 929   3                   {
 930   4                     PULSADOR_BOTTON = 0;
 931   4                     pulseboton=0;                                                                //muevo tarjeta hasta el lector de RF
 932   4                     Timer_wait=0;                                                                // inicio el timer de espera de placa 
 933   4                     Estado=SEQ_WAIT_PLACA; //SEQ_LPR;                  //SEQ_MOVER_CARD_RF;
 934   4                   }
 935   3                   else
 936   3                   {
 937   4                      if (rx_ip==0)                                                         /*pregunto si llega datos de monitor pto serie emulado*
             -/
 938   4                      {
 939   5                  
 940   5                        Rx_Monitor();
 941   5                    
 942   5                      }
 943   4                    Estado=SEQ_INGRESO_PRECARGA;                                                                        //SEQ_INICIO; 
 944   4                     ValTimeOutCom=TIME_PULSADOR;       //ojo
 945   4                   }
 946   3                
 947   3                  
 948   3              } 
 949   2          }
 950   1          else
 951   1              { 
 952   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 953   2            
 954   2                led_err_imp = 1;
 955   2                Estado=SEQ_PRESENCIA_VEHICULAR;   //SEQ_LOAD_PASSWORD;        //SEQ_INGRESO_PRECARGA;                                       
             -                                    //SEQ_INICIO; 
 956   2              }
 957   1        return Estado;
 958   1      }
 959           
 960          /*------------------------------------------------------------------------------
 961          Se pregunta por el estado del expedidor si hay tarjetas y presencia para expulsar tarjeta
 962          o si hay tarjeta en la boca o rf para entrar en mensuales
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 17  

 963          ------------------------------------------------------------------------------*/
 964          
 965          unsigned char Responde_Estado_Sensores_Transporte()
 966          {
 967   1        unsigned char Estado_expedidor;
 968   1          
 969   1            Debug_txt_Tibbo((unsigned char *) "TAREA_SENSORES_TRANSPORTE\r\n");                                 // trama valida Hab
             -ilitado 
 970   1          
 971   1            if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                                 // CANAL LIBRE    no tiene 
             -tarjetas en el mecanismo
 972   1            {
 973   2                
 974   2              if  ((Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS)||(Buffer_Rta_Lintech[Pos_St1]==FULL_CARD  ))  //  se
             - detecta la tarjeta en la boca TARJETA EN BEZZEL
 975   2              {
 976   3                if (Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS  )                                             // nivel de tarjetas
 977   3                  {
 978   4                    Debug_txt_Tibbo((unsigned char *) "Nivel bajo de tarjetas\r\n");                            // nivel bajo de tarj
             -etas 
 979   4                    send_portERR(LOW_CARD);                                                                     //envio msj al primario
 980   4                  
 981   4                      Estado_expedidor=SEQ_MOVER_CARD_RF;
 982   4                          
 983   4                   }
 984   3                   else
 985   3                      {
 986   4                        /*respuesta ok*/
 987   4                    
 988   4                          Estado_expedidor=SEQ_MOVER_CARD_RF;
 989   4                  
 990   4                     }
 991   3              } 
 992   2              else 
 993   2                  {
 994   3                    /*dispensador no posee tarjetas*/
 995   3                    Debug_txt_Tibbo((unsigned char *) "Dispensador SIN TARJETAS...\r\n"); 
 996   3                    
 997   3                    send_portERR(NO_CARD);  
 998   3                                                                          // se envia msj al uC principal, visualiza en el lcd que no hay tarjetas
 999   3                      
1000   3                    Estado_expedidor=SEQ_INICIO;                                                                //inicio el loop
1001   3                   }
1002   2            }
1003   1            else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                                //  se detecta la tarjeta
             - en la boca TARJETA EN BEZZEL
1004   1              {
1005   2                    /*hay una tarjeta en la boca del verificador */
1006   2                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca\r\n");                                //se envia msj al debug
             -er q hay tarjeta en la boca
1007   2                                                                                                                //se habilita recepcion de tarjetas por boca
1008   2                    Estado_expedidor=SEQ_TIPO_CARD;                                     //SEQ_CARD_INSERCION_ON;                                                  
             -    //se trabaja mensual        
1009   2              }
1010   1            else if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF )  
1011   1                  
1012   1              {
1013   2                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en RF\r\n");
1014   2                    Estado_expedidor=SEQ_TIPO_CARD;                                     //SEQ_CARD_INSERCION_ON;
1015   2              }
1016   1            //else
1017   1            //  {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 18  

1018   1            //    Estado_expedidor=SEQ_INICIO;  
1019   1            //  }
1020   1        return Estado_expedidor;  
1021   1      }
1022          
1023          /*------------------------------------------------------------------------------
1024          Funcion que nos dice el tipo de tarjeta que tiene en el mecanismo
1025          Comprobacion automatica del tipo de tarjeta 
1026          checking RF card type
1027          Card_type_H   Card_type_L  explicacion
1028              0             0           tarjeta desconocida
1029              1             0           MF50
1030              1             1           MF70
1031              1             2           MF_UL
1032              2             0           TYPE_A_CPU
1033          
1034          #define MF50_HIGH             '1'
1035          #define MF50_LOW              '0'
1036          ------------------------------------------------------------------------------*/
1037          unsigned char Responde_Tipo_Tarjeta()
1038            {
1039   1          unsigned char Estado_expedidor;
1040   1          
1041   1            Debug_txt_Tibbo((unsigned char *) "TAREA_TIPO DE TARJETA\r\n");                                       // trama valida Habi
             -litado 
1042   1            
1043   1        if (Buffer_Rta_Lintech[Card_type_H]==MF50_HIGH)                                                           /* pregunto si la tarjeta en
             - el transporte es MF 50 */
1044   1          {
1045   2          if ((Buffer_Rta_Lintech[Card_type_L] == MF50_LOW) || (Buffer_Rta_Lintech[Card_type_L] == MF70)) 
1046   2            {
1047   3              Debug_txt_Tibbo((unsigned char *) "Tarjeta valida MF50\r\n");                                       /* trama valida son M
             -F50*/
1048   3              if(MenSual ==  True)
1049   3              {
1050   4              Estado_expedidor =SEQ_CAPTURE_CARD;               //SEQ_UID;                                                                          //SEQ_LOAD_P
             -ASSWORD;                        
1051   4              }
1052   3              else  
1053   3              {
1054   4                Estado_expedidor = SEQ_LOAD_PASSWORD;     //SEQ_LPR;    //SEQ_LOAD_PASSWORD;
1055   4              }         
1056   3            }
1057   2          else
1058   2            {
1059   3                 if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF)                                                //  se detecta la tarjeta
             - en la boca TARJETA EN BEZZEL
1060   3                {
1061   4                
1062   4                Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida_1 no es MF50\r\n");                           /* trama no vali
             -da */
1063   4                      
1064   4                send_portERR(PRMR_TARJETA_INVALIDA);                                                              /*envio msj principal tarjeta inva
             -lidad*/
1065   4                PantallaLCD(TARJETA_INVALIDA);
1066   4                    
1067   4                  Estado_expedidor =SEQ_CAPTURE_CARD;             // Captura_Expulsa(); 
1068   4                
1069   4                } 
1070   3                else  
1071   3                {
1072   4                  /*NO HAY TARJETA EN RF*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 19  

1073   4                  MenSual = False;
1074   4                  Estado_expedidor = SEQ_INICIO;    
1075   4                }           
1076   3            }
1077   2          }
1078   1          else 
1079   1            {
1080   2               if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF)                                                //  se detecta la tarjeta 
             -en la boca TARJETA EN BEZZEL
1081   2                {
1082   3                  /*patina el transporte */
1083   3                
1084   3              Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n");                             /* trama no valida
             - */
1085   3                      
1086   3              send_portERR(PRMR_TARJETA_INVALIDA);                                                              //la tarjeta no es valida 
1087   3              PantallaLCD(TARJETA_INVALIDA);                                                                    /*envio el msj por la pantalla lcd o l
             -a raspberry*/
1088   3                        
1089   3              Estado_expedidor = SEQ_CAPTURE_CARD;      //Captura_Expulsa();  
1090   3                          
1091   3                  
1092   3                }
1093   2                else  
1094   2                {
1095   3                  /*NO HAY TARJETA EN RF*/
1096   3                  MenSual = False;
1097   3                  Estado_expedidor = SEQ_INICIO;    
1098   3                }                     
1099   2            }
1100   1                    
1101   1          return Estado_expedidor;                                                                                                  
1102   1        } 
1103          /*------------------------------------------------------------------------------
1104            Funcion que lee los datos en el Sector 1 Bloque 1
1105            se lee
1106            ID_CLIENTE
1107            COD_PARK
1108            TIPO DE TARJETA
1109            EXPIRA_ANO
1110            EXPIRA_MES
1111            EXPIRA_DIA
1112          ------------------------------------------------------------------------------*/
1113          
1114          unsigned char  Responde_Lectura_Tarjeta_Sector1_Bloque1 (unsigned char *Atributos_Expedidor)
1115          {
1116   1        unsigned char temp;
1117   1        unsigned char Estado_expedidor;
1118   1        unsigned char buffer_S1_B1[17];
1119   1        unsigned char ID_CLIENTE;
1120   1        unsigned char COD_PARK;   
1121   1        static unsigned char falla=0;
1122   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE1\r\n");   
1123   1                                        
1124   1                                      
1125   1            
1126   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1127   1            {
1128   2              
1129   2                for (temp=0; temp<16; ++temp)
1130   2                {
1131   3                  buffer_S1_B1 [temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                            /*almaceno la informacion de
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 20  

             - MF en un arreglo*/
1132   3                 
1133   3                }
1134   2                
1135   2                
1136   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b1\r\n");
1137   2                DebugBufferMF(buffer_S1_B1,16,RESPUESTA);
1138   2                ID_CLIENTE=rd_eeprom(0xa8,EE_ID_CLIENTE); 
1139   2                COD_PARK=rd_eeprom(0xa8,EE_ID_PARK);
1140   2                /*Compara  MF_ID_CLIENTE y MF_COD_PARK con el codigo del parqueadero ID_CLIENTE  COD_PARK*/
1141   2                
1142   2                if (((buffer_S1_B1 [ MF_ID_CLIENTE])==ID_CLIENTE) && ((buffer_S1_B1 [ MF_COD_PARK] ) == COD_PARK)||((
             -ID_CLIENTE==0)&&(COD_PARK==0)))   
1143   2                {
1144   3                    
1145   3                  Debug_txt_Tibbo((unsigned char *) "CARD ID_CLIENTE: ");               
1146   3                  Debug_HexDec((buffer_S1_B1 [ MF_ID_CLIENTE]));
1147   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1148   3                  
1149   3                  Debug_txt_Tibbo((unsigned char *) "ID_CLIENTE: ");                
1150   3                  Debug_HexDec(ID_CLIENTE);
1151   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1152   3                  
1153   3                  Debug_txt_Tibbo((unsigned char *) "CARD COD_PARK:");                    
1154   3                  Debug_HexDec(buffer_S1_B1 [ MF_COD_PARK]);
1155   3                  Debug_txt_Tibbo((unsigned char *) "\r\n"); 
1156   3                  
1157   3                  Debug_txt_Tibbo((unsigned char *) "COD_PARK:");                   
1158   3                  Debug_HexDec(buffer_S1_B1 [ MF_COD_PARK]);
1159   3                  Debug_txt_Tibbo((unsigned char *) "\r\n"); 
1160   3      
1161   3                  Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA: ");
1162   3                  Debug_chr_Tibbo(buffer_S1_B1 [MF_TIPO_TARJETA]);
1163   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1164   3                  
1165   3                  *(Atributos_Expedidor + Tipo_Tarjeta) = buffer_S1_B1 [MF_TIPO_TARJETA];
1166   3                  /*fecha de vencimiento de mensual o prepago*/
1167   3                  *(Atributos_Expedidor + Expira_ano) = buffer_S1_B1 [MF_EXPIRA_ANO];
1168   3                  *(Atributos_Expedidor + Expira_mes) = buffer_S1_B1 [MF_EXPIRA_MES];
1169   3                  *(Atributos_Expedidor + Expira_dia) = buffer_S1_B1 [MF_EXPIRA_DIA];
1170   3                  
1171   3                  *(Atributos_Expedidor + Sector) = Sector_1;
1172   3                  *(Atributos_Expedidor + Bloque) = Bloque_2;
1173   3                  falla=0;
1174   3                  Estado_expedidor = SEQ_READ_SECTOR_BLOQUE;
1175   3              
1176   3                }
1177   2                else
1178   2                {
1179   3                  falla=0;
1180   3                  Debug_txt_Tibbo((unsigned char *) "ERROR COD PARK\r\n");
1181   3                  send_portERR(PRMR_ERROR_COD_PARK);
1182   3                  PantallaLCD(ERROR_COD_PARK);                                                        //envio el msj por la pantalla lcd o la rasp
             -berry
1183   3                  Estado_expedidor =SEQ_CAPTURE_CARD;             //Captura_Expulsa();                                                  //   codigo de
             - parqueo erro expulso la tarjeta    
1184   3                }
1185   2            }
1186   1            else
1187   1            {
1188   2                
1189   2              if ((Buffer_Rta_Lintech[Rtype]) == OPERATE_FAIL)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 21  

1190   2              {
1191   3                falla++;
1192   3              }
1193   2               if (falla <= 2)
1194   2                
1195   2              {
1196   3                Debug_txt_Tibbo((unsigned char *) "ERROR OPERATE FAIL\r\n");
1197   3                Estado_expedidor = SEQ_POWER_ON;
1198   3                                    
1199   3              }
1200   2              else
1201   2              {
1202   3                falla=0;
1203   3                Debug_txt_Tibbo((unsigned char *) "TARJETA SIN FORMATO\r\n");
1204   3                send_portERR(PRMR_TARJETA_SIN_FORMATO);
1205   3                PantallaLCD(TARJETA_SIN_FORMATO);                                                       /*envio el msj por la pantalla lcd o la 
             -raspberry*/
1206   3               Estado_expedidor =SEQ_CAPTURE_CARD;                                  //Captura_Expulsa();    
1207   3              }
1208   2            }
1209   1            
1210   1        return Estado_expedidor;
1211   1      } 
1212          /*------------------------------------------------------------------------------
1213          
1214          ------------------------------------------------------------------------------*/
1215          
1216          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque2 (unsigned char *Atributos_Expedidor)
1217          {
1218   1        unsigned char temp;
1219   1        unsigned char Estado_expedidor;
1220   1        unsigned char buffer_S1_B2[17]; 
1221   1      
1222   1            
1223   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE2\r\n");   
1224   1            
1225   1                              
1226   1            
1227   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1228   1            {
1229   2              
1230   2                for (temp=0; temp<16; ++temp)
1231   2                {
1232   3                  buffer_S1_B2 [temp] =Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion d
             -e MF en un arreglo*/
1233   3                }
1234   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b2\r\n");
1235   2                DebugBufferMF(buffer_S1_B2,16,RESPUESTA);
1236   2                
1237   2                      
1238   2                
1239   2                Debug_txt_Tibbo((unsigned char *) "HORARIO:");
1240   2                Debug_chr_Tibbo((buffer_S1_B2 [MF_TIPO_VEHICULO] & 0XF0) >> 4);
1241   2                *(Atributos_Expedidor + Horario)= ((buffer_S1_B2 [MF_TIPO_VEHICULO] & 0XF0) >> 4);
1242   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1243   2                
1244   2                Debug_txt_Tibbo((unsigned char *) "PICO Y PLACA:");
1245   2                
1246   2                *(Atributos_Expedidor + Pico_Placa)= ((buffer_S1_B2 [MF_IN_PAGO] & 0XF0) >> 4);
1247   2                Debug_chr_Tibbo(*(Atributos_Expedidor + Pico_Placa));
1248   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1249   2                
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 22  

1250   2            
1251   2                Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK:");
1252   2                Debug_chr_Tibbo(buffer_S1_B2 [MF_APB] );
1253   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1254   2              
1255   2                /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
1256   2                
1257   2                *(Atributos_Expedidor + Apb)=   buffer_S1_B2 [MF_APB] ;
1258   2                
1259   2                
1260   2                  *(Atributos_Expedidor + Type_Vehiculo ) = buffer_S1_B2 [MF_TIPO_VEHICULO]& 0x0f;
1261   2                  Estado_expedidor =SEQ_PRESENCIA_VEHICULAR;    ///SEQ_CLASE_TARJETAS;    // Valida_Tipo_Tarjeta(Atribut
             -os_Expedidor,Buffer_Write_MF);
1262   2            
1263   2        
1264   2            }
1265   1            else
1266   1            {
1267   2              Estado_expedidor = SEQ_CAPTURE_CARD;  //Captura_Expulsa(); //momentario
1268   2            }
1269   1          return Estado_expedidor;  
1270   1      }
1271          
1272          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque0 (unsigned char *Nombre_Mensual)
1273          {
1274   1        unsigned char temp;
1275   1        unsigned char Estado_expedidor;
1276   1          
1277   1      
1278   1            
1279   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE0\r\n");   
1280   1            
1281   1                              
1282   1            
1283   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1284   1            {
1285   2              
1286   2                for (temp=0; temp<16; ++temp)
1287   2                {
1288   3                  *(Nombre_Mensual + temp ) =Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informa
             -cion de MF en un arreglo*/
1289   3                }
1290   2                *(Nombre_Mensual + temp )=NULL;
1291   2                Debug_txt_Tibbo((unsigned char *) "Nombre Mensual:");
1292   2                Debug_txt_Tibbo(Nombre_Mensual );
1293   2                Debug_txt_Tibbo((unsigned char *) "\r\n");      
1294   2                Estado_expedidor = SEQ_PLACA;   //SEQ_TIPO_TARJETAS;                                                // Valida_Tipo_Tarjeta(Atr
             -ibutos_Expedidor,Buffer_Write_MF);
1295   2            
1296   2        
1297   2            }
1298   1            else
1299   1            {
1300   2              Estado_expedidor =  SEQ_CAPTURE_CARD; //Captura_Expulsa(); //momentario
1301   2            }
1302   1          return Estado_expedidor;  
1303   1      }
1304          unsigned char Responde_ReeLectura_Tarjeta_Sector1_Bloque2 (unsigned char *lectura_anterior, unsigned char 
             -*Atributos_Expedidor)
1305          {
1306   1        unsigned char temp;
1307   1        unsigned char Estado_expedidor;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 23  

1308   1        unsigned char *reelectura;
1309   1        static unsigned char error_lectura=0;
1310   1            
1311   1            Debug_txt_Tibbo((unsigned char *) "TAREA_REELECTURA_TARJETA_SECTOR1_BLOQUE2\r\n");    
1312   1                                  
1313   1            
1314   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1315   1            {
1316   2              
1317   2                for (temp=0; temp<16; ++temp)
1318   2                {
1319   3                  *(reelectura + temp ) =Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion
             - de MF en un arreglo*/
1320   3                }
1321   2                *(reelectura + temp )=NULL;
1322   2                Debug_txt_Tibbo((unsigned char *) "Reeletura sector_1 bloque_2:");
1323   2                DebugBufferMF(reelectura,16,RESPUESTA);
1324   2                Debug_txt_Tibbo((unsigned char *) "\r\n");      
1325   2              
1326   2                  if(strcmp(reelectura,lectura_anterior)== 0)
1327   2                  {
1328   3                    error_lectura=0;
1329   3                    Debug_txt_Tibbo((unsigned char *) "Reeletura sector_1 bloque_2 ok");
1330   3                    Debug_txt_Tibbo((unsigned char *) "\r\n");      
1331   3                    *(Atributos_Expedidor + Sector) = Sector_1;
1332   3                    *(Atributos_Expedidor + Bloque) = Bloque_0;
1333   3                    Armar_Trama_Tarjeta_Sector1_Bloque0(lectura_anterior);//Buffer_Write_MF
1334   3                    Estado_expedidor = SEQ_WRITE_SECTOR_BLOQUE;
1335   3                  }
1336   2                  else 
1337   2                  {
1338   3                    error_lectura++;
1339   3                    if (error_lectura >=3)
1340   3                    {
1341   4                      Debug_txt_Tibbo((unsigned char *) "Reeletura sector_1 bloque_2 falla");
1342   4                      Estado_expedidor =SEQ_CAPTURE_CARD;
1343   4                      
1344   4                    }
1345   3                    else
1346   3                    {
1347   4                    Debug_txt_Tibbo((unsigned char *) "Reeletura sector_1 bloque_2 falla");
1348   4                    Debug_txt_Tibbo((unsigned char *) "\r\n");      
1349   4                    *(Atributos_Expedidor + Sector) = Sector_1;
1350   4                    *(Atributos_Expedidor + Bloque) = Bloque_2;
1351   4                    Estado_expedidor =SEQ_WRITE_SECTOR_BLOQUE;
1352   4                      
1353   4                    }
1354   3                  }
1355   2                          
1356   2            }
1357   1              return Estado_expedidor ;
1358   1      }
1359          unsigned char Responde_Write_Tarjeta_Sector1_Bloque1(unsigned char *Buffer_Write_MF)
1360          {
1361   1        unsigned char Estado_expedidor;
1362   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE1\r\n"); 
1363   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b1\r\n");
1364   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1365   1        Estado_expedidor = SEQ_TIPO_CARD;
1366   1        return Estado_expedidor;
1367   1      }
1368          unsigned char Responde_Write_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buf
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 24  

             -fer_Write_MF)
1369          {
1370   1        unsigned char Estado_expedidor;
1371   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE2\r\n"); 
1372   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b2\r\n");
1373   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1374   1        if(MenSual !=  True)
1375   1        {
1376   2          //Estado_expedidor=SEQ_REELER_CARD_SECTOR1_BLOQUE1;
1377   2          /*se graba locatorios*/
1378   2          *(Atributos_Expedidor + Sector) = Sector_1;
1379   2          *(Atributos_Expedidor + Bloque) = Bloque_0;
1380   2          Armar_Trama_Tarjeta_Sector1_Bloque0(Buffer_Write_MF);
1381   2          Estado_expedidor = SEQ_WRITE_SECTOR_BLOQUE;
1382   2        }
1383   1        else
1384   1        {
1385   2          *(Atributos_Expedidor + Sector) = Sector_1;
1386   2          *(Atributos_Expedidor + Bloque) = Bloque_0;
1387   2          Estado_expedidor = SEQ_READ_SECTOR_BLOQUE;
1388   2          
1389   2        }
1390   1        return Estado_expedidor;
1391   1      }
1392          /*----------------------------------------------------------------------------
1393          ----------------------------------------------------------------------------*/
1394          unsigned char Responde_Write_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
1395          {
1396   1      
1397   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE0\r\n"); 
1398   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b0\r\n");
1399   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1400   1        
1401   1        return SEQ_SECOND_PASSWORD;   //SEQ_PRESENCIA_VEHICULAR;                    //SEQ_PLACA;          //SEQ_LPR
1402   1      }
1403          /*----------------------------------------------------------------------------
1404          ----------------------------------------------------------------------------*/
1405          unsigned char Responde_Write_Tarjeta_Sector2_Bloque0(unsigned char *Buffer_Write_MF)
1406          {
1407   1        
1408   1        Debug_txt_Tibbo((unsigned char *) "PLACA:");  
1409   1        Debug_txt_Tibbo((unsigned char *) placa);
1410   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1411   1        Debug_txt_Tibbo((unsigned char *) "Write_s2_b0\r\n");
1412   1        DebugBufferMF(Buffer_Write_MF,16,ENVIADOS);
1413   1        return SEQ_FRONT_CARD;
1414   1      }
1415          
1416          /*----------------------------------------------------------------------------
1417          ----------------------------------------------------------------------------*/
1418          unsigned char Pregunta_Lpr(unsigned char *Atributos_Expedidor)
1419          {
1420   1        unsigned char Estado_expedidor;
1421   1        unsigned int contador=0;
1422   1        unsigned time_out=0;
1423   1        Debug_txt_Tibbo((unsigned char *) "PREGUNTA LPR\r\n");
1424   1         hora_entrada_vehiculo(Atributos_Expedidor);
1425   1          if(rd_eeprom(0xa8,EE_USE_LPR)== True)
1426   1             {
1427   2               /*monitor trama*/
1428   2               Debug_txt_Tibbo(Armar_Trama_Monitor(Atributos_Expedidor));
1429   2                if (rd_eeprom(0xa8,EE_DEBUG) == False)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 25  

1430   2                 {
1431   3                   Debug_Tibbo=False;
1432   3                                           
1433   3                 }
1434   2             }
1435   1        
1436   1      
1437   1          Estado_expedidor=SEQ_INGRESO_PRECARGA; //SEQ_CLASE_TARJETAS;       //SEQ_LOAD_PASSWORD;         //SEQ_TIPO_T
             -ARJETAS;
1438   1      
1439   1        return Estado_expedidor;
1440   1      }
1441          
1442          unsigned char Pregunta_Placa_Habilitada()
1443          {
1444   1        unsigned char Estado_expedidor;
1445   1        Debug_txt_Tibbo((unsigned char *) "PREGUNTA PLACA\r\n");
1446   1          if (rd_eeprom(0xa8,EE_PLACA)!= False)
1447   1          {
1448   2            /*espero placa*/
1449   2            Estado_expedidor=SEQ_WAIT_PLACA;
1450   2            ValTimeOutCom=TIME_WAIT ;
1451   2            Timer_wait=False;
1452   2          }
1453   1          else 
1454   1          {
1455   2          Estado_expedidor=SEQ_FRONT_CARD;
1456   2          }
1457   1        return Estado_expedidor;
1458   1      }
1459          unsigned char  Respuesta_Segunda_clave(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_MF)
1460          {
1461   1        
1462   1        Debug_txt_Tibbo((unsigned char *) "TAREA_SEGUNDA CLAVE\r\n"); 
1463   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1464   1      
1465   1        
1466   1        *(Atributos_Expedidor + Sector) = Sector_2;
1467   1        *(Atributos_Expedidor + Bloque) = Bloque_0;
1468   1        Armar_Trama_Placa(Buffer_Write_MF);
1469   1          
1470   1        return SEQ_WRITE_SECTOR_BLOQUE;
1471   1      }
1472          unsigned char Respuesta_Placa_Cancel()
1473          {
1474   1        unsigned char Estado_expedidor;
1475   1        
1476   1        
1477   1        Debug_txt_Tibbo((unsigned char *) "RESPUESTA PLACA O CANCEL = "); 
1478   1        Debug_txt_Tibbo((unsigned char *) placa);
1479   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1480   1        
1481   1        
1482   1          
1483   1        if (strcmp(placa,"NO_PLATE")== 0)
1484   1        {
1485   2          Debug_txt_rs232(placa);
1486   2          Estado_expedidor = SEQ_CLASE_TARJETAS;//SEQ_SECOND_PASSWORD;
1487   2        }
1488   1        else
1489   1        {
1490   2          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 26  

1491   2            Estado_expedidor = SEQ_CLASE_TARJETAS; //SEQ_SECOND_PASSWORD;
1492   2          
1493   2        } 
1494   1        return Estado_expedidor;
1495   1      }
1496          /*------------------------------------------------------------------------------
1497          ------------------------------------------------------------------------------*/
1498          /*void  Armar_Trama_Tarjeta_Sector1_Bloque1_Camcel(unsigned char *Buffer_Write_MF)
1499          {
1500            unsigned char ID_CLIENTE;
1501            unsigned char COD_PARK; 
1502              /*cuando se recibe el CAMCEL se bloquea la tarjeta*/
1503          /*  clear_placa();
1504            ID_CLIENTE=rd_eeprom(0xa8,EE_ID_CLIENTE); 
1505            COD_PARK=rd_eeprom(0xa8,EE_ID_PARK);
1506          
1507            *(Buffer_Write_MF + MF_TIPO_TARJETA)  = MENSUALIDAD;
1508            *(Buffer_Write_MF + MF_COD_PARK)      = COD_PARK; 
1509            *(Buffer_Write_MF + MF_COD_PARK+1)    = NULL;
1510            *(Buffer_Write_MF + MF_ID_CLIENTE)    = ID_CLIENTE;
1511            *(Buffer_Write_MF + MF_ID_CLIENTE+1)  = NULL;
1512            *(Buffer_Write_MF + MF_MENSUAL_ANO)   = NULL;
1513            *(Buffer_Write_MF + MF_MENSUAL_MES)   = NULL;
1514            *(Buffer_Write_MF + MF_MENSUAL_DIA)   = NULL;
1515            *(Buffer_Write_MF + MF_EXPIRA_ANO)    = NULL;
1516            *(Buffer_Write_MF + MF_EXPIRA_MES)    = NULL;
1517            *(Buffer_Write_MF + MF_EXPIRA_DIA)    = NULL;
1518            *(Buffer_Write_MF + MF_EXPIRA_DIA+1)  = NULL;
1519            *(Buffer_Write_MF + MF_EXPIRA_DIA+2)  = NULL;
1520            *(Buffer_Write_MF + MF_EXPIRA_DIA+3)  = NULL;
1521            *(Buffer_Write_MF + MF_EXPIRA_DIA+4)  = NULL;
1522          }
1523          */
1524          /*------------------------------------------------------------------------------
1525          ------------------------------------------------------------------------------*/
1526          
1527          void  Armar_Trama_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_M
             -F)
1528          {
1529   1        
1530   1        /*fecha de ingreso se lee año,mes,dia,hora y minutos*/
1531   1      
1532   1        //Block_read_Clock_Hex(Buffer_Write_MF);
1533   1        *(Buffer_Write_MF + 0)= bcd_hex(*(Atributos_Expedidor +  DateTime_year));
1534   1        *(Buffer_Write_MF + 1)= bcd_hex(*(Atributos_Expedidor +  DateTime_month));
1535   1        *(Buffer_Write_MF + 2)= bcd_hex(*(Atributos_Expedidor +  DateTime_day));
1536   1        *(Buffer_Write_MF + 3)= bcd_hex(*(Atributos_Expedidor +  DateTime_hour));
1537   1        *(Buffer_Write_MF + 4)= bcd_hex(*(Atributos_Expedidor +  DateTime_minutes));
1538   1        /*descuentos los borro*/
1539   1        
1540   1        *(Buffer_Write_MF + 5)=0;
1541   1        *(Buffer_Write_MF + 6)=0;
1542   1        *(Buffer_Write_MF + 7)=0;
1543   1        
1544   1        if (*(Atributos_Expedidor + Tipo_Tarjeta) == ROTACION)
1545   1        {
1546   2          *(Buffer_Write_MF + 8)  = Tipo_Vehiculo;
1547   2          *(Buffer_Write_MF + 9)  = (Dir_board())- 0x30;
1548   2          *(Buffer_Write_MF +10) = APB_INT;
1549   2        }
1550   1        
1551   1        /*mensual*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 27  

1552   1        else
1553   1        {
1554   2          
1555   2          *(Buffer_Write_MF + 8)  = (*(Atributos_Expedidor + Horario) << 4) | (*(Atributos_Expedidor + Type_Vehicu
             -lo));
1556   2          *(Buffer_Write_MF + 9)  =  (*(Atributos_Expedidor + Pico_Placa) << 4)| (Dir_board())- 0x30;
1557   2          
1558   2          if (*(Atributos_Expedidor + Apb)== APB_NO)
1559   2           {
1560   3              *(Buffer_Write_MF +10) =APB_NO;
1561   3            }
1562   2          else 
1563   2          {
1564   3            *(Buffer_Write_MF +10) =APB_INT;
1565   3          }
1566   2        }
1567   1        /*fecha de salida maxima*/
1568   1        *(Buffer_Write_MF +11)=0;
1569   1        *(Buffer_Write_MF +12)=0;
1570   1        *(Buffer_Write_MF +13)=0;
1571   1        *(Buffer_Write_MF +14)=0;
1572   1        *(Buffer_Write_MF +15)=0;
1573   1      }
1574          void Armar_Trama_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
1575          {
1576   1        /*graba serie de Ticket*/
1577   1        strcpy(Buffer_Write_MF, Lee_No_Ticket());
1578   1      }
1579          unsigned char *Armar_Trama_Pto_Paralelo_Expedidor(unsigned char *Atributos_Expedidor,unsigned char *longit
             -ud_trama_pto_paralelo)
1580          {
1581   1        static unsigned char buffer[28];
1582   1        unsigned char ticket[11];
1583   1        unsigned char j;
1584   1        /*la trama esta compuesta de
1585   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1586   1      
1587   1        buffer[0]=STX;
1588   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR;
1589   1        buffer[2]=NULL;
1590   1        strcpy(ticket, Lee_No_Ticket());
1591   1        strcat(buffer , ticket);
1592   1        j=strlen(buffer);
1593   1        
1594   1        buffer[j++]= '-';
1595   1        /*leo fecha de entrada*/
1596   1        buffer[j++]= bcd_hex(*(Atributos_Expedidor +  DateTime_year))   + 0x30;
1597   1        buffer[j++]= bcd_hex(*(Atributos_Expedidor +  DateTime_month))  + 0x30;
1598   1        buffer[j++]= bcd_hex(*(Atributos_Expedidor +  DateTime_day))    + 0x30;
1599   1        buffer[j++]= bcd_hex(*(Atributos_Expedidor +  DateTime_hour))   + 0x30;
1600   1        buffer[j++]= bcd_hex(*(Atributos_Expedidor +  DateTime_minutes))+ 0x30;
1601   1        buffer[j++]= '-';
1602   1        
1603   1        //Block_read_Clock_Hex(buffer+j);         //leo la fecha de entrada
1604   1        //buffer[j]=buffer[j]+0x030;              /*año de entrada*/
1605   1        //buffer[j+1]=buffer[j+1]+0x030;          /*mes de entrada*/
1606   1        //buffer[j+2]=buffer[j+2]+0x030;          /*dia de entrada*/
1607   1        //buffer[j+3]=buffer[j+3]+0x030;          /*hora de entrada*/
1608   1        //buffer[j+4]=buffer[j+4]+0x030;          /*minutos de entrada*/
1609   1        //buffer[j+5]= '-';
1610   1        /*placa*/
1611   1        if (rd_eeprom(0xa8,EE_PLACA)!=0)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 28  

1612   1        {   
1613   2          if (placa_ready != False)
1614   2          {
1615   3            buffer[j++]= placa[0];
1616   3            buffer[j++]= placa[1];
1617   3            buffer[j++]= placa[2];
1618   3            buffer[j++]= placa[3];
1619   3            buffer[j++]= placa[4];
1620   3            buffer[j++]= placa[5];
1621   3            buffer[j++]= NULL;
1622   3          }
1623   2          else
1624   2          {
1625   3            buffer[j++]= ' ';
1626   3            buffer[j++]= NULL;
1627   3          }
1628   2        }
1629   1        else 
1630   1        {
1631   2          buffer[j++]= ' ';
1632   2          buffer[j++]=NULL;
1633   2        }
1634   1        j=strlen(buffer);
1635   1        buffer[j]= ETX;
1636   1        *longitud_trama_pto_paralelo=j+1;
1637   1        
1638   1        return buffer;
1639   1      }
1640          unsigned char *Armar_Trama_Pto_Paralelo_Expedidor_Mensual(unsigned char *Atributos_Expedidor,unsigned char
             - *longitud_trama_pto_paralelo)
1641          {
1642   1        static unsigned char buffer[28];
1643   1      
1644   1        /*la trama esta compuesta de
1645   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1646   1      
1647   1        buffer[0]=STX;
1648   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL;
1649   1        buffer[2]=*(Atributos_Expedidor + Uid_0);
1650   1        buffer[3]=*(Atributos_Expedidor + Uid_1);
1651   1        buffer[4]=*(Atributos_Expedidor + Uid_2);
1652   1        buffer[5]=*(Atributos_Expedidor + Uid_3);
1653   1        
1654   1        /*leo fecha de entrada*/
1655   1        
1656   1        buffer[6]= bcd_hex(*(Atributos_Expedidor +  DateTime_year))   + 0x30;
1657   1        buffer[7]= bcd_hex(*(Atributos_Expedidor +  DateTime_month))  + 0x30;
1658   1        buffer[8]= bcd_hex(*(Atributos_Expedidor +  DateTime_day))    + 0x30;
1659   1        buffer[9]= bcd_hex(*(Atributos_Expedidor +  DateTime_hour))   + 0x30;
1660   1        buffer[10]= bcd_hex(*(Atributos_Expedidor + DateTime_minutes))+ 0x30;
1661   1        
1662   1      //  Block_read_Clock_Hex(buffer+6);         //leo la fecha de entrada
1663   1      //  buffer[6]=buffer[6]+0x030;              /*año de entrada*/
1664   1      //  buffer[7]=buffer[7]+0x030;          /*mes de entrada*/
1665   1      //  buffer[8]=buffer[8]+0x030;          /*dia de entrada*/
1666   1      //  buffer[9]=buffer[9]+0x030;          /*hora de entrada*/
1667   1      //  buffer[10]=buffer[10]+0x030;          /*minutos de entrada*/
1668   1      
1669   1        /*placa*/
1670   1        if (rd_eeprom(0xa8,EE_PLACA)!=0)
1671   1        {   
1672   2          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 29  

1673   2            buffer[11]= placa[0];
1674   2            buffer[12]= placa[1];
1675   2            buffer[13]= placa[2];
1676   2            buffer[14]= placa[3];
1677   2            buffer[15]= placa[4];
1678   2            buffer[16]= placa[5];
1679   2      
1680   2        }
1681   1      
1682   1        if(*(Atributos_Expedidor + Type_Vehiculo) == AUTOMOVIL )
1683   1        {
1684   2          buffer[17]= 'C';
1685   2        }
1686   1        else
1687   1        {
1688   2          buffer[17]= 'M';
1689   2        }
1690   1        
1691   1        buffer[18]= ETX;
1692   1        buffer[19]= NULL;
1693   1        *longitud_trama_pto_paralelo=19;
1694   1        return buffer;
1695   1      }
1696          unsigned char *Armar_Trama_Monitor(unsigned char *Atributos_Expedidor)
1697          {
1698   1        static unsigned char buffer[24];
1699   1        unsigned char ticket[11];
1700   1        unsigned char j;
1701   1        /*la trama esta compuesta de
1702   1        STX,address_board,CMD,Tipo_Vehiculo,NoTICKET,:,fecha int añomesdishoraminuto,:,ETX*/
1703   1        Debug_Tibbo=False;
1704   1        buffer[0]=STX;
1705   1        buffer[1]=Dir_Board_Monitor();
1706   1        buffer[2]=CMD_MONITOR_EXPEDIDOR;
1707   1        if(Tipo_Vehiculo == AUTOMOVIL)
1708   1          {
1709   2            buffer[3]= 'C';
1710   2          }
1711   1        else
1712   1          {
1713   2            buffer[3]= 'M';
1714   2          }
1715   1          
1716   1          /*ticket*/
1717   1          if(MenSual !=  True)
1718   1          {
1719   2          buffer[4]=NULL;
1720   2          strcpy(ticket, Lee_No_Ticket());
1721   2          strcat(buffer , ticket);
1722   2          }
1723   1          else
1724   1          {
1725   2            ByteHex_Decimal(buffer+4,*(Atributos_Expedidor + Uid_2));
1726   2            j=strlen(buffer);
1727   2            buffer[j]= ' ';
1728   2            buffer[j+1]= NULL;
1729   2            j=strlen(buffer);
1730   2            Two_ByteHex_Decimal(buffer+j,*(Atributos_Expedidor + Uid_1),*(Atributos_Expedidor + Uid_0));
1731   2            
1732   2          }
1733   1          j=strlen(buffer);
1734   1          buffer[j++]=':';
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 30  

1735   1          /*fecha de entrada*/
1736   1          /*parte alta del año*/
1737   1          buffer[j++]= (((*(Atributos_Expedidor +  DateTime_year))  & 0xf0) >> 4)    | 0x30;
1738   1          buffer[j++]= ((*(Atributos_Expedidor +   DateTime_year))  & 0x0f)          | 0x30;
1739   1        
1740   1          /* parte alta mes*/
1741   1          buffer[j++]= (((*(Atributos_Expedidor +  DateTime_month))  & 0xf0) >> 4)   | 0x30;
1742   1          buffer[j++]= ((*(Atributos_Expedidor +   DateTime_month))  & 0x0f)         | 0x30;
1743   1          
1744   1          /*parte alta dia*/
1745   1          buffer[j++]= (((*(Atributos_Expedidor +  DateTime_day))  & 0xf0) >> 4)     | 0x30;
1746   1          buffer[j++]= ((*(Atributos_Expedidor +   DateTime_day))  & 0x0f)           | 0x30;  
1747   1          
1748   1          /*parte alta horas*/
1749   1          buffer[j++]= (((*(Atributos_Expedidor +  DateTime_hour))  & 0xf0) >> 4)    | 0x30;
1750   1          buffer[j++]= ((*(Atributos_Expedidor +   DateTime_hour))  & 0x0f)          | 0x30;    
1751   1          
1752   1          /*parte alta minutos*/
1753   1          buffer[j++]= (((*(Atributos_Expedidor +  DateTime_minutes))  & 0xf0) >> 4) | 0x30;
1754   1          buffer[j++]= ((*(Atributos_Expedidor +   DateTime_minutes))  & 0x0f)       | 0x30;  
1755   1          buffer[j++]=NULL;
1756   1          
1757   1          //Block_read_clock_ascii(buffer+j+1);     //leo la fecha de entrada
1758   1          j=strlen(buffer);
1759   1        
1760   1          buffer[j]= ':';
1761   1          buffer[j+1]=ETX;
1762   1          buffer[j+2]=NULL;
1763   1          Debug_Tibbo=True;
1764   1        return buffer;
1765   1      }
1766          void Armar_Trama_Placa(unsigned char *Buffer_Write_MF)
1767          {
1768   1        unsigned char j;
1769   1        unsigned char len_placa;
1770   1        len_placa = strlen(placa);
1771   1          if (len_placa ==0)
1772   1          {
1773   2            strcpy(placa, "NO_PLATE");
1774   2          }
1775   1          len_placa = strlen(placa);
1776   1          for(j=0; j<len_placa;j++)
1777   1          {
1778   2          *(Buffer_Write_MF +j)=placa[j];
1779   2          }
1780   1          /*lleno de ceros*/
1781   1            for (j=len_placa; j<16; j++)            
1782   1          {
1783   2            *(Buffer_Write_MF +j)=0x00;
1784   2          }
1785   1      }
1786          unsigned char Load_Secuencia_Expedidor(unsigned char *Secuencia_Expedidor,unsigned const  estadoactivo,uns
             -igned const estadoactual,unsigned const estadofuturo)
1787          {
1788   1        *(Secuencia_Expedidor + EstadoPasado ) = estadoactivo ;
1789   1        *(Secuencia_Expedidor + EstadoActual ) = estadoactual;
1790   1        *(Secuencia_Expedidor + EstadoFuturo ) = estadofuturo;
1791   1        return estadoactual;
1792   1      }
1793          unsigned char Disparo_Lock_Entrada_Vehiculo(unsigned char *Nombre_Mensual)
1794          {
1795   1        unsigned char Estado_expedidor;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 31  

1796   1        static unsigned char take_card=6;
1797   1        
1798   1        
1799   1        Debug_txt_Tibbo((unsigned char *) "TAKE CARD\r\n");
1800   1        
1801   1        //PantallaLCD(RETIRE_TARJETA);
1802   1        
1803   1        if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                   // CANAL LIBRE    no tiene tarjetas 
             -en el mecanismo
1804   1          {
1805   2            
1806   2            Debug_txt_Tibbo((unsigned char *) "TAREA_OPEN_BARRERA\r\n");
1807   2              
1808   2            take_card=6;
1809   2            lock=ON;
1810   2            send_portERR(BIENVENIDO);
1811   2            //send_portERR(AUDIO_ENTRADA);  
1812   2            PantallaLCD_LINEA_2(BIENVENIDO,Nombre_Mensual);
1813   2            Estado_expedidor=SEQ_PTO_PARALELO;
1814   2            
1815   2            
1816   2          }
1817   1        else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                      //  se detecta la tarjeta en la b
             -oca TARJETA EN BEZZEL
1818   1        {
1819   2          if(Valida_Sensor1_Auto()!= False)
1820   2          {
1821   3            if(take_card >= 6)
1822   3                  { PantallaLCD(RETIRE_TARJETA);
1823   4                    take_card=0;
1824   4                  }
1825   3                  else
1826   3                   {
1827   4                     take_card++;
1828   4                       
1829   4                   }
1830   3            
1831   3            ValTimeOutCom=TIME_PULSADOR;
1832   3            Estado_expedidor=SEQ_DETAIL_CARD;
1833   3            
1834   3          }
1835   2          else
1836   2          {
1837   3            Estado_expedidor=SEQ_CAPTURE_CARD;
1838   3          }
1839   2        
1840   2        }
1841   1        
1842   1          
1843   1        
1844   1        
1845   1        return Estado_expedidor;
1846   1      }
1847          unsigned char Send_Pto_Paralelo(unsigned char *Atributos_Expedidor)
1848          {
1849   1        unsigned char *Trama_Expedidor ;
1850   1        unsigned char leng_trama_pto;
1851   1        if(MenSual == True)
1852   1        {
1853   2        Trama_Expedidor=Armar_Trama_Pto_Paralelo_Expedidor_Mensual(Atributos_Expedidor,&leng_trama_pto );
1854   2        }
1855   1        else 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 32  

1856   1        {
1857   2          Trama_Expedidor=Armar_Trama_Pto_Paralelo_Expedidor(Atributos_Expedidor,&leng_trama_pto);
1858   2          Incremente_Ticket();
1859   2        }
1860   1        
1861   1        send_port(Trama_Expedidor,leng_trama_pto);  
1862   1        Debug_txt_Tibbo((unsigned char *) "Trama_pto_paralelo: ");
1863   1        DebugBufferMF(Trama_Expedidor,leng_trama_pto,SIN_MSJ  );
1864   1        
1865   1        
1866   1        
1867   1        clear_placa();
1868   1        ValTimeOutCom=TIME_WAIT ;
1869   1        Timer_wait=0;
1870   1        PULSADOR_BOTTON = 0;
1871   1        return SEQ_ESPERA_VEHICULO_ENTRE;
1872   1      }
1873          
1874          /*------------------------------------------------------------------------------
1875          ------------------------------------------------------------------------------*/
1876          unsigned char Entrega_Card_Captura()
1877          {
1878   1        unsigned char Estado_expedidor;
1879   1        
1880   1          
1881   1        Debug_txt_Tibbo((unsigned char *) "ESPERA VEHICULO ENTRE\r\n"); 
1882   1        sel_Sensor2();                                //garantiso q la barrera se encuentre en posicion baja  
1883   1        if ((DataIn==0))        
1884   1        {  
1885   2          if (ValidaSensor()==0)
1886   2          {
1887   3            lock=OFF;
1888   3            pto_paraleo=False;
1889   3            Debug_txt_Tibbo((unsigned char *) "Vehiculo Entrando OFF_BARRERA\r\n");
1890   3            Estado_expedidor=SEQ_INICIO;
1891   3          }
1892   2          
1893   2        }
1894   1        else
1895   1        {
1896   2            if(Valida_Sensor1_Auto()!= False)
1897   2            {
1898   3            /*presencia vehicular*/
1899   3              Estado_expedidor=SEQ_ESPERA_VEHICULO_ENTRE;//SEQ_INICIO;//
1900   3              
1901   3              if ((ValTimeOutCom == 1) || (ValTimeOutCom > TIME_WAIT))
1902   3              {
1903   4                  if (Timer_wait >= 5)
1904   4               {
1905   5                 pto_paraleo=False;
1906   5                 Debug_txt_Tibbo((unsigned char *) "Vehiculo TIEMPO OFF_BARRERA\r\n");
1907   5                
1908   5                 lock=OFF;
1909   5                 Timer_wait=0;
1910   5                 Estado_expedidor=SEQ_ESPERA_VEHICULO_ENTRE;
1911   5                 //Estado_expedidor=SEQ_INICIO;;
1912   5               }
1913   4              else if (Timer_wait <= 4)
1914   4               {
1915   5                ValTimeOutCom=TIME_WAIT ;
1916   5               }
1917   4             }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 33  

1918   3              
1919   3            }
1920   2            else
1921   2            {
1922   3            pto_paraleo=False;
1923   3            Debug_txt_Tibbo((unsigned char *) "Vehiculo NO LOOP OFF_BARRERA\r\n");
1924   3            lock=OFF;
1925   3            Estado_expedidor=SEQ_INICIO;
1926   3            }
1927   2        } 
1928   1       
1929   1        return Estado_expedidor;
1930   1      }
1931          unsigned char Wait_Placa()
1932          {
1933   1        //unsigned char *Atributos_Expedidor, unsigned char *Buffer_Write_MF
1934   1        unsigned char Estado_expedidor;
1935   1        
1936   1          Debug_txt_Tibbo((unsigned char *) "Wait_Placa");
1937   1        /*espera la llega de placa o cancel*/
1938   1        while ((ValTimeOutCom != 1) && (ValTimeOutCom <= TIME_WAIT) && (placa_ready == False))
1939   1        {
1940   2          if (rx_ip==0)                                                         /*pregunto si llega datos de monitor pto serie emulado*/
1941   2              {
1942   3                
1943   3                Rx_Monitor();
1944   3              }
1945   2        }
1946   1          
1947   1          if(placa_ready!=False || led_err_imp==0)
1948   1            {
1949   2              /*llego placa*/
1950   2              Estado_expedidor = Respuesta_Placa_Cancel();
1951   2            }
1952   1            else
1953   1              /*no llego placa o cancel*/
1954   1            {
1955   2                Estado_expedidor=SEQ_WAIT_PLACA;
1956   2             if ((ValTimeOutCom == 1) || (ValTimeOutCom > TIME_WAIT))
1957   2             {  
1958   3              if (Timer_wait >= 3)                      //5
1959   3               {
1960   4                 /*sale por tiempo*/
1961   4                 strcpy (placa,"NOPLATE");
1962   4                 Estado_expedidor=SEQ_CLASE_TARJETAS;//SEQ_SECOND_PASSWORD;       //SEQ_FRONT_CARD;
1963   4               }
1964   3              else if (Timer_wait <= 2)                 //4
1965   3               {
1966   4                ValTimeOutCom=TIME_WAIT ;
1967   4               }
1968   3             }
1969   2            }
1970   1        return Estado_expedidor;
1971   1      }
1972          /*unsigned char Valida_Vehiculo_Card_Mensual(unsigned char *Atributos_Expedidor)
1973          {
1974            unsigned char Estado_expedidor;
1975            
1976              Debug_txt_Tibbo((unsigned char *) "VEHICULO MENSUAL TARJETA: ");
1977              if(*(Atributos_Expedidor + Type_Vehiculo  ) == False)
1978               {
1979                Debug_txt_Tibbo((unsigned char *) "(0) CARRO");
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 34  

1980               }
1981              else
1982               {
1983                Debug_txt_Tibbo((unsigned char *) "(1) MOTO");
1984               }
1985                                
1986              Debug_txt_Tibbo((unsigned char *) "\r\n");
1987            if ((rd_eeprom(0xa8,EE_VALIDA_TIPO_VEHICULO_MENSUAL)) != True) 
1988            {
1989              if  (*(Atributos_Expedidor + Type_Vehiculo  ) == Tipo_Vehiculo )          
1990              {
1991               Debug_txt_Tibbo((unsigned char *) "COINCIDE CARD CON LOOK\r\n ");
1992                Estado_expedidor = True ;
1993              }
1994              
1995              else
1996              {
1997                send_portERR(PRMR_ERROR_TIPO_VEHICULO); 
1998                Debug_txt_Tibbo((unsigned char *) "TIPO DE VEHICULO NO CORRESPONDE\r\n ");
1999                Estado_expedidor = False; 
2000              }
2001            } 
2002            else 
2003            {
2004                Debug_txt_Tibbo((unsigned char *) "NO INTERESA COINCIDENCIA CARD CON LOOK\r\n ");
2005                Estado_expedidor = True ;
2006            }
2007              return Estado_expedidor;
2008          */
2009          /*unsigned char Tarjeta_Mensual(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
2010          //{
2011          //  unsigned char Estado_expedidor;
2012          //  unsigned char fecha_asii[7];
2013            
2014            /*cheque la fecha de expiracion del mensual*/
2015          //  if (Horarios(Atributos_Expedidor) == True)
2016          //  {
2017          //   if ( check_fechaOut(Atributos_Expedidor+Expira_ano) == True )
2018          //      {
2019                  /*valida el vehiculo en el loop y en la card*/
2020          //        if( Valida_Vehiculo_Card_Mensual(Atributos_Expedidor) == False)
2021          //        {
2022          //        Estado_expedidor =  SEQ_CAPTURE_CARD; //Captura_Expulsa();    
2023          //        }
2024          //        else
2025          //        {
2026          //          Debug_txt_Tibbo((unsigned char *) "MENSUAL AL DIA\r\n");  
2027          //          *(Atributos_Expedidor + Sector) = Sector_1;
2028          //          *(Atributos_Expedidor + Bloque) = Bloque_2;
2029          //          Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
2030          //          Estado_expedidor=SEQ_WRITE_SECTOR_BLOQUE;
2031          //        }
2032          //      }
2033          //      else 
2034          //      {
2035          //        send_portERR(PRMR_TARJETA_VENCIDA); 
2036                      
2037          //        PantallaLCD(TARJETA_VENCIDA);
2038          //        Debug_txt_Tibbo((unsigned char *) "MENSUAL EXPIRA\r\n");
2039          //        Estado_expedidor = SEQ_EXPULSAR_CARD;
2040          //      }
2041          //  }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 35  

2042          //  else
2043          //  {
2044              
2045          //    Estado_expedidor = SEQ_EXPULSAR_CARD;
2046            //}
2047          //  return Estado_expedidor;
2048          //}*/
2049          unsigned char Tarjeta_Rotacion(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
2050          {
2051   1              *(Atributos_Expedidor + Sector) = Sector_1;
2052   1                *(Atributos_Expedidor + Bloque) = Bloque_2;
2053   1                Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
2054   1                return  SEQ_WRITE_SECTOR_BLOQUE;
2055   1        
2056   1        
2057   1      }
2058          unsigned char Valida_Tipo_Tarjeta(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
2059          {
2060   1        unsigned char Estado_expedidor;
2061   1        //if(*(Atributos_Expedidor + Tipo_Tarjeta) ==  MENSUALIDAD)
2062   1        //{
2063   1        //  Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA MENSUALIDAD\r\n ");
2064   1        //  if(MenSual ==  True)
2065   1        //  {
2066   1          
2067   1          /*APB Habilitado por software*/
2068   1          
2069   1          //  if( (rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL) == APB_HABILITADO_SOFT) )
2070   1        //    {
2071   1              /*APB por Card*/
2072   1           
2073   1          //    if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) || (*(A
             -tributos_Expedidor + Apb) == APB_NO))       
2074   1          //    {
2075   1          //      Estado_expedidor = Tarjeta_Mensual(Atributos_Expedidor,Buffer_Write_MF );
2076   1      
2077   1          //    }
2078   1          //    else
2079   1          //    {
2080   1          //      Debug_txt_Tibbo((unsigned char *) "ERROR: INT ANTIPASSBACK MENSUAL \r\n");
2081   1          //      send_portERR(PRMR_SIN_SALIDA);
2082   1          //      Estado_expedidor =  SEQ_CAPTURE_CARD; // Captura_Expulsa(); 
2083   1          //    } 
2084   1          //  }
2085   1          
2086   1        //  else
2087   1        //  {
2088   1          //  Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK INHABILITADO MENSUAL \r\n");
2089   1          
2090   1          // Estado_expedidor = Tarjeta_Mensual(Atributos_Expedidor,Buffer_Write_MF );
2091   1          //}
2092   1        //}
2093   1        //else
2094   1        // {
2095   1        //  send_portERR(PRMR_NO_CARD_MENSUAL);
2096   1        //  PantallaLCD(NO_CARD_MENSUAL);     
2097   1        //  Estado_expedidor =  SEQ_CAPTURE_CARD; //Captura_Expulsa();  
2098   1        // } 
2099   1       //}
2100   1        if (*(Atributos_Expedidor + Tipo_Tarjeta) ==  ROTACION)
2101   1        {
2102   2          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 36  

2103   2            Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA ROTACION\r\n ");
2104   2          if(MenSual != True)
2105   2          {
2106   3            if ( (rd_eeprom(0xa8,EE_HABILITA_APB))!= APB_INHABILITADO_SOFT)
2107   3            {
2108   4              if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) || (*(Atr
             -ibutos_Expedidor + Apb) == APB_NO) )
2109   4                                    
2110   4              {
2111   5                Estado_expedidor = Tarjeta_Rotacion(Atributos_Expedidor,Buffer_Write_MF );
2112   5              }
2113   4              else
2114   4              {
2115   5                Debug_txt_Tibbo((unsigned char *) "ERROR: INT ANTIPASSBACK ROTACION \r\n");
2116   5                send_portERR(PRMR_SIN_SALIDA);
2117   5                PantallaLCD(SIN_SALIDA);
2118   5                Estado_expedidor =  SEQ_CAPTURE_CARD; //Captura_Expulsa();
2119   5              }
2120   4            }
2121   3            else
2122   3            {
2123   4              Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK INHABILITADO ROTACION \r\n");
2124   4              Estado_expedidor = Tarjeta_Rotacion(Atributos_Expedidor,Buffer_Write_MF );
2125   4            } 
2126   3          }
2127   2          else
2128   2          {
2129   3            /*tarjeta por insercion por boca */ 
2130   3            send_portERR(PRMR_NO_CARD_MENSUAL);
2131   3            PantallaLCD(NO_CARD_MENSUAL);     
2132   3            Estado_expedidor =SEQ_CAPTURE_CARD; //SEQ_EXPULSAR_CARD;        //Captura_Expulsa();    
2133   3          }
2134   2        }
2135   1        else
2136   1        {
2137   2          Debug_txt_Tibbo((unsigned char *) "TIPO NUEVO DE TARJETA SIN DEFINIR\r\n ");
2138   2          send_portERR(PRMR_NO_ROTACION);
2139   2          
2140   2          Estado_expedidor =  SEQ_CAPTURE_CARD; //Captura_Expulsa();    
2141   2        }
2142   1        
2143   1        return Estado_expedidor;
2144   1      }
2145          /*
2146          unsigned char Festivos()
2147          {
2148            
2149            unsigned char dia_semana,day, month, year,DiaFestivo=0;
2150          
2151            
2152            dia_semana=bcd_hex(lee_clk(RDIA_SEMANA));
2153            day = bcd_hex(lee_clk(RDIA));
2154            month = bcd_hex(lee_clk(RMES));
2155            year = bcd_hex(lee_clk(RANO));
2156            
2157            if (year==20)
2158            {
2159              if (((month==1)&&(day==1))||((month==1)&&(day==6))||((month==3)&&(day==23))||((month==4)&&(day==9))||((m
             -onth==4)&&(day==10))||((month==5)&&(day==1))||((month==5)&&(day==25))||((month==6)&&(day==3)))  
2160              {
2161                DiaFestivo = True;
2162                }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 37  

2163              else if (((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==17))||((month==10)&&(day==1
             -2))||((month==11)&&(day==2))||((month==11)&&(day==16))||((month==12)&&(day==8))||((month==12)&&(day==25)))
2164              {
2165                DiaFestivo = True;
2166              }
2167          
2168            }
2169            else if (year==21)
2170            {
2171              if (((month==1)&&(day==1))||((month==1)&&(day==11))||((month==3)&&(day==22))||((month==4)&&(day==1))||((
             -month==4)&&(day==2))||((month==5)&&(day==1))||((month==5)&&(day==17))||((month==6)&&(day==7))||((month==6)&&(day==14))) 
2172              {
2173                DiaFestivo = True;
2174                }
2175              else if (((month==7)&&(day==5))||((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==16)
             -)||((month==10)&&(day==18))||((month==11)&&(day==1))||((month==11)&&(day==15))||((month==12)&&(day==8))||((month==12)&&(
             -day==25)))
2176              {
2177                DiaFestivo = True;
2178              }
2179          
2180            }
2181            else if (year==22)
2182            {
2183              if (((month==1)&&(day==1))||((month==1)&&(day==10))||((month==3)&&(day==21))||((month==4)&&(day==14))||(
             -(month==4)&&(day==15))||((month==5)&&(day==1))||((month==5)&&(day==30))||((month==6)&&(day==20))||((month==6)&&(day==27)
             -))  
2184              {
2185                DiaFestivo = True;
2186                }
2187              else if (((month==7)&&(day==4))||((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==15)
             -)||((month==10)&&(day==17))||((month==11)&&(day==7))||((month==11)&&(day==14))||((month==12)&&(day==8))||((month==12)&&(
             -day==25)))
2188              {
2189                DiaFestivo = True;
2190              }
2191          
2192            
2193            
2194            }
2195            if ((dia_semana == Sabado)||(dia_semana == Domingo)||(DiaFestivo == True))
2196            {
2197              DiaFestivo = True;
2198            }
2199            else
2200            {
2201              DiaFestivo = False;
2202            }
2203            return DiaFestivo;
2204          }
2205          */
2206          /*
2207          unsigned char Dia_Pico_Placa(unsigned char * Atributos_Expedidor)
2208          {
2209            unsigned char Par_Impar;
2210            unsigned char dato;
2211            
2212            if( Festivos() == False)
2213            {
2214            dato=lee_clk(RDIA);
2215          
2216              if((dato % 2 == False) && (*(Atributos_Expedidor + Pico_Placa)  == True))
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 38  

2217              {
2218              
2219              /*es par*/
2220          /*
2221              Par_Impar = True;
2222              
2223              }
2224              else
2225              {
2226              /*es impar */
2227              /*
2228              Par_Impar = False;
2229              }
2230            }
2231            else
2232            {
2233              Par_Impar = True;
2234            }
2235            return Par_Impar;
2236          }
2237          */
2238          /*unsigned char Horarios(unsigned char * Atributos_Expedidor)
2239          {
2240            unsigned char Estado_Horario;
2241            
2242            unsigned char Addr_horarios [11];
2243            unsigned char dia_semana,EE_dia_semana;
2244            unsigned int addr;
2245            if (*(Atributos_Expedidor + Horario) != False )
2246            {
2247              /*se Lee la direccion del horario*/
2248          /*    strcpy (Addr_horarios,(Addr_Horarios()));
2249              
2250              addr= Addr_horarios[(*(Atributos_Expedidor + Horario)) -1] ;
2251              
2252               /*leemos si esta habilitado*/
2253              
2254            /*  if ((rd_eeprom(0xa8,addr + HABILITA_ADDR)) == True)
2255              {
2256                /*miramos si el dia de la semana esta habilitado*/
2257            /*    dia_semana = lee_clk(RDIA_SEMANA);
2258                Debug_txt_Tibbo((unsigned char *) "DIA DE LA SEMANA: ");
2259                Debug_chr_Tibbo(dia_semana);
2260                Debug_txt_Tibbo((unsigned char *) "\r\n");
2261                
2262              
2263                EE_dia_semana = rd_eeprom(0xa8,addr + dia_semana - 1 ) -0x30;
2264                Debug_txt_Tibbo((unsigned char *) "DIA PROGRAMADO: ");
2265                Debug_chr_Tibbo(EE_dia_semana);
2266                Debug_txt_Tibbo((unsigned char *) "\r\n");
2267              
2268                if ( EE_dia_semana == dia_semana)
2269                {
2270                  /*miramos si esta en el rango del horario*/
2271            /*      Estado_Horario = Bloque_Horario(addr);
2272                }
2273                else
2274                {
2275          
2276                  Debug_txt_Tibbo((unsigned char *) "HORARIO DEL DIA NO PROGRAMADO\r\n");
2277                  Estado_Horario= False;
2278                }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 39  

2279              }
2280              else 
2281              {
2282                
2283                Estado_Horario= False;
2284                PantallaLCD(HORARIO_NO_PROG);
2285                Debug_txt_Tibbo((unsigned char *) "INHABILITADO HORARIO \r\n");
2286                
2287              }
2288              
2289            }
2290            else
2291            {
2292              Estado_Horario = True;
2293            
2294              Debug_txt_Tibbo((unsigned char *) "NO TIENE HORARIO PROGRAMADO\r\n");
2295            }
2296            return Estado_Horario;
2297          }
2298          unsigned int Hora_Maxima(unsigned int addr)
2299          {
2300            unsigned char Hora_High,  Minuto_High;
2301            unsigned char HoraIni , MinutoIni; 
2302            unsigned int  Hora_Prog;
2303            
2304             Hora_High    = (rd_eeprom(0xa8, (addr + Hora_High_addr_Desde )) - 0x30)  << 4;
2305             HoraIni      = Hora_High | ((rd_eeprom(0xa8, (addr + Hora_Low_addr_Desde ))) - 0x30);
2306             Minuto_High  = ((rd_eeprom(0xa8, (addr + Minutos_High_addr_Desde ))) - 0x30)  << 4;
2307             MinutoIni    =  Minuto_High | ((rd_eeprom(0xa8, (addr +  Minutos_Low_addr_Desde ))) - 0x30);
2308             Debug_chr_Tibbo(HoraIni);
2309             Debug_chr_Tibbo(MinutoIni);
2310             Debug_txt_Tibbo((unsigned char *) "\r\n");
2311            
2312             return Hora_Prog = (HoraIni *60) + (MinutoIni ) ;
2313          }
2314          unsigned char En_Horario(unsigned int HoraNow, unsigned int Hora_Prog,unsigned int addr)
2315          {
2316            unsigned char Estado_Horario; 
2317            
2318            if( Hora_Prog  <=  HoraNow )        //HoraNow >=  Hora_Prog 
2319            {
2320              
2321              /*hasta la hora que puede ingresar el vehiculo */
2322          /*    Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA HASTA: ");
2323              Hora_Prog = Hora_Maxima(addr+4);
2324          
2325            
2326              if( HoraNow <= Hora_Prog)
2327              {
2328                //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2329                Debug_txt_Tibbo((unsigned char *) "EN HORARIO PROGRAMADO\r\n");
2330                Estado_Horario = True;
2331              }
2332              else
2333              {
2334                //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2335                //PantallaLCD(MENSUAL_FUERA_HORARIO);
2336                Debug_txt_Tibbo((unsigned char *) "DESPUES DEL HORARIO PROGRAMADO\r\n");
2337                Estado_Horario = False;
2338              }
2339              
2340            }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 40  

2341            else
2342            {
2343                  //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2344                  //PantallaLCD(MENSUAL_FUERA_HORARIO);
2345                  Debug_txt_Tibbo((unsigned char *) "ANTES DEL HORARIO PROGRAMADO\r\n");
2346                  Estado_Horario = False;
2347                
2348            }
2349            return Estado_Horario;
2350          }
2351          
2352          unsigned Bloque_Horario(unsigned int addr)
2353          {
2354            unsigned char Estado_Horario; 
2355            unsigned int HoraNow, Hora_Prog;
2356            
2357            /*la hora del momento de entrada del vehiculo*/
2358            /*
2359            Debug_txt_Tibbo((unsigned char *) "HORA AHORA: ");
2360            Debug_chr_Tibbo(lee_clk(RHORA));
2361            Debug_chr_Tibbo(lee_clk(RMIN));
2362            Debug_txt_Tibbo((unsigned char *) "\r\n");
2363            HoraNow = (lee_clk(RHORA) * 60) + (lee_clk(RMIN) );
2364            
2365            /* desde la hora en que puede ingresar vehiculo */
2366            
2367            /*
2368            Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA DESDE: ");
2369            Hora_Prog = Hora_Maxima(addr);
2370            Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr);
2371            if(Estado_Horario == False )
2372            {
2373              
2374                
2375                if(rd_eeprom(0xa8,addr + Segundo_Tiempo ) == True)
2376                {
2377                  Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA SEGUNDA DESDE: ");
2378                  Hora_Prog = Hora_Maxima(addr+10);
2379                  Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr+10);
2380                }
2381                else
2382                {
2383                  send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2384                  PantallaLCD(MENSUAL_FUERA_HORARIO);
2385                  Estado_Horario = False;
2386                }
2387            }
2388          
2389          return Estado_Horario;
2390          }*/
2391          /*------------------------------------------------------------------------------
2392          Secuencia de los cmd de inicio (reset dispositivo y graba eeprom)
2393          
2394          funcion  de los cmd de inicio (reset dispositivo y graba eeprom) retorna un (00) cuando a terminado exitos
             -o
2395          ------------------------------------------------------------------------------*/
2396          
2397          
2398          unsigned char  Secuencia_inicio_expedidor(void)
2399          {
2400   1        char temp;
2401   1        switch (Estado)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 41  

2402   1        {
2403   2          case INICIA_LINTECH:
2404   2      
2405   2                
2406   2              Inicializa(SIN_MOVIMIENTO);                                       //Inicio el transporte sin movimiento
2407   2              Estado=SEQ_CAPTURE_DATOS_INI;                                     // entra a validar la respuesta del transporte
2408   2              
2409   2            
2410   2            return (Estado);
2411   2          break;
2412   2      
2413   2      
2414   2      /*------------------------------------------------------------------------------
2415   2      Envia la primera trama de inicializacion del transporte sin movimiento
2416   2            (0) LA RESPUESTA ES OK
2417   2            (1) NO RESPONDE EL PTO SERIE
2418   2            (2) NO RECIBIDO LA TRAMA 
2419   2            (3) ERROR DE TRAMA CMD (N)
2420   2      ------------------------------------------------------------------------------*/
2421   2            
2422   2          case SEQ_CAPTURE_DATOS_INI:
2423   2      
2424   2            if((temp=Trama_Validacion_P_N())!=0)
2425   2          {
2426   3            if(temp==2)
2427   3            {
2428   4            Estado=SEQ_CAPTURE_DATOS_INI;                                                         /*(2)no ha respondido*/
2429   4            } 
2430   3            else if (temp==3)
2431   3            {
2432   4            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO ERROR\r\n\r\n");         /* trama no valida*/
2433   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
2434   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
2435   4            }
2436   3            else
2437   3            {
2438   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
2439   4              Estado=INICIA_LINTECH;                                                              /*(1) no responde el pto*/  
2440   4            }
2441   3          }
2442   2          else
2443   2          {
2444   3            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO OK\r\n\r\n");            /* trama valida Habilit
             -ado */
2445   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
2446   3            Estado=GRABA_EEPROM;                                                                  /*(0) respuesta ok*/
2447   3          }     
2448   2          return (Estado);
2449   2          break;
2450   2            
2451   2      /*------------------------------------------------------------------------------
2452   2      Envia el cmd de grabar claves a la eeprom del transporte 
2453   2      ------------------------------------------------------------------------------*/
2454   2            
2455   2            case GRABA_EEPROM:
2456   2              
2457   2              Dwload_EEprom();                                                                    //envio el cmd de grabar la eeprom
2458   2              Estado=SEQ_CAPTURA_OK_EEPROM;                                                       // entra a validar la respuesta del transport
             -e
2459   2            
2460   2            
2461   2      
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 42  

2462   2            return (Estado);
2463   2              break;
2464   2        
2465   2      /*------------------------------------------------------------------------------
2466   2      se analiza la respuesta 
2467   2            (0) LA RESPUESTA ES OK
2468   2            (1) NO RESPONDE EL PTO SERIE
2469   2            (2) NO RECIBIDO LA TRAMA 
2470   2            (3) ERROR DE TRAMA CMD (N)
2471   2      ------------------------------------------------------------------------------*/
2472   2            
2473   2          case SEQ_CAPTURA_OK_EEPROM:
2474   2          
2475   2          if((temp=Trama_Validacion_P_N())!=0)
2476   2          {
2477   3            if(temp==2)
2478   3            {
2479   4            Estado=SEQ_CAPTURA_OK_EEPROM;                                                         /*no ha respondido*/
2480   4            }
2481   3            else if (temp==3)
2482   3            {
2483   4            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM ERROR\r\n\r\n");                     /* trama no valida respuest
             -a incorrecta falla en la escritura de la clave*/
2484   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
2485   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
2486   4            }     
2487   3            else
2488   3            {
2489   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
2490   4              Estado=INICIA_LINTECH;                                                              /*NO RESPONDE PTO SERIE */
2491   4            }       
2492   3          }
2493   2          else
2494   2          {
2495   3            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM OK\r\n\r\n");                        /* trama valida Habilitado */
2496   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
2497   3            Estado=FIN_OK;                                                                        /*respuesta ok clave grabada con exito*/
2498   3          }     
2499   2      
2500   2          return (Estado);
2501   2          break;
2502   2      
2503   2      /*------------------------------------------------------------------------------
2504   2      Fin de la secuencia de comandos con exito 
2505   2      ------------------------------------------------------------------------------*/    
2506   2            
2507   2              case FIN_OK:
2508   2      
2509   2              return (Estado);
2510   2          break;
2511   2            
2512   2                
2513   2              default:
2514   2              return Estado=INICIA_LINTECH; 
2515   2              break;
2516   2        }
2517   1      }
2518          
2519          /*------------------------------------------------------------------------------
2520          Prosedimiento  q hace paso a paso la secuencia de la MF
2521          atributos
2522          ValTimeOutCom = tiempo que  espera para recibir datos pto serie
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 43  

2523          Tarjeta_on = detecto vehiculo en loop y tiene tarjeta en boca
2524          g_cEstadoComSeqMF = nos dice en el estado que nos encontramos dentro del seguimiento
2525          ------------------------------------------------------------------------------*/
2526          
2527          unsigned char SecuenciaExpedidorMF( unsigned char EstadoActivo)
2528          {
2529   1        static unsigned char Buffer_Write_MF[17];
2530   1        static unsigned char Atributos_Expedidor[20];
2531   1        static unsigned char Secuencia_Expedidor[4];
2532   1        static unsigned char Nombre_Mensual[17];
2533   1        
2534   1        
2535   1        
2536   1        switch (EstadoActivo)
2537   1        {
2538   2      //***********************************************************************************************
2539   2          
2540   2          case SEQ_INICIO:
2541   2      
2542   2            if ((buffer_ready == True)|| (ValTimeOutCom > TIME_PULSADOR ))        /*TIME_CARD*/
2543   2            {
2544   3              lock=OFF;                                                                                   /*rele de disparo a la barrera*/
2545   3              Atascado_GP0_PIN_3 = OFF;                                                                          /*activo el rele de reset del verificad
             -or logica negativa*/    
2546   3              Check_Status(SENSOR_NORMAL);                                                              /* se pregunta al transporte en q estado es
             -tan las TI*/
2547   3              EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_
             -TRANSPORTE);
2548   3              Secuencia_Expedidor [ TareadelCmd  ] = TAREA_SENSORES_TRANSPORTE;
2549   3            }
2550   2            
2551   2            break;
2552   2          case  SEQ_CMD_ACEPTADO:
2553   2          /*cmd comun para todos*/
2554   2            EstadoActivo=rta_cmd_transporte(Secuencia_Expedidor);
2555   2            break;
2556   2          case SEQ_MOVER_CARD_RF:
2557   2            Mov_Card(MovPos_RF);
2558   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_TIPO_CARD);
2559   2            break;
2560   2          case SEQ_TIPO_CARD:
2561   2            Aut_Card_check_Status();
2562   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2563   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_TIPO_TARJETA;
2564   2            break;
2565   2          
2566   2          case SEQ_LOAD_PASSWORD:
2567   2            LoadVerify_EEprom();
2568   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_READ_SECTOR
             -_BLOQUE);
2569   2            Atributos_Expedidor [ Sector ]    = Sector_1;
2570   2            Atributos_Expedidor [ Bloque ]    = Bloque_1;
2571   2            break;
2572   2          case SEQ_READ_SECTOR_BLOQUE:
2573   2            RD_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ]);
2574   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2575   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_LECTURA_TARJETA_SECTOR_BLOQUE;
2576   2            break;
2577   2          case SEQ_WRITE_SECTOR_BLOQUE:
2578   2            WR_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ],Buffer_Write_MF);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 44  

2579   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2580   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_WRITE_TARJETA_SECTOR_BLOQUE;
2581   2            break;
2582   2          case SEQ_CAPTURE_CARD:
2583   2            Mov_Card(MovPos_Capture);
2584   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_INICIO);     
             -//SEQ_INICIOSEQ_MOVER_CARD_RF
2585   2            Atascado_GP0_PIN_3 = OFF;     
2586   2          break;
2587   2          case SEQ_CARD_INSERCION_OFF:
2588   2            Card_Insercion(Inhabilita);
2589   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_EXPULSAR_CA
             -RD);
2590   2            break;
2591   2          case SEQ_EXPULSAR_CARD:
2592   2            Mov_Card(MovPos_Front);
2593   2            MenSual = False;
2594   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_INICIO);    
2595   2            break;
2596   2          case SEQ_FRONT_CARD:
2597   2            Mov_Card(MovPos_Front);
2598   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_DETAIL_CAR
             -D);    
2599   2            break;
2600   2          case SEQ_DETAIL_CARD:
2601   2            if ((buffer_ready ==True)|| (ValTimeOutCom > TIME_PULSADOR))
2602   2            {
2603   3            Check_Status(SENSOR_DETAIL);    
2604   3            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);    
2605   3            Secuencia_Expedidor[TareadelCmd ] = TAREA_OPEN_BARRERA;
2606   3            }
2607   2            break;
2608   2      
2609   2          case SEQ_LOAD_EEPROM:
2610   2            Dwload_EEprom();
2611   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_READ_SECT
             -OR_BLOQUE);  
2612   2            break;
2613   2          case SEQ_ESPERA_VEHICULO_ENTRE:
2614   2            MenSual = False;
2615   2            EstadoActivo = Entrega_Card_Captura();
2616   2            break;
2617   2          case SEQ_PTO_PARALELO:
2618   2            EstadoActivo = Send_Pto_Paralelo(Atributos_Expedidor);
2619   2            break;
2620   2          case SEQ_WAIT_PLACA:
2621   2            
2622   2            ValTimeOutCom=TIME_WAIT ;
2623   2            EstadoActivo = Wait_Placa();  //Secuencia_Expedidor,EstadoActivo //Atributos_Expedidor,Buffer_Write_MF
2624   2            break;
2625   2          case SEQ_UID: 
2626   2            Unique_Identifier_UID();
2627   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA
             -_TRANSPORTE);    
2628   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_UID ;
2629   2            break;
2630   2          case SEQ_LPR:
2631   2            EstadoActivo = Pregunta_Lpr(Atributos_Expedidor);
2632   2            break;
2633   2          case SEQ_PLACA:
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 45  

2634   2            pto_paraleo=True;
2635   2            EstadoActivo = Pregunta_Placa_Habilitada();
2636   2            break;
2637   2          case SEQ_CLASE_TARJETAS:
2638   2            EstadoActivo = Valida_Tipo_Tarjeta(Atributos_Expedidor,Buffer_Write_MF);;
2639   2            break;
2640   2          case SEQ_CAPTURE_CARD_LOOP:
2641   2            
2642   2            
2643   2              Mov_Card(MovPos_Capture);
2644   2              EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUEST
             -A_TRANSPORTE);     //SEQ_INICIOSEQ_MOVER_CARD_RF TAREA_PRESENCIA_ROTACION
2645   2              Secuencia_Expedidor[TareadelCmd ] = TAREA_PRESENCIA_ROTACION;
2646   2            
2647   2            break;
2648   2          case SEQ_POWER_OFF:
2649   2            Power_off();
2650   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_UID);
2651   2            break;
2652   2          case SEQ_POWER_ON:
2653   2            Power_off();
2654   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_LOAD_PASS
             -WORD);
2655   2            break;
2656   2          case SEQ_SECOND_PASSWORD:
2657   2            Clave_Seguridad_S2();
2658   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA
             -_TRANSPORTE);
2659   2            Secuencia_Expedidor [TareadelCmd]  = TAREA_WRITE_PLACA_CARD;
2660   2            break;
2661   2          case SEQ_REELER_CARD_SECTOR1_BLOQUE1:
2662   2            
2663   2            RD_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ]);
2664   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2665   2            EstadoActivo = Responde_ReeLectura_Tarjeta_Sector1_Bloque2(Buffer_Write_MF,Atributos_Expedidor);
2666   2            break;
2667   2          case SEQ_PRESENCIA_VEHICULAR:
2668   2            if ((buffer_ready == True)|| (ValTimeOutCom > TIME_WAIT ))        /*TIME_CARD*/
2669   2            {
2670   3            EstadoActivo=Analiza_Presencia_rotacion();
2671   3            }
2672   2          break;
2673   2          case SEQ_INGRESO_PRECARGA:
2674   2            if ((buffer_ready == True)|| (ValTimeOutCom > TIME_PULSADOR )||(rx_ip==0))        /*TIME_CARD*/
2675   2            {
2676   3              if (rx_ip==0)                                                         /*pregunto si llega datos de monitor pto serie emulado*/
2677   3              {
2678   4                 Rx_Monitor();
2679   4              }
2680   3             EstadoActivo=Ingreso_Vehiculo();
2681   3            }
2682   2            else
2683   2            {
2684   3              if (rx_ip==0)                                                         /*pregunto si llega datos de monitor pto serie emulado*/
2685   3              {
2686   4                 Rx_Monitor();
2687   4              }
2688   3            }
2689   2            break;
2690   2      /*------------------------------------------------------------------------------
2691   2          Tareas especificas de cada paso
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 46  

2692   2      ------------------------------------------------------------------------------*/      
2693   2          case SEQ_RESPUESTA_TRANSPORTE:
2694   2            ValTimeOutCom=TIME_WAIT;
2695   2            if (Secuencia_Expedidor [TareadelCmd]==TAREA_SENSORES_TRANSPORTE)
2696   2            {
2697   3            EstadoActivo=Responde_Estado_Sensores_Transporte(); 
2698   3              ValTimeOutCom=TIME_PULSADOR;
2699   3            
2700   3            }
2701   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_TIPO_TARJETA)
2702   2                {
2703   3                  
2704   3                  EstadoActivo=Responde_Tipo_Tarjeta();
2705   3                }
2706   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_LECTURA_TARJETA_SECTOR_BLOQUE)
2707   2                {
2708   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_1))
2709   3                  {
2710   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque1 (Atributos_Expedidor);
2711   4                  }
2712   3                  else if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_0))
2713   3                  {
2714   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque0 (Nombre_Mensual);
2715   4                  }
2716   3                  else
2717   3                  {
2718   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque2(Atributos_Expedidor);
2719   4                  }
2720   3                }
2721   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_WRITE_TARJETA_SECTOR_BLOQUE)
2722   2                { 
2723   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_2))
2724   3                  { 
2725   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque2 (Atributos_Expedidor,Buffer_Write_MF);
2726   4                  }
2727   3                  else if ((Atributos_Expedidor [ Sector ]== Sector_2)&& (Atributos_Expedidor [ Bloque ]==Bloque_0))
2728   3                  {
2729   4                    EstadoActivo=Responde_Write_Tarjeta_Sector2_Bloque0(Buffer_Write_MF);
2730   4                  }
2731   3                    else if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_1))
2732   3                  {
2733   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque1(Buffer_Write_MF);
2734   4                  }
2735   3                  else
2736   3                  {
2737   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque0 (Buffer_Write_MF);
2738   4                  }
2739   3                }
2740   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_OPEN_BARRERA)
2741   2                {   
2742   3                  EstadoActivo = Disparo_Lock_Entrada_Vehiculo(Nombre_Mensual);
2743   3                }
2744   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_WRITE_PLACA_CARD)
2745   2                {   
2746   3                  EstadoActivo = Respuesta_Segunda_clave(Atributos_Expedidor,Buffer_Write_MF);
2747   3                }
2748   2                    
2749   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_UID ) 
2750   2                {
2751   3                  EstadoActivo = Analiza_Uid_Card(Atributos_Expedidor);
2752   3                } 
2753   2      
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/14/2021 15:59:55 PAGE 47  

2754   2      
2755   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_PRESENCIA_ROTACION  ) 
2756   2                {
2757   3                  EstadoActivo = Analiza_Presencia_rotacion();
2758   3                }   
2759   2            else
2760   2                {
2761   3                  Debug_txt_Tibbo((unsigned char *) "TAREA_3\r\n");
2762   3                }
2763   2            break;
2764   2          default:
2765   2          EstadoActivo = SEQ_INICIO;  
2766   2          break;  
2767   2            
2768   2        } 
2769   1        return EstadoActivo;
2770   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7752    ----
   CONSTANT SIZE    =   1665    ----
   XDATA SIZE       =    145     208
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
