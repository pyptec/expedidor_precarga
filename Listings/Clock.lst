C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE CLOCK
OBJECT MODULE PLACED IN .\Objects\Clock.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Clock.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\Clock.lst) TABS(2) OBJECT(.\Objects\Clock.obj)

line level    source

   1          
   2          #include <Clock.h>
   3          #include <reg51.h>
   4          
   5          /*funcion prototipo*/
   6          extern void Delay (void);
   7          extern void Delay_20us(unsigned int cnt);
   8          extern void Debug_Fecha_actual(unsigned char *buffer);
   9          extern float pow   (float x, float y);
  10          extern void Debug_chr_Tibbo(unsigned char Dat);
  11          extern void Debug_txt_Tibbo(unsigned char * str);
  12          extern void Debug_HexDec(unsigned char xfc);
  13          /*variables externas */
  14          extern unsigned char  Debug_Tibbo;
  15          
  16          sbit sck = P1^4 ;                 /* define I/O functions     */
  17          sbit io  = P1^5 ;
  18          sbit rst = P1^6 ;
  19          /*CMD DE ESCRITURA RELOJ*/
  20          #define WDIA            0x86
  21          #define WMES            0x88
  22          #define WANO            0x8C
  23          #define WHORA           0x84
  24          #define WMIN            0x82
  25          #define WSEG            0x80
  26          #define WDIA_SEMANA     0x8A
  27          /*CMD DE LECTURA DEL RELOJ*/
  28          #define RDIA            0x87
  29          #define RMES            0x89
  30          #define RANO            0x8D
  31          #define RHORA           0x85
  32          #define RMIN            0x83
  33          #define RSEG            0x81
  34          #define RDIA_SEMANA     0x8B
  35          
  36          #define True                    0x01
  37          #define False                   0x00
  38          
  39          enum Dia_Semana{
  40            Domingo=1,Lunes, Martes, Miercoles, Jueves, Viernes, Sabado 
  41          };
  42          
  43          
  44          unsigned char data_clk;
  45          //*********************************************************************************
  46          
  47          //*********************************************************************************
  48          void p_ck (void)
  49          {
  50   1          sck=1;
  51   1          Delay();
  52   1          sck=0;
  53   1      }
  54          //*********************************************************************************
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 2   

  55          void eb_clk(char dir_clk) {
  56   1        int nbits;
  57   1        for (nbits=0; nbits<8; nbits++)
  58   1        {
  59   2          dir_clk >>=1;
  60   2          if (CY==1)
  61   2          { 
  62   3            io=1;
  63   3          }
  64   2          else
  65   2          {
  66   3            io=0;
  67   3          }
  68   2          p_ck();
  69   2        }
  70   1      }
  71          //*********************************************************************************
  72          char lee_clk (unsigned char dir_clk) {            
  73   1      int nbits;
  74   1        rst=1;
  75   1        Delay_20us(3);
  76   1        eb_clk(dir_clk);
  77   1        for (nbits=0; nbits<8; nbits++)
  78   1        {
  79   2          if (io==1) 
  80   2          {
  81   3          data_clk = data_clk | 0x80;
  82   3          if (nbits<=6) {
  83   4           data_clk >>=1;
  84   4           }
  85   3          }
  86   2          if (io==0)
  87   2          {
  88   3            data_clk = data_clk & 0x7F;
  89   3          if (nbits<=6) 
  90   3           {
  91   4            data_clk >>=1;
  92   4           }
  93   3          }
  94   2          p_ck();
  95   2          } 
  96   1        rst=0;
  97   1        return data_clk;
  98   1      }
  99          //*********************************************************************************
 100          void wr_clk (unsigned char dir_clk, unsigned char byte) {            
 101   1        rst=1;
 102   1        Delay_20us(3);
 103   1        eb_clk(dir_clk);
 104   1        dir_clk=byte;
 105   1        eb_clk(dir_clk);
 106   1        rst=0;
 107   1        
 108   1       }
 109          //****************************************************************************
 110           unsigned char two_one (unsigned char byte_h,unsigned char byte_l)
 111          {
 112   1        unsigned char byte_out;
 113   1        byte_h=byte_h&0x0f;
 114   1        byte_h<<=4;
 115   1        byte_l=byte_l&0x0f;
 116   1        byte_out=byte_h|byte_l;
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 3   

 117   1        return byte_out;
 118   1      }
 119          /*------------------------------------------------------------------------------
 120          
 121          ------------------------------------------------------------------------------*/
 122          unsigned char validar_clk(unsigned char *datos_clock)
 123          {
 124   1        unsigned char validador=0;
 125   1        
 126   1        
 127   1          if ((*datos_clock >= '0') &&(*datos_clock <= '9'))                                /*valida el dia parte alta */
 128   1          {
 129   2          
 130   2             if ((*(datos_clock+1) >= '0') &&(*(datos_clock+1) <= '9'))                     /*valida el dia parte baja*/
 131   2            {
 132   3              
 133   3               if ((*(datos_clock+3) >= '0') &&(*(datos_clock+3) <= '9'))             /*valida el mes parte alta*/
 134   3              {
 135   4                if ((*(datos_clock+4) >= '0') &&(*(datos_clock+4) <= '9'))            /*valida el mes parte baja */
 136   4                {
 137   5                 if ((*(datos_clock+8) >= '0') &&(*(datos_clock+8) <= '9'))         /*año baja*/      
 138   5                  {
 139   6                   if ((*(datos_clock+0x0b) >= '0')&&(*(datos_clock+0x0b) <= '9'))          /*hora alta*/ 
 140   6                    {
 141   7                    if ((*(datos_clock+0x0c) >= '0') &&(*(datos_clock+0x0c) <= '9'))          /*hora baja*/ 
 142   7                      {
 143   8                     if ((*(datos_clock+0x0e) >= '0') &&(*(datos_clock+0x0e) <= '9'))       /*minutos alta*/
 144   8                        {
 145   9                      if ((*(datos_clock+0x0f) >= '0') &&(*(datos_clock+0x0f) <= '9'))        /*minutos baja*/
 146   9                        {
 147  10                       if ((*(datos_clock+0x11) >= '0') &&(*(datos_clock+0x11) <= '9'))       /*segundos alta*/
 148  10                            {
 149  11                        if ((*(datos_clock+0x12) >= '0') &&(*(datos_clock+0x12) <= '9'))        /*segundos baja*/
 150  11                          {
 151  12                          if ((*(datos_clock+0x14) >= '0') &&(*(datos_clock+0x14) <= '9'))        /*dia de la semana*/
 152  12                           {
 153  13                                  validador=0;
 154  13                           }
 155  12                              }
 156  11                              else
 157  11                              {
 158  12                                validador =1;
 159  12                              }
 160  11                            }
 161  10                            else
 162  10                            {
 163  11                              validador =1;
 164  11                          
 165  11                            }
 166  10                          }
 167   9                          else
 168   9                          {
 169  10                            validador =1;
 170  10                        
 171  10                          }
 172   9                      
 173   9                        }
 174   8                        else
 175   8                        {
 176   9                          validador =1;
 177   9                        
 178   9                        }
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 4   

 179   8                      }
 180   7                      else
 181   7                      {
 182   8                        validador =1;
 183   8                        //break;
 184   8                      }
 185   7                    }
 186   6                    else
 187   6                    {
 188   7                      validador =1;
 189   7                      
 190   7                    }               
 191   6                  }
 192   5                  else
 193   5                  {
 194   6                    validador =1;
 195   6                    
 196   6                  }
 197   5                }
 198   4                
 199   4              }
 200   3              else
 201   3              {
 202   4                validador =1;
 203   4                
 204   4              }
 205   3            
 206   3            }
 207   2            
 208   2            else
 209   2            {
 210   3              validador =1;
 211   3            
 212   3            }
 213   2          
 214   2          }
 215   1          
 216   1          else 
 217   1          {
 218   2            validador =1;
 219   2            
 220   2          }
 221   1        
 222   1        return validador;
 223   1        
 224   1      }
 225          /*------------------------------------------------------------------------------
 226          Escribo el reloj en ascii en bloque 
 227          
 228          ------------------------------------------------------------------------------*/
 229          
 230          void Block_write_clock_ascii(unsigned char *datos_clock)  
 231          
 232          {     
 233   1        unsigned char temp;
 234   1      //dia,mes,año,hora,minutos,segundos,Dia de la semana 
 235   1          
 236   1            /*dia*/
 237   1            wr_clk(WDIA,two_one(*datos_clock,*(datos_clock+1)));                    //dia
 238   1            datos_clock++;
 239   1            datos_clock++;
 240   1            datos_clock++;
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 5   

 241   1            /*mes*/
 242   1            wr_clk(WMES,two_one(*datos_clock,*(datos_clock+1)));                    //mes
 243   1            datos_clock++;
 244   1            datos_clock++;
 245   1            datos_clock++;
 246   1            datos_clock++;
 247   1            datos_clock++;
 248   1            /*año*/
 249   1            wr_clk(WANO,two_one(*datos_clock,*(datos_clock+1)));                    //año
 250   1            datos_clock++;
 251   1            datos_clock++;
 252   1            datos_clock++;
 253   1            /*hora*/
 254   1            wr_clk(WHORA,two_one(*datos_clock,*(datos_clock+1)));                   //hora
 255   1            datos_clock++;
 256   1            datos_clock++;
 257   1            datos_clock++;
 258   1            /*minutos*/
 259   1            wr_clk(WMIN,two_one(*datos_clock,*(datos_clock+1)));                    //minutos
 260   1            datos_clock++;
 261   1            datos_clock++;
 262   1            datos_clock++;
 263   1            /*segundos*/
 264   1            wr_clk(WSEG,two_one(*datos_clock,*(datos_clock+1)));                    //segundos
 265   1            datos_clock++;
 266   1            datos_clock++;
 267   1            datos_clock++;
 268   1            /*dia de la semana*/
 269   1            temp =*datos_clock & 0x07;
 270   1            wr_clk(WDIA_SEMANA,temp);                               //dia de la semana
 271   1        
 272   1      }
 273          /*------------------------------------------------------------------------------
 274          rutinas de conversiones  de bcd a hex
 275          ------------------------------------------------------------------------------*/
 276          unsigned char bcd_hex (unsigned char l_data)
 277           {
 278   1        unsigned char temp,j;
 279   1        temp=l_data;
 280   1        temp>>=4;
 281   1        temp=temp & 0x0f;
 282   1        if (temp!=0x00)
 283   1        {
 284   2          l_data=l_data & 0x0f;
 285   2          for (j=0;j<temp;j++)
 286   2          {
 287   3              l_data=l_data+0x0a;
 288   3          } 
 289   2        }
 290   1        return l_data;
 291   1       }
 292           /*------------------------------------------------------------------------------
 293           Rutina que convierte de Hex a bcd 
 294          ------------------------------------------------------------------------------*/
 295          unsigned char hex_bcd (unsigned char byte)
 296          {
 297   1        unsigned char nibble_h; 
 298   1        unsigned char nibble_l;
 299   1        unsigned char k,byte_out;
 300   1      
 301   1        nibble_h=0x00;
 302   1        nibble_l=0x00;
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 6   

 303   1      
 304   1        for (k=0;k<byte;k++)
 305   1        {
 306   2          nibble_l=nibble_l+0x01;
 307   2          if (nibble_l==0x0a)
 308   2          {
 309   3            nibble_l=0x00;
 310   3            nibble_h=nibble_h+0x01;
 311   3          }
 312   2         }
 313   1         nibble_h<<=4;
 314   1         nibble_h=nibble_h & 0xf0;
 315   1         nibble_l=nibble_l & 0x0f;
 316   1         byte_out=(nibble_h | nibble_l);
 317   1         return byte_out;
 318   1        
 319   1      }
 320          void hex_ascii(unsigned char * datos,unsigned char * fecha_asii)
 321          {
 322   1        unsigned char dato;
 323   1        //unsigned fecha_asii[7];
 324   1        
 325   1          dato=hex_bcd (*datos);
 326   1          *fecha_asii=((dato&0xf0)>>4)| 0x30;     /*dato parte alta*/
 327   1          *(fecha_asii+1)=(dato&0x0f)| 0x30;            /*dato parte bajo*/
 328   1          datos++;
 329   1        
 330   1          dato=hex_bcd (*(datos));
 331   1            *(fecha_asii+2)=((dato&0xf0)>>4)| 0x30;     /*dato parte alta*/
 332   1            *(fecha_asii+3)=(dato&0x0f)| 0x30;            /*dato parte bajo*/
 333   1          datos++;
 334   1        
 335   1          dato=hex_bcd (*(datos));
 336   1            *(fecha_asii+4)=((dato&0xf0)>>4)| 0x30;     /*dato parte alta*/
 337   1            *(fecha_asii+5)=(dato&0x0f)| 0x30;            /*dato parte bajo*/
 338   1          
 339   1            *(fecha_asii+6)=0;
 340   1        
 341   1      }
 342          /*------------------------------------------------------------------------------
 343            CONVIERTE DE 1BYTE HEXADECIMAL A DECIMAL                      
 344          valorhex= pasa el byte en Hex y lo convierte en decimal
 345          buffer=   se debuelve la conversion en un arreglo en ascii
 346          ------------------------------------------------------------------------------*/
 347          void ByteHex_Decimal(unsigned char *buffer,unsigned char valorhex)
 348          {
 349   1        unsigned char numero, centena, decena;
 350   1      
 351   1        centena=0;
 352   1        decena=0;
 353   1        numero=valorhex;
 354   1      
 355   1        while (numero>=0x064)                           /* resto centena en ascii100*/
 356   1        {
 357   2          numero=numero-0x64;
 358   2          centena=centena+1;
 359   2        }
 360   1          *buffer=centena|0x30;
 361   1          buffer++;
 362   1        while (numero>=0x0a)                            /* resto 10 decena en ascii*/
 363   1        {
 364   2          numero=numero-0x0a;
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 7   

 365   2          decena=decena+1;
 366   2        }
 367   1        *buffer=decena|0x30;
 368   1        buffer++;
 369   1        *buffer=numero|0x30;                            /*unidad en ascii */
 370   1        buffer++;
 371   1        *buffer= 0;
 372   1      
 373   1      }
 374          /*------------------------------------------------------------------------------
 375            CONVIERTE DE 2BYTE HEXADECIMAL A DECIMAL                      
 376          
 377          ------------------------------------------------------------------------------*/
 378          void Two_ByteHex_Decimal(unsigned char *buffer,unsigned char id_h,unsigned char id_l)
 379          {
 380   1        unsigned int valor,numero;
 381   1        unsigned char temp,dmil, mil, centena, decena;
 382   1      
 383   1        valor=0;
 384   1        dmil=0;
 385   1        mil=0;
 386   1        centena=0;
 387   1        decena=0;
 388   1        
 389   1         
 390   1        temp=id_h;
 391   1        temp=temp&0xf0;
 392   1        temp>>=4;
 393   1      
 394   1        valor=valor+(pow(16,3))*temp;
 395   1        temp=id_h;
 396   1        temp=temp&0x0f;
 397   1        valor=valor+(pow(16,2))*temp;
 398   1      
 399   1        temp=id_l;
 400   1        temp=temp&0xf0;
 401   1        temp>>=4;
 402   1        valor=valor+(pow(16,1))*temp;
 403   1        temp=id_l;
 404   1        temp=temp&0x0f;
 405   1        valor=valor+(pow(16,0))*temp;
 406   1        numero=valor;
 407   1      
 408   1        while (numero>=0x2710)        // resto 10.000 
 409   1        {
 410   2          numero=numero-0x2710;
 411   2          dmil=dmil+1;
 412   2        }
 413   1        *buffer=dmil|0x30;
 414   1          buffer++;
 415   1        while (numero>=0x03e8)        // resto 1.000
 416   1        {
 417   2          numero=numero-0x03e8;
 418   2          mil=mil+1;
 419   2        }
 420   1        *buffer=mil|0x30;
 421   1          buffer++;
 422   1        while (numero>=0x064)         // resto 100
 423   1        {
 424   2          numero=numero-0x64;
 425   2          centena=centena+1;
 426   2        }
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 8   

 427   1        *buffer=centena|0x30;
 428   1          buffer++;
 429   1        while (numero>=0x0a)        // resto 10
 430   1        {
 431   2          numero=numero-0x0a;
 432   2          decena=decena+1;
 433   2        }
 434   1        *buffer=decena|0x30;
 435   1        buffer++;
 436   1        *buffer=numero|0x30;
 437   1        buffer++;
 438   1        *buffer=00;
 439   1        
 440   1      }
 441          /*------------------------------------------------------------------------------
 442           Lee el dato del reloj en bloque 
 443          ------------------------------------------------------------------------------*/
 444          void Block_read_clock_ascii(unsigned char *datos_clock)
 445          {
 446   1        unsigned char dato;
 447   1      
 448   1        //dia,mes,año,hora,minutos,segundos,Dia de la semana
 449   1          
 450   1          /*año*/
 451   1          dato=(lee_clk(RANO));
 452   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 453   1          datos_clock++;
 454   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 455   1          datos_clock++;
 456   1        
 457   1        /*mes*/
 458   1          dato=(lee_clk(RMES));
 459   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 460   1          datos_clock++;
 461   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 462   1          datos_clock++;    
 463   1      
 464   1          /*dia*/
 465   1          dato=(lee_clk(RDIA));                       //;bcd_hex(lee_clk(DIA));
 466   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 467   1          datos_clock++;
 468   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 469   1          datos_clock++;
 470   1          
 471   1          
 472   1          /*hora*/            
 473   1          dato=(lee_clk(RHORA));
 474   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 475   1          datos_clock++;
 476   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 477   1          datos_clock++;        
 478   1          
 479   1          /*minutos*/   
 480   1          dato=(lee_clk(RMIN));   
 481   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 482   1          datos_clock++;
 483   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 484   1          datos_clock++;  
 485   1          *datos_clock=0;
 486   1                      
 487   1      } 
 488          void Block_read_clock_ascii_rasberry(unsigned char *datos_clock)
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 9   

 489          {
 490   1        unsigned char dato;
 491   1      
 492   1        //dia,mes,año,hora,minutos,segundos,Dia de la semana
 493   1        /*mes*/
 494   1          dato=(lee_clk(RMES));
 495   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 496   1          datos_clock++;
 497   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 498   1          datos_clock++;    
 499   1      
 500   1          /*dia*/
 501   1          dato=(lee_clk(RDIA));                       //;bcd_hex(lee_clk(DIA));
 502   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 503   1          datos_clock++;
 504   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 505   1          datos_clock++;
 506   1          
 507   1        
 508   1          /*año*/
 509   1          dato=(lee_clk(RANO));
 510   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 511   1          datos_clock++;
 512   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 513   1          datos_clock++;
 514   1        
 515   1        
 516   1          
 517   1          /*hora*/            
 518   1          dato=(lee_clk(RHORA));
 519   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 520   1          datos_clock++;
 521   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 522   1          datos_clock++;        
 523   1          
 524   1          /*minutos*/   
 525   1          dato=(lee_clk(RMIN));   
 526   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 527   1          datos_clock++;
 528   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 529   1          datos_clock++;  
 530   1          *datos_clock='.';
 531   1          datos_clock++;      
 532   1          
 533   1            /*segundos*/    
 534   1          dato=(lee_clk(RSEG));   
 535   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 536   1          datos_clock++;
 537   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 538   1          
 539   1          datos_clock++;  
 540   1          *datos_clock=0;
 541   1                      
 542   1      } 
 543          
 544          void Block_read_Clock_Hex(unsigned char *datos_clock)
 545          {
 546   1        
 547   1        /*año*/
 548   1        *datos_clock=bcd_hex(lee_clk(RANO));      
 549   1         datos_clock++;
 550   1        /*mes*/
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 10  

 551   1        *datos_clock=bcd_hex(lee_clk(RMES));      
 552   1         datos_clock++;
 553   1        /*Dia*/
 554   1        *datos_clock=bcd_hex(lee_clk(RDIA));      
 555   1         datos_clock++;
 556   1        /*hora*/  
 557   1        *datos_clock=bcd_hex(lee_clk(RHORA));     
 558   1         datos_clock++;
 559   1        /*minutos*/ 
 560   1        *datos_clock=bcd_hex(lee_clk(RMIN));      
 561   1         datos_clock++;
 562   1      
 563   1      }
 564          
 565          /*------------------------------------------------------------------------------
 566           Lee el dato del reloj en bloque 
 567          ------------------------------------------------------------------------------*/
 568          void Block_read_Clock(unsigned char *datos_clock)
 569          {
 570   1        /*año*/ 
 571   1        *datos_clock = (char)lee_clk(RANO);     
 572   1         datos_clock++;
 573   1        /*mes*/
 574   1        *datos_clock = (char)lee_clk(RMES);     
 575   1         datos_clock++;
 576   1        /*Dia*/
 577   1        *datos_clock = (char)lee_clk(RDIA);     
 578   1         datos_clock++;
 579   1        /*hora*/  
 580   1        *datos_clock = (char)lee_clk(RHORA);      
 581   1         datos_clock++;
 582   1        /*minutos*/ 
 583   1        *datos_clock = (char)lee_clk(RMIN);     
 584   1         datos_clock++;
 585   1        /*segundos*/  
 586   1        *datos_clock = (char)lee_clk(RSEG);
 587   1        datos_clock++;
 588   1        *datos_clock=00;
 589   1          
 590   1      }
 591          void cond_ini_clock()
 592          {
 593   1        sck=0;          //Reloj
 594   1        rst=0;
 595   1        io=1;
 596   1      }
 597          
 598          /*------------------------------------------------------------------------------
 599          funcion q verifica la fecha maxima de salida 
 600          VERIFICA PAGO (sin_pago)....                                      
 601          SI PAGO, VERIFICA QUE LA FECHA MAX DE SALIDA NO EXCEDE A LA ACTUAL (acceso_ok)              
 602          (0) vencida
 603          (1) ok en rango
 604          
 605          ------------------------------------------------------------------------------*/
 606          char check_fechaOut(char *buffer)
 607          {
 608   1        unsigned long int fecha_inicio,fecha_fin;
 609   1        unsigned char datos_clk[6];
 610   1        char temp;
 611   1        
 612   1        
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 11  

 613   1          Block_read_Clock_Hex(datos_clk);                              /*leo el clock actual*/
 614   1          fecha_inicio =  datos_clk[0] * 365 + datos_clk[1] * 30 + datos_clk[2] ;
 615   1          fecha_fin = *(buffer ) * 365 + *(buffer + 1) * 30  + *(buffer + 2);
 616   1          
 617   1            
 618   1          if (fecha_fin >= fecha_inicio )           
 619   1          {
 620   2            temp = True;
 621   2          }
 622   1          else
 623   1          {
 624   2            temp = False;
 625   2          }
 626   1            
 627   1      
 628   1        
 629   1        return temp;
 630   1      }
 631          
 632          //*******************************************************************************************
 633          /*
 634          void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos)
 635          {
 636          
 637          
 638            int ano_inT;
 639            bit bisiesto=0;
 640          
 641            unsigned char ano_out, mes_out, dia_out, hora_out, min_out;
 642            unsigned char Horas_Dcto, Minutos_Dcto, Xtemp; 
 643          
 644            bit Tiempo_Dcto=0;
 645          
 646          if ((*(buffer+0x0b)==0x00)&&(*(buffer+0x0c)==0x00)&&(*(buffer+0x0d)==0x00)&&(*(buffer+0x0e)==0x00)&&(*(buf
             -fer+0x0f)==0x00))
 647          {
 648          
 649          //--------------------------------------------------------------------------------------------------------
             -------------------------------------
 650          //  Descuento Maximo 999 minutos  = 16 Horas  39 Minutos
 651          //--------------------------------------------------------------------------------------------------------
             -------------------------------------
 652            if (Val_DctoMinutos >= 60 )
 653            {
 654              Horas_Dcto=Val_DctoMinutos/60;
 655              Minutos_Dcto=Val_DctoMinutos-(Horas_Dcto*60);
 656          
 657            }
 658            else
 659            {
 660              Minutos_Dcto=Val_DctoMinutos;
 661              Horas_Dcto=0;
 662            }
 663          //********************************************************************************************************
             -*************************************
 664          //  Aumenta Primero Minutos
 665          //--------------------------------------------------------------------------------------------------------
             --------------------------------------
 666            if (Minutos_Dcto!=0)
 667            {
 668              min_out=*(buffer+4)+Minutos_Dcto;         
 669              if (min_out>59)                   // Si los minutos no sube de 60 no hay que aumentar nada
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 12  

 670              {
 671          //----------------------------------------------------
 672                Xtemp=(int)(min_out/60);          // Numero de Horas a aumentar
 673                min_out=min_out-(Xtemp*60);         // Total de minutos
 674          //----------------------------------------------------
 675                hora_out=*(buffer+3)+Xtemp;         /*horas*/
 676          /*
 677                if (hora_out>23)
 678                {
 679                  Xtemp= hora_out/24;             // Numero Dias a aumentar
 680                  hora_out=hora_out-(Xtemp*24);       // Total de Horas
 681          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 682                  dia_out=*(buffer+2)+Xtemp;
 683                  if ((*(buffer+1)==1)||(*(buffer+1)==3)||(*(buffer+1)==5)||(*(buffer+1)==7)||(*(buffer+1)==8)||(*(buffe
             -r+1)==10)||(*(buffer+1)==12))   // Meses de 31 dias
 684                  {
 685                    if (dia_out>31)
 686                    {
 687                      dia_out=dia_out-31;
 688                      mes_out=*(buffer+1)+1;
 689                      if (mes_out>12)
 690                      {
 691                        ano_out=*(buffer+0)+1;
 692                        mes_out=1;
 693                      }
 694                      else
 695                      {
 696                        ano_out=*(buffer+0);
 697                      }
 698                    }
 699                    else
 700                    {
 701                      mes_out=*(buffer+1);                        /*mes*/
 702            /*          ano_out=*(buffer+0);                        /*año*/
 703            /*        } 
 704                  }
 705                  else if ((*(buffer+1)==4)||(*(buffer+1)==6)||(*(buffer+1)==9)||(*(buffer+1)==11))                   // Meses de
             - 30 dias
 706                  {
 707                    if (dia_out>30)
 708                    {
 709                      dia_out=dia_out-30;
 710                      mes_out=*(buffer+1)+1;
 711                      ano_out=*(buffer+0);          
 712                    }
 713                    else
 714                    {
 715                      mes_out=*(buffer+1);
 716                      ano_out=*(buffer+0);  
 717                    }
 718          
 719                  }
 720                  else if (*(buffer+1)==2)                                        // Febtrero Es biciesto?
 721                  {
 722          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 723                    ano_inT=*(buffer+0)+2000;
 724                    bisiesto=0;
 725          
 726          /*
 727                    float flotante=12.345;
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 13  

 728                    int entero;
 729          
 730                    entero=(int)flotante;
 731          */
 732            
 733          /*          division=(ano_inT/4);
 734                    intpart=division;
 735                    decpart= ano_inT - (intpart*4);
 736                    if (decpart==0)
 737                    {
 738                      division=(ano_inT/10);
 739                        intpart = division;
 740                        decpart = ano_inT - (intpart*10);
 741                      if (decpart==0)
 742                      {
 743                        division=(ano_inT/40);
 744                          intpart = division;
 745                          decpart = ano_inT - (intpart*40);
 746          
 747          
 748                        if (decpart==0)
 749                        {
 750                          bisiesto=1;
 751                        }
 752                        else
 753                        {
 754                          bisiesto=0;
 755                        }
 756                      }
 757                      else
 758                      {
 759                        bisiesto=1;
 760                      }
 761                    }
 762          */
 763          
 764            /*        if ((*(buffer+0)==16)||(*(buffer+0)==20)||(*(buffer+0)==24)||(*(buffer+0)==28)||(*(buffer+0)==32)||
             -(*(buffer+0)==36))
 765                    {
 766                      bisiesto=1;
 767                    }   
 768          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------          
 769                    if (bisiesto==1)
 770                    {
 771                      if (dia_out>29)
 772                      {
 773                        ano_out=*(buffer+0);
 774                        dia_out=dia_out-29;
 775                        mes_out=*(buffer+1)+1;
 776                    
 777                      }
 778                      else
 779                      {
 780                        ano_out=*(buffer+0);  
 781                        dia_out=dia_out;
 782                        mes_out=*(buffer+1);
 783                      }
 784                    }
 785                    else
 786                    {
 787                      if (dia_out>28)
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 14  

 788                      {
 789                        dia_out=dia_out-28;
 790                        mes_out=*(buffer+1)+1;
 791                        ano_out=*(buffer+0);
 792                      }
 793                      else
 794                      {
 795                        dia_out=dia_out;
 796                        mes_out=*(buffer+1);
 797                        ano_out=*(buffer+0);  
 798                      }
 799                    }
 800          //--------------------------------------------------------------------------------------------------------
             --------------------------------------
 801                  }
 802                  else                                                // Error fecha
 803                  {
 804                    dia_out=dia_out;
 805                    mes_out=*(buffer+1);
 806                    ano_out=*(buffer+0);  
 807                  }
 808                }
 809                else
 810                {
 811                  dia_out=*(buffer+2);
 812                  mes_out=*(buffer+1);
 813                  ano_out=*(buffer+0);
 814                }
 815              }
 816              else
 817              {
 818                hora_out=*(buffer+3);
 819                dia_out=*(buffer+2);
 820                mes_out=*(buffer+1);
 821                ano_out=*(buffer+0);
 822              }
 823            }
 824            else
 825            {
 826              min_out=*(buffer+4);
 827              hora_out=*(buffer+3);
 828              dia_out=*(buffer+2);
 829              mes_out=*(buffer+1);
 830              ano_out=*(buffer+0);
 831            }
 832          //********************************************************************************************************
             -*************************************
 833          //  AUMENTA HORAS
 834          //--------------------------------------------------------------------------------------------------------
             --------------------------------------
 835              if (Horas_Dcto!=0)
 836              {
 837                  hora_out=hora_out+Horas_Dcto;
 838                  if (hora_out>23)
 839                  {
 840                    Xtemp= hora_out/24;             // Numero Dias a aumentar
 841                    hora_out=hora_out-(Xtemp*24);       // Total de Horas
 842            //-------------------------------------------------------------------------------------------------------
             ----------------------------------------
 843                    dia_out=dia_out+Xtemp;
 844                    if ((mes_out==1)||(mes_out==3)||(mes_out==5)||(mes_out==7)||(mes_out==8)||(mes_out==10)||(mes_out==12
             -))    // Meses de 31 dias
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 15  

 845                    {
 846                      if (dia_out>31)
 847                      {
 848                        dia_out=dia_out-31;
 849                        mes_out=mes_out+1;
 850                        if (mes_out>12)
 851                        {
 852                          ano_out=ano_out+1;
 853                          mes_out=1;
 854                        }
 855                        else
 856                        {
 857                          ano_out=ano_out;
 858                        }
 859                      }
 860                    }
 861                    else if ((mes_out==4)||(mes_out==6)||(mes_out==9)||(mes_out==11))                   // Meses de 30 dias
 862                    {
 863                      if (dia_out>30)
 864                      {
 865                        dia_out=dia_out-30;
 866                        mes_out=mes_out+1;
 867                        ano_out=ano_out;          
 868                      }
 869                      else
 870                      {
 871                        mes_out=mes_out;
 872                        ano_out=ano_out;  
 873                      }
 874                    }
 875                    else if (mes_out==2)                                        // Febtrero Es biciesto?
 876                    {
 877          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 878                      ano_inT=ano_out+2000;
 879                      bisiesto=0;
 880          
 881          
 882          /*            division=(ano_inT/4);
 883                      intpart = division;
 884                      decpart= ano_inT - (intpart*4);
 885            
 886            
 887                      if (decpart==0)
 888                      {
 889                        division=(ano_inT/10);
 890                          intpart = division;
 891                          decpart = ano_inT - (intpart*10);
 892                        if (decpart==0)
 893                        {
 894                          division=(ano_inT/40);
 895                            intpart = division;
 896                            decpart = ano_inT - (intpart*40);
 897                          if (decpart==0)
 898                          {
 899                            bisiesto=1;
 900                          }
 901                          else
 902                          {
 903                            bisiesto=0;
 904                          }
 905                        }
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 16  

 906                        else
 907                        {
 908                          bisiesto=1;
 909                        }
 910                      }
 911          */
 912            /*          if ((ano_out==16)||(ano_out==20)||(ano_out==24)||(ano_out==28)||(ano_out==32)||(ano_out==36))
 913                      {
 914                        bisiesto=1;
 915                      }   
 916          
 917          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------          
 918                      if (bisiesto==1)
 919                      {
 920                        if (dia_out>29)
 921                        {
 922                          dia_out=dia_out-29;
 923                          mes_out=mes_out+1;
 924                          ano_out=ano_out;            
 925                        }
 926                        else
 927                        {
 928                          dia_out=dia_out;
 929                          mes_out=mes_out;
 930                          ano_out=ano_out;
 931                        }
 932                      }
 933                      else
 934                      {
 935                        if (dia_out>28)
 936                        {
 937                          dia_out=dia_out-28;
 938                          mes_out=mes_out+1;
 939                          ano_out=ano_out;                          
 940                        }
 941                      }
 942            //-------------------------------------------------------------------------------------------------------
             ----------------------------------------
 943                    }
 944            
 945                  }
 946              }
 947          
 948          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 949            *(buffer+0x0b)=ano_out;
 950            *(buffer+0x0c)=mes_out;
 951            *(buffer+0x0d)=dia_out;
 952            *(buffer+0x0e)=hora_out;
 953            *(buffer+0x0f)=min_out;   
 954          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 955            }
 956            
 957          
 958          }
 959          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3191    ----
C51 COMPILER V9.59.0.0   CLOCK                                                             05/02/2021 15:24:48 PAGE 17  

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      60
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
