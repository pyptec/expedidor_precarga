C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE PROG
OBJECT MODULE PLACED IN .\Objects\prog.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE prog.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\prog.lst) TABS(2) OBJECT(.\Objects\prog.obj)

line level    source

   1          
   2          #include "prog.h" 
   3          #include <string.h>
   4          extern int printf   (const char *, ...);
   5          extern char putchar (char);
   6          extern char getchar (void);
   7          extern char  *strtok  (char *str, const char *set);
   8          extern char   strcmp  (const char *s1, const char *s2);
   9          extern char  *strcpy  (char *s1, const char *s2);
  10          extern char _getkey (void);
  11          extern char  *strcat  (char *s1, const char *s2);
  12          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  13          extern void wr_eeprom (unsigned char control,unsigned int Dir, unsigned char data_eeprom);
  14          extern int sprintf  (char *, const char *, ...);
  15          extern int    atoi (const char *s1);
  16          extern unsigned long int  Read_EEprom_Ticket();
  17          extern void LeerMemoria(unsigned int addres, unsigned char *res);
  18          extern void EscribirMemoria(unsigned int addres,unsigned char *res);
  19          extern int   rand ();
  20          extern void Block_read_clock_ascii(unsigned char *datos_clock);
  21          extern char check_fechaOut(char *buffer);
  22          extern void ByteHex_Decimal(unsigned char *buffer,unsigned char valorhex);
  23          extern unsigned char hex_bcd (unsigned char byte);
  24          extern void hex_ascii(unsigned char * datos,unsigned char * fecha_asii);
  25          
  26          unsigned char cursor[20] = "/"; //current working directory
  27          unsigned char validacion [11]={"admin"};  //usuario
  28          
  29          
  30          
  31          
  32          
  33          /*define posiciones de memoria*/
  34          #define EE_ID_CLIENTE           0x0000
  35          #define EE_ID_PARK              0x0002
  36          #define EE_TIEMPO_GRACIA        0x0004
  37          #define EE_SIN_COBRO            0x0006
  38          #define EE_DEBUG                0x0008
  39          #define EE_USE_LPR              0x000A
  40          #define EE_TIPO_PANTALLA        0X000E
  41          #define EE_CARD_AUTOMATIC_BOTON 0x000f
  42          #define EE_HABILITA_APB         0x0010
  43          #define EE_PLACA                0X0011
  44          #define EE_ADDRESS_HIGH_BOARD   0X0012
  45          #define EE_JUST_ONE_TIME_CLAVE  0X0013
  46          #define EE_VALIDA_TIPO_VEHICULO_MENSUAL 0X0014
  47          #define EE_HABILITA_APB_MENSUAL 0X0015
  48          #define EE_HORARIO_1            0X0019
  49          #define EE_HORARIO_2            0x0032
  50          #define EE_HORARIO_3            0x004b
  51          #define EE_HORARIO_4            0x0064
  52          #define EE_HORARIO_5            0x007d
  53          #define EE_HORARIO_6            0x0096
  54          #define EE_HORARIO_7            0x00af
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 2   

  55          #define EE_HORARIO_8            0x00c8
  56          #define EE_HORARIO_9            0x00e1
  57          #define EE_HORARIO_10           0x00fa
  58          #define EE_TICKET_ID            0X0200
  59          #define EE_ID_REGISTER          0x0300
  60          #define EE_FECHA_VENCIMIENTO    0X0350
  61          /* Definicion del tamaño de comando y longitud de cmd*/
  62          
  63          #define   NUMCOMMAND 17
  64          #define   LONGSIZE 3
  65          
  66          #define True                    0x01
  67          #define False                   0x00
  68          
  69          
  70          
  71          enum ee_horario_addr{
  72            ee_horario1_addr, ee_horario2_addr, ee_horario3_addr, ee_horario4_addr, ee_horario5_addr,
  73            ee_horario6_addr, ee_horario7_addr, ee_horario8_addr, ee_horario9_addr, ee_horario10_addr,
  74            ee_horarioNULL_addr
  75          };
  76          
  77          
  78          enum Dia_Semana_addr{
  79            Lunes_addr = 1, Martes_addr = 2, Miercoles_addr = 3, Jueves_addr =4, Viernes_addr = 5, 
  80            Sabado_addr = 6, Domingo_addr =0 
  81          };
  82          enum Dia_Semana_data{
  83            Domingo_dato=0x31, Lunes_dato=0x32, Martes_dato=0x33, Miercoles_dato=0x34, Jueves_dato=0x35, Viernes_dato
             -=0x36, Sabado_dato=0x37  
  84          };
  85          enum Hora_Minutos_addr{
  86            Hora_High_addr_Desde = 7, Hora_Low_addr_Desde = 8, Minutos_High_addr_Desde = 9, Minutos_Low_addr_Desde = 
             -10,
  87            Hora_High_addr_Hasta = 11, Hora_Low_addr_Hasta = 12, Minutos_High_addr_Hasta = 13, Minutos_Low_addr_Hasta
             - = 14,
  88            Habilita_addr =15, Segundo_Tiempo=16
  89          };
  90          enum Hora_Minutos_data{
  91              Hora_High_data = 0, Hora_Low_data = 1, Minutos_High_data = 3, Minutos_Low_data =4
  92          };
  93          char comandos[NUMCOMMAND][LONGSIZE]=
  94          {
  95            "0",          //ID_CLIENTEValor del punto cero.
  96            "1",       //COD_PARKTiempo de recolecion entre muestra
  97            "2",    // T_GRACIAInformacion recolectada enviada al rs232
  98            "3",    //SIN_COBROAjuste del cero del sensor
  99            "4",  //DEBUG Calibracion por la curva de la pendiente
 100            "5",    //USE_LPR
 101            "6",      //TIPO_PANTALLA
 102            "7",        // tarjeta automatica o boton
 103            "8",      //habilita apb o inhabilta
 104            "9",      //placa
 105            "10",     // direccion logico
 106            "11",     // prog horario
 107            "12",     // Validar tipo de vehiculo mensual
 108            "13",     // habilita apb para mensual
 109            "14",     //AYUDA Ayuda!muestra todos los comandos
 110            "15",   //SALIRSalir de programacion
 111            "16"      //cmd escondido fecha de vencimiento password
 112          };
 113          
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 3   

 114          /*------------------------------------------------------------------------------
 115          Rutina que encripta la clave q se le envie
 116          len_clave= longitud de la clave a encriptar
 117          aleatorio=numero aleatoria para escoger el dato a sumar y para la or
 118          
 119          ------------------------------------------------------------------------------*/
 120          unsigned char *hash_id(unsigned char *clave)
 121          {
 122   1        unsigned char len_clave,i;
 123   1        static unsigned int temp, temp1;
 124   1        unsigned char aleatorio []={":[<%?XT]=)" };
 125   1        //unsigned char aleatorio2 []={"@#!\`Fb^&*" };
 126   1        unsigned char suma []={"#*YJAIMEcamiltK"};/*caracteres q se le suman a la trama */
 127   1        unsigned char xxor []={"wrz25q68-91fS.@" };
 128   1        unsigned char usuario1[11];
 129   1        unsigned char vencimiento_password [4];
 130   1        
 131   1        LeerMemoria(EE_FECHA_VENCIMIENTO,vencimiento_password); 
 132   1        if (check_fechaOut(vencimiento_password) != True)
 133   1          
 134   1        {
 135   2          strcpy(aleatorio,"@#!\`Fb^&*");
 136   2        }
 137   1        else
 138   1        {
 139   2          strcpy(aleatorio, ":[<%?XT]=)");
 140   2        }
 141   1        len_clave=strlen(clave);                      /*longitud de la clave a encriptar*/
 142   1          for (i=0; i<len_clave;i++)
 143   1          {
 144   2            temp=*(clave+i)+aleatorio[i];               /*el primer caracter de la clave se le suma con el primero de los 
             -aleatorios*/
 145   2            temp1=temp & 15;                            /*al  resultado se le hace una and con (0x0f)*/
 146   2            if (temp1==0)temp1++; 
 147   2            temp=*(clave+i) + suma[temp1-1];            /*se suma la clave  con el arreglo suma y el valor del arreglo bi
             -ene de  aleatorio el resultado q da en temp */
 148   2            temp1=temp & 15;
 149   2            if (temp1==0)temp1++;
 150   2            temp=temp ^ xxor[temp1-1];                  /*temp se le hace uan xor aleatoria*/
 151   2            if (temp > 255)
 152   2            {
 153   3              temp=temp & 255;
 154   3            }     
 155   2            if ((temp >=122)&&(temp<=255))
 156   2            {
 157   3            temp=temp & 122;
 158   3          
 159   3            }
 160   2            if (temp < 48)
 161   2            {
 162   3            temp=temp+64;
 163   3            }
 164   2            if ((temp>=91)&&(temp<=96))
 165   2            {
 166   3            temp=temp +7 ;
 167   3            }
 168   2            if ((temp>=58)&&(temp<=64))
 169   2            {
 170   3            temp=temp - 7 ;
 171   3            }
 172   2            usuario1[i]=temp;
 173   2          
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 4   

 174   2          }
 175   1          usuario1[i]=0;
 176   1        
 177   1        return usuario1;
 178   1      }
 179          
 180          
 181          /*------------------------------------------------------------------------------
 182          Rutina de lista de comandos 
 183          ------------------------------------------------------------------------------*/
 184          
 185          unsigned char ListaComandos(unsigned char *cmd)
 186          {
 187   1         unsigned char buf[LONGSIZE];
 188   1         unsigned char i;
 189   1         
 190   1         for (i=0; i<NUMCOMMAND; i++)
 191   1         {
 192   2            strcpy(buf, &comandos[i][0]);
 193   2            if (strcmp(buf, cmd)==0)
 194   2               return(i);
 195   2         }
 196   1         
 197   1         return(0xFF);
 198   1      }
 199          
 200          
 201          /*------------------------------------------------------------------------------
 202          Rutina que valida la clave
 203          ------------------------------------------------------------------------------*/
 204          unsigned char  ValidarClave(unsigned char *buffer)
 205          {
 206   1      unsigned char buf [11];
 207   1        
 208   1            strcpy(buf, &validacion[0]);
 209   1            if (strcmp(buf, buffer)==0)
 210   1               return(0);
 211   1       
 212   1         
 213   1         return(0xFF);
 214   1      }
 215          
 216          
 217          
 218          /*------------------------------------------------------------------------------
 219          Rutina que busca el \
 220          ------------------------------------------------------------------------------*/
 221          unsigned char * GetCMD(unsigned char *in)
 222          {
 223   1         char tokens[]=" \r\n";
 224   1         return(strtok(in,tokens));
 225   1      }
 226          
 227          /*------------------------------------------------------------------------------
 228          Rutina de 
 229          ------------------------------------------------------------------------------*/
 230          unsigned char * GetOption(unsigned char *in)
 231          {
 232   1         unsigned char tokensSpace[]=" \r\n";
 233   1         unsigned char tokensQuote[]="\"\r\n";
 234   1         
 235   1         //trim leading spaces
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 5   

 236   1         while (*in==' ')
 237   1            in++;
 238   1         
 239   1         //if first char is a quote, then end token on a quote.  ELSE end token on a space
 240   1         if (*in == '\"')
 241   1            return(strtok(in,tokensQuote));
 242   1         else
 243   1            return(strtok(in,tokensSpace));
 244   1      } 
 245          /*------------------------------------------------------------------------------
 246          Rutina de muestra el cursor
 247          ------------------------------------------------------------------------------*/
 248          
 249          void DisplayCursor(void)
 250          {
 251   1         printf("\r\n\n%s> ", cursor);
 252   1      }
 253          
 254          /*------------------------------------------------------------------------------
 255          Rutina que captura los datos pto serie y los muestra en el pto
 256          ------------------------------------------------------------------------------*/
 257          
 258          void IngresaDato(unsigned char  *buffer, unsigned char modo)
 259          {
 260   1      
 261   1       int i;
 262   1       
 263   1        do
 264   1        { 
 265   2          *buffer = _getkey();
 266   2        if (modo == 0) 
 267   2          {
 268   3             printf("%c", *buffer);
 269   3          }
 270   2          else 
 271   2          {
 272   3            putchar('*');
 273   3          }
 274   2           i=*buffer; 
 275   2           buffer++;
 276   2          *buffer='\0'; 
 277   2          
 278   2        } while(i != '\r');
 279   1          
 280   1            
 281   1               
 282   1      } 
 283          /*
 284          void LeerMemoria(unsigned int  addres,unsigned char  *res)
 285          {
 286          unsigned char i;
 287            do {
 288              *res=rd_eeprom(0xa8,addres);
 289              i=*res;
 290              addres++;
 291              res++;
 292              }while(i !='\0');
 293              *res='\0';
 294          }
 295          */
 296          /*------------------------------------------------------------------------------
 297          Rutina que programa el id_cliente en eeprom
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 6   

 298          ------------------------------------------------------------------------------*/
 299          void prog_id_cliente()
 300          {
 301   1        unsigned char buffer[10];
 302   1        unsigned int dataee;
 303   1        
 304   1        dataee=rd_eeprom(0xa8,EE_ID_CLIENTE);                                         /*se lee el id_cliente actual */
 305   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 306   1        
 307   1        printf("\r\n\n ACTUAL ID_CLIENTE=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual en pan
             -talla*/
 308   1        
 309   1        printf("\r\n\n DIGITE SU NUEVO ID_CLIENTE=");                                 /*digite el nuevo id_cliente*/
 310   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 311   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 312   1        wr_eeprom(0xa8,EE_ID_CLIENTE,dataee);                                         /*grabo el dato en la eeprom*/
 313   1        
 314   1        dataee=rd_eeprom(0xa8,EE_ID_CLIENTE);                                         /*leo el dato grabado*/
 315   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 316   1        printf("\r\n\n DATO MODIFICADO ID_CLIENTE=%s\r\n\n",buffer);                  /*lo muetro por la pantalla el dato 
             -grabado*/
 317   1      }
 318          /*------------------------------------------------------------------------------
 319          Rutina que programa el cod_park
 320          ------------------------------------------------------------------------------*/
 321          void prog_cod_park()
 322          {
 323   1        unsigned char buffer[10];
 324   1        unsigned int dataee;
 325   1        
 326   1        dataee=rd_eeprom(0xa8,EE_ID_PARK);                                          /*se lee el id_cliente actual */
 327   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 328   1        
 329   1        printf("\r\n\n ACTUAL COD_PARK=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual en panta
             -lla*/
 330   1        
 331   1        printf("\r\n\n DIGITE SU NUEVO COD_PARK=");                                 /*digite el nuevo id_cliente*/
 332   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 333   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 334   1        wr_eeprom(0xa8,EE_ID_PARK,dataee);                                          /*grabo el dato en la eeprom*/
 335   1        
 336   1        dataee=rd_eeprom(0xa8,EE_ID_PARK);                                          /*leo el dato grabado*/
 337   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 338   1        printf("\r\n\n DATO MODIFICADO COD_PARK=%s\r\n\n",buffer);                  /*lo muetro por la pantalla el dato gr
             -abado*/
 339   1      }
 340          /*------------------------------------------------------------------------------
 341          Rutina que programa el tiempo de gracia de cobro (00) no tiene tiempo de gracia
 342          ------------------------------------------------------------------------------*/
 343          void Prog_tiempo_gracia()
 344          {
 345   1        unsigned char buffer[10];
 346   1        unsigned int dataee;
 347   1        
 348   1        dataee=rd_eeprom(0xa8,EE_TIEMPO_GRACIA);                                          /*se lee el id_cliente actual */
 349   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 350   1        
 351   1        printf("\r\n\n ACTUAL TIEMPO_GRACIA=%s\r\n\n",buffer);                            /*se muestra el id_cliente actual en 
             -pantalla*/
 352   1        
 353   1        printf("\r\n\n DIGITE SU NUEVO TIEMPO_GRACIA=");                                  /*digite el nuevo id_cliente*/
 354   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 7   

 355   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 356   1        wr_eeprom(0xa8,EE_TIEMPO_GRACIA,dataee);                                          /*grabo el dato en la eeprom*/
 357   1        
 358   1        dataee=rd_eeprom(0xa8,EE_TIEMPO_GRACIA);                                        /*leo el dato grabado*/
 359   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 360   1        printf("\r\n\n DATO MODIFICADO TIEMPO_GRACIA=%s\r\n\n",buffer);               /*lo muetro por la pantalla el dat
             -o grabado*/
 361   1      }
 362          /*------------------------------------------------------------------------------
 363          Rutina que programa SIN COBRO
 364          SIN_COBRO=0 inhabilitado, SIN_COBRO=1 sin cobro, SIN_COBRO=2 sin cobro y salida el mismo dia");
 365          ------------------------------------------------------------------------------*/
 366          void Prog_Sin_Cobro()
 367          {
 368   1        
 369   1      
 370   1        unsigned char buffer[10];
 371   1        unsigned int dataee;
 372   1      
 373   1        dataee=rd_eeprom(0xa8,EE_SIN_COBRO);                                          /*se lee el id_cliente actual */
 374   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 375   1        if(dataee==0)
 376   1        {
 377   2          printf("\r\n\n ACTUAL SIN_COBRO INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente 
             -actual en pantalla*/
 378   2        }
 379   1        else if (dataee==1)
 380   1        {
 381   2          printf("\r\n\n ACTUAL SIN_COBRO GRATIS=%s\r\n\n",buffer);   
 382   2        }
 383   1        else 
 384   1        {
 385   2            printf("\r\n\n ACTUAL SIN_COBRO GRATIS Y SALIDA EL MISMO DIA=%s\r\n\n",buffer);   
 386   2        }
 387   1        
 388   1        printf("\r\n\n DIGITE SU NUEVO SIN_COBRO=");                                  /*digite el nuevo id_cliente*/
 389   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 390   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 391   1        wr_eeprom(0xa8,EE_SIN_COBRO,dataee);                                          /*grabo el dato en la eeprom*/
 392   1        
 393   1        dataee=rd_eeprom(0xa8,EE_SIN_COBRO);                                        /*leo el dato grabado*/
 394   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 395   1        if(dataee==0)
 396   1        {
 397   2          printf("\r\n\n ACTUAL SIN_COBRO INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente 
             -actual en pantalla*/
 398   2        }
 399   1        else if (dataee==1)
 400   1        {
 401   2          printf("\r\n\n ACTUAL SIN_COBRO GRATIS=%s\r\n\n",buffer);   
 402   2        }
 403   1        else 
 404   1        {
 405   2            printf("\r\n\n ACTUAL SIN_COBRO GRATIS Y SALIDA EL MISMO DIA=%s\r\n\n",buffer);   
 406   2        }
 407   1        
 408   1      }
 409          /*------------------------------------------------------------------------------------
 410          Rutina que habilita el debuger
 411           Habilita = 1 ; 
 412          inahabilita = 0;
 413          --------------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 8   

 414          void Prog_debug()
 415          {
 416   1        unsigned char buffer[10];
 417   1        unsigned int dataee;
 418   1      
 419   1        
 420   1        dataee=rd_eeprom(0xa8,EE_DEBUG);                                          /*se lee el id_cliente actual */
 421   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 422   1        if(dataee==0)
 423   1        {
 424   2          printf("\r\n\n ACTUAL DEBUG INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 425   2        }
 426   1        else
 427   1        {
 428   2          printf("\r\n\n ACTUAL DEBUG HABILITADO=%s\r\n\n",buffer);     
 429   2        }
 430   1        
 431   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE DEBUG=");                                  /*digite el nuevo id_cliente*/
 432   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 433   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 434   1        wr_eeprom(0xa8,EE_DEBUG,dataee);                                          /*grabo el dato en la eeprom*/
 435   1        
 436   1        dataee=rd_eeprom(0xa8,EE_DEBUG);                                        /*leo el dato grabado*/
 437   1        sprintf(buffer,"%d",dataee);  
 438   1        if(dataee==0)
 439   1        {
 440   2          printf("\r\n\n ACTUAL DEBUG INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 441   2        }
 442   1        else
 443   1        {
 444   2          printf("\r\n\n ACTUAL DEBUG HABILITADO=%s\r\n\n",buffer);     
 445   2        }
 446   1      }
 447          /*------------------------------------------------------------------------------------
 448          
 449          --------------------------------------------------------------------------------------*/
 450          
 451          void Prog_Use_Lpr()
 452          {
 453   1          unsigned char buffer[10];
 454   1        unsigned int dataee;
 455   1      
 456   1        
 457   1        dataee=rd_eeprom(0xa8,EE_USE_LPR);                                          /*se lee el id_cliente actual */
 458   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 459   1        if(dataee==0)
 460   1        {
 461   2          printf("\r\n\n ACTUAL USE_LPR INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente ac
             -tual en pantalla*/
 462   2        }
 463   1        else
 464   1        {
 465   2          printf("\r\n\n ACTUAL USE_LPR HABILITADO=%s\r\n\n",buffer);     
 466   2        }
 467   1        
 468   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE USE_LPR=");                                  /*digite el nuevo id_cliente*/
 469   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 470   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 471   1        wr_eeprom(0xa8,EE_USE_LPR,dataee);                                          /*grabo el dato en la eeprom*/
 472   1        
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 9   

 473   1        dataee=rd_eeprom(0xa8,EE_USE_LPR);                                        /*leo el dato grabado*/
 474   1        sprintf(buffer,"%d",dataee);  
 475   1        if(dataee==0)
 476   1        {
 477   2          printf("\r\n\n ACTUAL USE_LPR INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente ac
             -tual en pantalla*/
 478   2        }
 479   1        else
 480   1        {
 481   2          printf("\r\n\n ACTUAL USE_LPR HABILITADO=%s\r\n\n",buffer);     
 482   2        }
 483   1      }
 484          
 485          /*------------------------------------------------------------------------------------
 486          cmd del tipo de pantalla a usar
 487          Rasberry = 1
 488          lcd = 0
 489          --------------------------------------------------------------------------------------*/
 490          void tipo_pantalla()
 491          {
 492   1        unsigned char buffer[10];
 493   1        unsigned int dataee;
 494   1      
 495   1        
 496   1        dataee=rd_eeprom(0xa8,EE_TIPO_PANTALLA);                                          /*se lee el id_cliente actual */
 497   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 498   1        if(dataee==0)
 499   1        {
 500   2          printf("\r\n\n PANTALLA LCD HABILITADA=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual
             - en pantalla*/
 501   2        }
 502   1        else
 503   1        {
 504   2          printf("\r\n\n PANTALLA RASPBERRY  HABILITADA=%s\r\n\n",buffer);      
 505   2        }
 506   1        
 507   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE LA PANTALLA =");                                 /*digite el nuevo id_cliente*/
 508   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 509   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 510   1        wr_eeprom(0xa8,EE_TIPO_PANTALLA,dataee);                                          /*grabo el dato en la eeprom*/
 511   1        
 512   1        dataee=rd_eeprom(0xa8,EE_TIPO_PANTALLA);                                        /*leo el dato grabado*/
 513   1        sprintf(buffer,"%d",dataee);  
 514   1        if(dataee==0)
 515   1        {
 516   2          printf("\r\n\n PANTALLA LCD HABILITADA=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual
             - en pantalla*/
 517   2        }
 518   1        else
 519   1        {
 520   2          printf("\r\n\n ACTUAL COMPARACION ACTIVA  HABILITADA=%s\r\n\n",buffer);     
 521   2        }
 522   1        
 523   1      }
 524          void Prog_tarjeta_automatica_o_boton()
 525          {
 526   1        unsigned char buffer[10];
 527   1        unsigned int dataee;
 528   1      
 529   1        
 530   1        dataee=rd_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON);                               //se lee LA CONFIGURACION 
 531   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 10  

 532   1        if(dataee==0)
 533   1        {
 534   2          printf("\r\n\n EXPIDE TARJETA PULSANDO BOTON\r\n\n");                           /*se muestra el id_cliente actual en 
             -pantalla*/
 535   2        }
 536   1        else
 537   1        {
 538   2          printf("\r\n\n EXPIDE TARJETA AUTOMATICA\r\n\n");     
 539   2        }
 540   1        
 541   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DEL EXPEDIDOR=");                                 /*digite el nuevo id_cliente*/
 542   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 543   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 544   1        wr_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON,dataee);                                         /*grabo el dato en la eeprom*/
 545   1        
 546   1        dataee=rd_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON);                                       /*leo el dato grabado*/
 547   1        sprintf(buffer,"%d",dataee);  
 548   1        if(dataee==0)
 549   1        {
 550   2          printf("\r\n\n EXPIDE TARJETA PULSANDO BOTON\r\n\n");                           /*se muestra el id_cliente actual en 
             -pantalla*/
 551   2        }
 552   1        else
 553   1        {
 554   2          printf("\r\n\n EXPIDE TARJETA AUTOMATICA\r\n\n");     
 555   2        }
 556   1      }
 557          void Prog_AntiPassBack()
 558          {
 559   1        unsigned char buffer[10];
 560   1        unsigned int dataee;
 561   1      
 562   1        
 563   1        dataee=rd_eeprom(0xa8,EE_HABILITA_APB);                                         /*se lee el id_cliente actual */
 564   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 565   1        if(dataee==0)
 566   1        {
 567   2          printf("\r\n\n ACTUAL ANTIPASSBACK INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el id_clien
             -te actual en pantalla*/
 568   2        }
 569   1        else
 570   1        {
 571   2          printf("\r\n\n ACTUAL ANTIPASSBACK HABILITADO=%s\r\n\n",buffer);      
 572   2        }
 573   1        
 574   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE ANTIPASSBACK=");                                 /*digite el nuevo id_cliente*/
 575   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 576   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 577   1        wr_eeprom(0xa8,EE_HABILITA_APB,dataee);                                         /*grabo el dato en la eeprom*/
 578   1        
 579   1        dataee=rd_eeprom(0xa8,EE_HABILITA_APB);                                       /*leo el dato grabado*/
 580   1        sprintf(buffer,"%d",dataee);  
 581   1        if(dataee==0)
 582   1        {
 583   2          printf("\r\n\n ACTUAL ANTIPASSBACK INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el id_clien
             -te actual en pantalla*/
 584   2        }
 585   1        else
 586   1        {
 587   2          printf("\r\n\n ACTUAL ANTIPASSBACK HABILITADO=%s\r\n\n",buffer);      
 588   2        }
 589   1      }
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 11  

 590          void Prog_Placa()
 591          {
 592   1        unsigned char buffer[10];
 593   1        unsigned int dataee;
 594   1      
 595   1        
 596   1        dataee=rd_eeprom(0xa8,EE_PLACA);                                          /*se lee el id_cliente actual */
 597   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 598   1        if(dataee==0)
 599   1        {
 600   2          printf("\r\n\n ACTUAL PLACA INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 601   2        }
 602   1        else
 603   1        {
 604   2          printf("\r\n\n ACTUAL PLACA HABILITADO=%s\r\n\n",buffer);     
 605   2        }
 606   1        
 607   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE PLACA=");                                  /*digite el nuevo id_cliente*/
 608   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 609   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 610   1        wr_eeprom(0xa8,EE_PLACA,dataee);                                          /*grabo el dato en la eeprom*/
 611   1        
 612   1        dataee=rd_eeprom(0xa8,EE_PLACA);                                        /*leo el dato grabado*/
 613   1        sprintf(buffer,"%d",dataee);  
 614   1        if(dataee==0)
 615   1        {
 616   2          printf("\r\n\n ACTUAL PLACA INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 617   2        }
 618   1        else
 619   1        {
 620   2          printf("\r\n\n ACTUAL PLACA HABILITADO=%s\r\n\n",buffer);     
 621   2        }
 622   1      }
 623          void Prog_Address_High_Board()
 624          {
 625   1        unsigned char buffer[10];
 626   1        unsigned int dataee;
 627   1      
 628   1        
 629   1        dataee=rd_eeprom(0xa8,EE_ADDRESS_HIGH_BOARD);                                         /*se lee el id_cliente actual */
 630   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 631   1        if(dataee==0)
 632   1        {
 633   2          printf("\r\n\n ACTUAL ADDRESS_HIGH_BOARD=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 634   2        }
 635   1        else
 636   1        {
 637   2          printf("\r\n\n ACTUAL ADDRESS_HIGH_BOARD=%s\r\n\n",buffer);     
 638   2        }
 639   1        
 640   1        printf("\r\n\n DIGITE LA NUEVA ADDRESS_HIGH_BOARD=");                                 /*digite el nuevo id_cliente*/
 641   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 642   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 643   1        wr_eeprom(0xa8,EE_ADDRESS_HIGH_BOARD,dataee);                                         /*grabo el dato en la eeprom*/
 644   1        
 645   1        dataee=rd_eeprom(0xa8,EE_ADDRESS_HIGH_BOARD);                                       /*leo el dato grabado*/
 646   1        sprintf(buffer,"%d",dataee);  
 647   1        if(dataee==0)
 648   1        {
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 12  

 649   2          printf("\r\n\n ACTUAL ADDRESS_HIGH_BOARD=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 650   2        }
 651   1        else
 652   1        {
 653   2          printf("\r\n\n ACTUAL ADDRESS_HIGH_BOARD=%s\r\n\n",buffer);     
 654   2        }
 655   1      }
 656          
 657          unsigned char *Addr_Horarios()
 658          {
 659   1        unsigned char ee_addr_horario[11];
 660   1          /*direcciones de memoria de almacenamiento*/
 661   1        ee_addr_horario[ee_horario1_addr]= EE_HORARIO_1;
 662   1        ee_addr_horario[ee_horario2_addr]= EE_HORARIO_2;
 663   1        ee_addr_horario[ee_horario3_addr]= EE_HORARIO_3;
 664   1        ee_addr_horario[ee_horario4_addr]= EE_HORARIO_4;
 665   1        ee_addr_horario[ee_horario5_addr]= EE_HORARIO_5;
 666   1        ee_addr_horario[ee_horario6_addr]= EE_HORARIO_6;
 667   1        ee_addr_horario[ee_horario7_addr]= EE_HORARIO_7;
 668   1        ee_addr_horario[ee_horario8_addr]= EE_HORARIO_8;
 669   1        ee_addr_horario[ee_horario9_addr]= EE_HORARIO_9;
 670   1        ee_addr_horario[ee_horario10_addr]= EE_HORARIO_10;
 671   1        ee_addr_horario[ee_horarioNULL_addr] = False;
 672   1        return ee_addr_horario;
 673   1      }
 674          unsigned char Prog_Horarios_on_off(unsigned int addr)
 675          {
 676   1        unsigned char buffer[10];
 677   1        unsigned int dataee,habilitado;
 678   1        dataee = rd_eeprom(0xa8,addr);                                          /*se lee el id_cliente actual */
 679   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 680   1        if(dataee==0)
 681   1        {
 682   2          printf("\r\n\n ACTUAL HORARIO INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente ac
             -tual en pantalla*/
 683   2        }
 684   1        else
 685   1        {
 686   2          printf("\r\n\n ACTUAL HORARIO HABILITADO=%s\r\n\n",buffer);     
 687   2        }
 688   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE HORARIO=");                                  /*digite el nuevo id_cliente*/
 689   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 690   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 691   1        wr_eeprom(0xa8,addr,dataee);                                          /*grabo el dato en la eeprom*/
 692   1        
 693   1        dataee=rd_eeprom(0xa8,addr);                                        /*leo el dato grabado*/
 694   1        sprintf(buffer,"%d",dataee);  
 695   1        if(dataee==0)
 696   1        {
 697   2          habilitado= False;
 698   2          printf("\r\n\n ACTUAL HORARIO INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente ac
             -tual en pantalla*/
 699   2        }
 700   1        else
 701   1        {
 702   2          habilitado=True;
 703   2          printf("\r\n\n ACTUAL HORARIO HABILITADO=%s\r\n\n",buffer);     
 704   2        }
 705   1        return habilitado;
 706   1      }
 707          void Prog_Horario_Desde_Hasta(unsigned int addr)
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 13  

 708          {
 709   1          unsigned char buffer[10];
 710   1          unsigned char dataee;
 711   1        /*la hora de inicio del horario*/
 712   1        
 713   1        printf("\r\n\n Digite Hora 08:00 Minutos Desde: ");
 714   1        IngresaDato(buffer,0);
 715   1        printf("\r\n\n Hora Programada Desde: ");
 716   1        wr_eeprom(0xa8, addr + Hora_High_addr_Desde,buffer[Hora_High_data]);
 717   1        dataee = rd_eeprom(0xa8,addr + Hora_High_addr_Desde);
 718   1        printf("%c",dataee);
 719   1        wr_eeprom(0xa8,addr + Hora_Low_addr_Desde ,buffer[Hora_Low_data]);
 720   1        dataee = rd_eeprom(0xa8,addr + Hora_Low_addr_Desde); //
 721   1        printf("%c:",dataee);
 722   1        wr_eeprom(0xa8,addr + Minutos_High_addr_Desde,buffer[Minutos_High_data]);
 723   1        dataee = rd_eeprom(0xa8,addr + Minutos_High_addr_Desde);
 724   1        printf("%c",dataee);
 725   1        wr_eeprom(0xa8,addr + Minutos_Low_addr_Desde,buffer[Minutos_Low_data]);
 726   1        dataee = rd_eeprom(0xa8,addr +  Minutos_Low_addr_Desde);
 727   1        printf("%c",dataee);
 728   1      
 729   1      /*la hora de final del horario*/
 730   1      
 731   1        printf("\r\n\n Digite Hora:Minutos Hasta: ");
 732   1        IngresaDato(buffer,0);
 733   1        
 734   1        printf("\r\n\n Hora Programada Hasta: ");
 735   1      
 736   1        wr_eeprom(0xa8,addr + Hora_High_addr_Hasta,buffer[Hora_High_data]);
 737   1        dataee = rd_eeprom(0xa8,addr + Hora_High_addr_Hasta);
 738   1        printf("%c",dataee);
 739   1        wr_eeprom(0xa8,addr + Hora_Low_addr_Hasta ,buffer[Hora_Low_data]);
 740   1        dataee = rd_eeprom(0xa8,addr + Hora_Low_addr_Hasta);
 741   1        printf("%c:",dataee);
 742   1        wr_eeprom(0xa8,addr + Minutos_High_addr_Hasta,buffer[Minutos_High_data]);
 743   1        dataee = rd_eeprom(0xa8,addr + Minutos_High_addr_Hasta);
 744   1        printf("%c",dataee);
 745   1        wr_eeprom(0xa8,addr + Minutos_Low_addr_Hasta ,buffer[Minutos_Low_data]);
 746   1        dataee = rd_eeprom(0xa8,addr + Minutos_Low_addr_Hasta);
 747   1        printf("%c",dataee);
 748   1      }
 749          void Prog_Horario_dias(unsigned int addr)
 750          {
 751   1        unsigned char buffer[10];
 752   1        unsigned char dataee, j, temp;
 753   1        /*los dias programados*/
 754   1        printf("\r\n\n Digite los dias a programar Lunes = 2, ");
 755   1        printf("Martes = 3, Miercoles = 4, Jueves = 5, ");
 756   1        printf("Viernes = 6, Sabado = 7, Domingo = 1 : ");
 757   1        IngresaDato(buffer,0);
 758   1        
 759   1        
 760   1        printf("\r\n\n Dias Programados : ");
 761   1        
 762   1        for(j=0; j < 8 ; j++)
 763   1        {
 764   2          
 765   2          if ((temp=buffer[j]) == Lunes_dato) 
 766   2          {
 767   3            printf(" Lunes");
 768   3          
 769   3            wr_eeprom(0xa8,addr+Lunes_addr,Lunes_dato); 
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 14  

 770   3            dataee=rd_eeprom(0xa8,addr+Lunes_addr); 
 771   3            printf("= %c,",dataee);
 772   3          }
 773   2          
 774   2          if ((temp=buffer[j]) == Martes_dato)
 775   2          {
 776   3            printf(" Martes");
 777   3            wr_eeprom(0xa8,addr+Martes_addr,Martes_dato);
 778   3            dataee=rd_eeprom(0xa8,addr+Martes_addr);  
 779   3            printf("= %c,",dataee);
 780   3          }
 781   2        
 782   2          if ((temp=buffer[j])== Miercoles_dato)
 783   2          {
 784   3            printf(" Miercoles");
 785   3            wr_eeprom(0xa8,addr+Miercoles_addr,Miercoles_dato);
 786   3            dataee=rd_eeprom(0xa8,addr+Miercoles_addr); 
 787   3            printf("= %c,",dataee);
 788   3          }
 789   2          
 790   2          if ((temp=buffer[j]) == Jueves_dato)
 791   2          {
 792   3            printf(" Jueves");
 793   3            wr_eeprom(0xa8,addr+Jueves_addr,Jueves_dato);
 794   3            dataee=rd_eeprom(0xa8,addr+Jueves_addr);  
 795   3            printf("= %c,",dataee);
 796   3          }
 797   2          
 798   2          if ((temp=buffer[j]) == Viernes_dato)
 799   2          { 
 800   3            printf(" Viernes");
 801   3            wr_eeprom(0xa8,addr+Viernes_addr,Viernes_dato);
 802   3            dataee=rd_eeprom(0xa8,addr+Viernes_addr); 
 803   3            printf("= %c,",dataee);
 804   3          }
 805   2          
 806   2          if ((temp=buffer[j]) == Sabado_dato) 
 807   2          {
 808   3            printf(" Sabado");
 809   3            wr_eeprom(0xa8,addr+Sabado_addr,Sabado_dato);
 810   3            dataee=rd_eeprom(0xa8,addr+Sabado_addr);  
 811   3            printf("= %c,",dataee);
 812   3          }
 813   2          
 814   2          if ((temp=buffer[j]) == Domingo_dato)
 815   2          {
 816   3            printf(" Domingo");
 817   3            wr_eeprom(0xa8,addr+Domingo_addr,Domingo_dato);
 818   3            dataee = rd_eeprom(0xa8,addr+Domingo_addr); 
 819   3            printf("= %c",dataee);
 820   3          }
 821   2        }
 822   1        
 823   1      }
 824          void Prog_Horarios()
 825          {
 826   1        unsigned char buffer[10];
 827   1        unsigned char ee_addr_horario[11];
 828   1        unsigned int addr,temp;
 829   1        unsigned char dataee;
 830   1        unsigned char j;
 831   1        
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 15  

 832   1        /*direcciones de memoria de almacenamiento*/
 833   1        
 834   1          strcpy (ee_addr_horario,(Addr_Horarios()));
 835   1          
 836   1        /*se programa el banco de horarios del 1 al 10*/
 837   1        
 838   1        printf("\r\n\n Digite el numero del Horario a programar = ");   
 839   1        IngresaDato(buffer,0);  
 840   1        
 841   1        j=(atoi(buffer)) - 1;
 842   1        
 843   1        /*mi direccion eeprom*/
 844   1        
 845   1        addr= ee_addr_horario[j];
 846   1        temp= addr;
 847   1        
 848   1        /*habilita o desabilita el uso del horario*/
 849   1        
 850   1        addr =addr + Habilita_addr ;
 851   1        if (Prog_Horarios_on_off(addr) == True);
 852   1        {
 853   2          /*limpiar la memoria*/
 854   2        addr= temp;
 855   2          for(j=Lunes_addr; j < 8 ; j++)
 856   2          {
 857   3            wr_eeprom(0xa8,addr+j,0xff);
 858   3          }
 859   2        
 860   2        addr= temp;
 861   2        /*los dias programados*/
 862   2        
 863   2        Prog_Horario_dias(addr);
 864   2          
 865   2        /*la hora de inicio del horario*/
 866   2        
 867   2        Prog_Horario_Desde_Hasta(addr);
 868   2        
 869   2        /*programo si hay segundo horario*/
 870   2        printf("\r\n\n Programar segundo Horario si=(1) no=(0)= ");   
 871   2        IngresaDato(buffer,0);
 872   2        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 873   2        wr_eeprom(0xa8,addr+Segundo_Tiempo,dataee);                                         /*grabo el dato en la eeprom*/
 874   2        
 875   2        dataee=rd_eeprom(0xa8,addr+Segundo_Tiempo);                                       /*leo el dato grabado*/
 876   2        sprintf(buffer,"%d",dataee);  
 877   2          if(dataee==True)
 878   2          {
 879   3            /*la hora de inicio del segundo horario*/
 880   3            addr =addr + Minutos_Low_addr_Desde ;
 881   3            Prog_Horario_Desde_Hasta(addr);
 882   3          }
 883   2        }
 884   1        
 885   1      }
 886          void Prog_Validar_Tipo_Vehiculo_Mensual() 
 887          {
 888   1        unsigned char buffer[10];
 889   1        unsigned int dataee;
 890   1      
 891   1        
 892   1        dataee=rd_eeprom(0xa8,EE_VALIDA_TIPO_VEHICULO_MENSUAL);                                         /*se lee el id_cliente actual
             - */
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 16  

 893   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 894   1        if(dataee==0)
 895   1        {
 896   2          printf("\r\n\n ACTUAL TIPO_VEHICULO MENSUAL INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el
             - id_cliente actual en pantalla*/
 897   2        }
 898   1        else
 899   1        {
 900   2          printf("\r\n\n ACTUAL TIPO_VEHICULO MENSUAL HABILITADO=%s\r\n\n",buffer);     
 901   2        }
 902   1        
 903   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE TIPO_VEHICULO MENSUAL=");                                  /*digite el nuevo id_c
             -liente*/
 904   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 905   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 906   1        wr_eeprom(0xa8,EE_VALIDA_TIPO_VEHICULO_MENSUAL,dataee);                                         /*grabo el dato en la eeprom*
             -/
 907   1        
 908   1        dataee=rd_eeprom(0xa8,EE_VALIDA_TIPO_VEHICULO_MENSUAL);                                       /*leo el dato grabado*/
 909   1        sprintf(buffer,"%d",dataee);  
 910   1        if(dataee==0)
 911   1        {
 912   2          printf("\r\n\n ACTUAL TIPO_VEHICULO MENSUAL INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el
             - id_cliente actual en pantalla*/
 913   2        }
 914   1        else
 915   1        {
 916   2          printf("\r\n\n ACTUAL TIPO_VEHICULO  MENSUAL HABILITADO=%s\r\n\n",buffer);      
 917   2        }
 918   1      }
 919          void Prog_Apb_Mensual()
 920          {
 921   1        unsigned char buffer[10];
 922   1        unsigned int dataee;
 923   1      
 924   1        
 925   1        dataee=rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL);                                         /*se lee el id_cliente actual */
 926   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 927   1        if(dataee==0)
 928   1        {
 929   2          printf("\r\n\n ACTUAL ANTIPASSBACK MENSUAL INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el 
             -id_cliente actual en pantalla*/
 930   2        }
 931   1        else
 932   1        {
 933   2          printf("\r\n\n ACTUAL ANTIPASSBACK MENSUAL HABILITADO=%s\r\n\n",buffer);      
 934   2        }
 935   1        
 936   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE ANTIPASSBACK MENSUAL=");                                 /*digite el nuevo id_cl
             -iente*/
 937   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 938   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 939   1        wr_eeprom(0xa8,EE_HABILITA_APB_MENSUAL,dataee);                                         /*grabo el dato en la eeprom*/
 940   1        
 941   1        dataee=rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL);                                       /*leo el dato grabado*/
 942   1        sprintf(buffer,"%d",dataee);  
 943   1        if(dataee==0)
 944   1        {
 945   2          printf("\r\n\n ACTUAL ANTIPASSBACK MENSUAL INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el 
             -id_cliente actual en pantalla*/
 946   2        }
 947   1        else
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 17  

 948   1        {
 949   2          printf("\r\n\n ACTUAL ANTIPASSBACK  MENSUAL HABILITADO=%s\r\n\n",buffer);     
 950   2        }
 951   1      }
 952          
 953          void Prog_fecha_vencimiento()
 954          {
 955   1        unsigned char buffer[11];
 956   1        unsigned char *cmd;
 957   1        
 958   1        unsigned char fecha[7];
 959   1        unsigned int dataee;
 960   1      
 961   1        LeerMemoria(EE_FECHA_VENCIMIENTO,buffer);   
 962   1           hex_ascii(buffer,fecha);
 963   1                                    
 964   1        
 965   1        printf("\r\n\n ACTUAL FECHA VENCIMIENTO PASSWORD:%s\r\n\n",fecha);                            /*se muestra el id_client
             -e actual en pantalla*/
 966   1          
 967   1         do{
 968   2        printf("\r\n\n/>Id Registro:");
 969   2        LeerMemoria(EE_ID_REGISTER,buffer);
 970   2        printf("%s", buffer);
 971   2        strcpy (validacion,hash_id(buffer));
 972   2        printf("\r\n\n/>Password:");
 973   2        
 974   2          /*para pruebas*/
 975   2        //printf("\r\n\%s ", validacion);
 976   2          
 977   2        IngresaDato(buffer,1);          //ingreso el password por teclado 
 978   2        cmd = GetCMD(buffer);         //quita el carri return 
 979   2        EscribirMemoria(EE_ID_REGISTER,validacion);
 980   2      
 981   2        }while(ValidarClave(cmd)!=0);
 982   1        
 983   1        
 984   1        printf("\r\n\n DIGITE LA NUEVA FECHA DE VENCIMIENTO=");                                 /*digite el nuevo id_cliente*/
 985   1        IngresaDato(buffer,0);  
 986   1        printf("\r\n\n %s\r\n\n",buffer); 
 987   1        
 988   1          fecha[0]=buffer[0]; 
 989   1          fecha[1]=buffer[1]; 
 990   1          fecha[2]=0; 
 991   1          
 992   1          dataee=atoi(fecha);
 993   1          printf("\r\n\n %X",dataee); 
 994   1        /*lo convierto a un dato hex*/
 995   1         wr_eeprom(0xa8,EE_FECHA_VENCIMIENTO,dataee);                                         /*grabo el dato en la eeprom*/
 996   1          fecha[0]=buffer[2]; 
 997   1          fecha[1]=buffer[3]; 
 998   1          fecha[2]=0; 
 999   1          dataee=atoi(fecha);
1000   1          printf("\r\n\n %X",dataee); 
1001   1          wr_eeprom(0xa8,EE_FECHA_VENCIMIENTO+1,dataee);
1002   1          fecha[0]=buffer[4]; 
1003   1          fecha[1]=buffer[5]; 
1004   1          fecha[2]=0; 
1005   1          dataee=atoi(fecha); 
1006   1          printf("\r\n\n %X",dataee);     
1007   1          wr_eeprom(0xa8,EE_FECHA_VENCIMIENTO+2,dataee);
1008   1          wr_eeprom(0xa8,EE_FECHA_VENCIMIENTO+3,0);
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 18  

1009   1          
1010   1          LeerMemoria(EE_FECHA_VENCIMIENTO,buffer);
1011   1          
1012   1          hex_ascii(buffer,fecha);  
1013   1          printf("\r\n\n ACTUAL FECHA DE VENCIMIENTO PROGRAMADA =%s\r\n\n",fecha);  
1014   1        
1015   1      }
1016          /*------------------------------------------------------------------------------
1017          Rutina que muestra la lista de comandos
1018          ------------------------------------------------------------------------------*/
1019          void Show()
1020          {
1021   1         printf("\r\n ID_CLIENTE         --- CMD 0 Identificador del cliente maximo 255");
1022   1         printf("\r\n COD_PARK           --- CMD 1 El numero del parqueadero maximo 255");
1023   1         printf("\r\n T_GRACIA           --- CMD 2 Tiempo sin cobro 00,  maximo 255");
1024   1         printf("\r\n SIN_COBRO          --- CMD 3 Inhabilitado= 0, Gratis= 1 , Gratis y salida el mismo dia= 2"
             -);
1025   1         printf("\r\n DEBUG              --- CMD 4 Habilitar = 1, Inhabilitar = 0");
1026   1         printf("\r\n USE_LPR            --- CMD 5 Habilitar = 1, Inhabilitar = 0");
1027   1         printf("\r\n TIPO_PANTALLA      --- CMD 6 PANTALLA LCD =0 PANTALLA RASPBERRI=1");
1028   1         printf("\r\n CARD_AUTOMATICA    --- CMD 7 BOTTON=0 AUTOMATICA=1");
1029   1         printf("\r\n ANTIPASSBACK       --- CMD 8 Habilitar = 1, Inhabilitar = 0");
1030   1         printf("\r\n PLACA              --- CMD 9 Habilitar = 1, Inhabilitar = 0");
1031   1         printf("\r\n ADDRESS_HIGH_BOARD --- CMD 10 La direccion alta del board del numero 5 al 9 sino se usa deb
             -e ir en 0");
1032   1         printf("\r\n HORARIO            --- CMD 11 Progama 10 horarios del 1 al 10");
1033   1         printf("\r\n VALIDA_VEHI_MENSUAL--- CMD 12 Habilitar = 1, Inhabilitar = 0");
1034   1         printf("\r\n USE_APB_MENSUAL    --- CMD 13 Habilitar = 1, Inhabilitar = 0");
1035   1         printf("\r\n AYUDA              --- CMD 14 Muestra los comandos");
1036   1         printf("\r\n SALIR              --- CMD 15 Salir de programacion");
1037   1      
1038   1      }
1039          
1040          /*------------------------------------------------------------------------------
1041          Rutina de principal de programacion
1042          ------------------------------------------------------------------------------*/
1043          void  First_Clave()
1044          {
1045   1        unsigned char clave[11];
1046   1        
1047   1        
1048   1          Block_read_clock_ascii(clave);
1049   1          clave[10] = 0;
1050   1          strcpy (validacion,hash_id(clave));
1051   1          EscribirMemoria(EE_ID_REGISTER,validacion);
1052   1          validacion[0]=0x14;
1053   1          validacion[0]=0x08;
1054   1          validacion[0]=0x14;
1055   1          validacion[0]=0;
1056   1          
1057   1          EscribirMemoria(EE_FECHA_VENCIMIENTO,validacion);
1058   1        
1059   1        
1060   1      }
1061          void menu(void)
1062          {
1063   1      
1064   1      unsigned char *cmd,*option1,*option2;
1065   1      unsigned char opt_buffer[40];
1066   1      unsigned char buffer[20];
1067   1      
1068   1      
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 19  

1069   1      
1070   1        
1071   1        printf("\r\n\nSistema de Programacion Expedidor \r\n\r\n");
1072   1      
1073   1      
1074   1        
1075   1        
1076   1        if(rd_eeprom(0xa8,EE_JUST_ONE_TIME_CLAVE) != False) 
1077   1        {
1078   2          First_Clave();  
1079   2          wr_eeprom(0xa8,EE_JUST_ONE_TIME_CLAVE,0x0);
1080   2          //printf("%s", buffer);
1081   2        
1082   2        }
1083   1       
1084   1        do{
1085   2        printf("\r\n\n/>Id Registro:");
1086   2        LeerMemoria(EE_ID_REGISTER,buffer);
1087   2        printf("%s", buffer);
1088   2        strcpy (validacion,hash_id(buffer));
1089   2        printf("\r\n\n/>Password:");
1090   2        
1091   2          /*para pruebas*/
1092   2        printf("\r\n\%s ", validacion);
1093   2          
1094   2        IngresaDato(buffer,1);          //ingreso el password por teclado 
1095   2        cmd = GetCMD(buffer);         //quita el carri return 
1096   2        EscribirMemoria(EE_ID_REGISTER,validacion);
1097   2      
1098   2        }while(ValidarClave(cmd)!=0);       //
1099   1      
1100   1        //EscribirMemoria(EE_ID_REGISTER,validacion);
1101   1        
1102   1        Show();
1103   1        while(1)
1104   1        {
1105   2        DisplayCursor();
1106   2      
1107   2      
1108   2          IngresaDato(buffer,0);  
1109   2          cmd = GetCMD(buffer); 
1110   2          option1 = GetOption(cmd + strlen(cmd) + 1);
1111   2          option2 = GetOption(option1 + strlen(option1) + 1);  
1112   2      
1113   2         //si empieza con un '/', eso significa que incluye el caminoa
1114   2            //al archivo.  si el archivo no empieza con un '/', debe agregarce 
1115   2            //la ruta del archivo.
1116   2            if (option1 && (option1[0]=='/'))
1117   2            {
1118   3               //option1 is a full path
1119   3               strcpy(opt_buffer, option1);
1120   3            }
1121   2            else if (option1)
1122   2            {
1123   3               // tack on the current working directory to option1
1124   3               strcpy(opt_buffer, cursor);
1125   3               strcat(opt_buffer, option1);
1126   3            }         
1127   2      
1128   2      
1129   2      
1130   2      
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 20  

1131   2      
1132   2          if (cmd)
1133   2            {
1134   3               switch(ListaComandos(cmd))
1135   3               {
1136   4                  case 0:                     /*Se programa la identificacion del cliente*/
1137   4                    prog_id_cliente();
1138   4                  
1139   4                   break;
1140   4                  
1141   4                  case 1:  //Tiempo de recolecion entre muestra
1142   4                    prog_cod_park();
1143   4                  break;
1144   4                  case 2:  //Informacion recolectada enviada al rs232
1145   4                    Prog_tiempo_gracia();
1146   4                  break;
1147   4                  case 3:  //Ajuste del cero del sensor
1148   4                    Prog_Sin_Cobro();
1149   4                  break;
1150   4                  case 4:  //Ajuste de calibracion por medio de la pendiente
1151   4                    Prog_debug();
1152   4                  break;
1153   4                  case 5:  //help me
1154   4                    Prog_Use_Lpr();
1155   4                     break;
1156   4                  case 6:     //tipo de pantalla
1157   4                    tipo_pantalla();
1158   4                  break;
1159   4                  case 7:     //tarjeta automatica o pulsador
1160   4                    Prog_tarjeta_automatica_o_boton();
1161   4                  break;
1162   4                  case 8:  //cmd antipassback
1163   4                    Prog_AntiPassBack();
1164   4                  break;
1165   4                  case 9:   //cmd placa
1166   4                    Prog_Placa();
1167   4                  break;
1168   4                  case 10:    //cmd configuracion de la direccion del board
1169   4                    Prog_Address_High_Board();
1170   4                  break;
1171   4                  case 11:    //cmd configuracion los horarios
1172   4                    Prog_Horarios();
1173   4                  break;
1174   4                  case 12:    //cmd configuracion los horarios
1175   4                    Prog_Validar_Tipo_Vehiculo_Mensual();
1176   4                  break;
1177   4                  case 13:    //cmd configuracion los horarios
1178   4                    Prog_Apb_Mensual();
1179   4                  break;
1180   4                  case 14:  //help me
1181   4                    Show();
1182   4                  break;
1183   4                  case 15:  //salir
1184   4                    return;
1185   4                  break;
1186   4                  case 16:
1187   4                    Prog_fecha_vencimiento();
1188   4                    break;
1189   4          
1190   4                
1191   4                  default:
1192   4                     printf("\r\nComando no existe '%s'", cmd);
C51 COMPILER V9.59.0.0   PROG                                                              07/14/2020 08:20:39 PAGE 21  

1193   4                     break;
1194   4              }
1195   3            }
1196   2        }
1197   1      }
1198          
1199            
1200          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7245    ----
   CONSTANT SIZE    =   3658    ----
   XDATA SIZE       =     86     446
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
