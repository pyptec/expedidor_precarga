C51 COMPILER V9.59.0.0   EEPROM                                                            08/26/2021 15:40:14 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE EEPROM
OBJECT MODULE PLACED IN .\Objects\eeprom.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE eeprom.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\eeprom.lst) TABS(2) OBJECT(.\Objects\eeprom.obj)

line level    source

   1          
   2          #include <eeprom.h>
   3          #include <reg51.h>
   4          #include <string.h>
   5          
   6          /*funciones externas*/
   7          extern void          _nop_     (void);
   8          extern void Delay (void);
   9          extern void Delay_20us(unsigned int cnt);
  10          extern void Delay_1ms(unsigned int cnt);
  11          extern long   atol (const char *s1);
  12          extern void Debug_txt_Tibbo(unsigned char * str);
  13          extern int sprintf  (char *, const char *, ...);
  14          extern void Debug_chr_Tibbo(unsigned char Dat);
  15          void Formato_eeprom();
  16          
  17          //******************************************************************************************
  18          //    RUTINAS DE EEPROM 24FC1025
  19          //******************************************************************************************
  20          sbit sda = P1^2;
  21          sbit scl = P1^3;
  22          //******************************************************************************************
  23          
  24          bit memory_flag;
  25          unsigned char byte_rd;
  26          unsigned char l_data_eeprom;
  27          unsigned char l_chr;
  28          
  29          /*define posiciones de memoria*/
  30          #define EE_ID_CLIENTE   0x0000
  31          
  32          #define EE_TICKET_ID          0X0200
  33          #define EE_FECHA_VENCIMIENTO    0X0350
  34          #define EE_BAUDIO               0X0800
  35          
  36          
  37          //*******************************************************************************************
  38          void ackd(void)
  39          {
  40   1        unsigned int i;
  41   1        memory_flag=1;
  42   1        scl=1;
  43   1        sda=1;
  44   1        for (i=0; i<1100; i++)             //500
  45   1        {
  46   2          if (sda==0)
  47   2          {
  48   3            memory_flag=0;
  49   3          scl=0;
  50   3      
  51   3          break;
  52   3          }
  53   2        }
  54   1        
C51 COMPILER V9.59.0.0   EEPROM                                                            08/26/2021 15:40:14 PAGE 2   

  55   1        if (memory_flag==1)
  56   1        { 
  57   2      
  58   2        }  
  59   1      } 
  60          //*******************************************************************************************
  61          //*******************************************************************************************
  62          void ack_lect(void)
  63          {
  64   1        int i;
  65   1        scl=1;
  66   1        sda=1;
  67   1        memory_flag=1;
  68   1        for (i=0; i<650; i++)
  69   1        {
  70   2          if (sda==0)
  71   2          {
  72   3            memory_flag=0;
  73   3          scl=0;
  74   3          break;
  75   3          }
  76   2        }
  77   1      } 
  78          //*******************************************************************************************
  79          void p_me (void)
  80          {
  81   1          scl=1;
  82   1          _nop_();
  83   1          scl=0;
  84   1      }
  85          //*******************************************************************************************
  86          void e_d_m (unsigned char a_serial_eeprom)
  87          {
  88   1        unsigned char nbits;
  89   1          for (nbits=0; nbits<8; nbits++)
  90   1        {
  91   2          a_serial_eeprom <<=1;
  92   2          if (CY==1)
  93   2          { 
  94   3            sda=1;
  95   3          }
  96   2          else
  97   2          {
  98   3            sda=0;
  99   3          }
 100   2          scl=1;
 101   2          p_me();         
 102   2        }
 103   1        return;
 104   1      }
 105          //********************************************************************************************
 106          void start (void)
 107          {
 108   1        sda=1;
 109   1        scl=1;
 110   1        _nop_();
 111   1        sda=0;
 112   1        scl=0;
 113   1        return;
 114   1      }
 115          //*******************************************************************************************
 116          void stop (void)
C51 COMPILER V9.59.0.0   EEPROM                                                            08/26/2021 15:40:14 PAGE 3   

 117          {
 118   1        scl=0;
 119   1        sda=0;
 120   1        _nop_();
 121   1        scl=1;
 122   1        sda=1;
 123   1        return;
 124   1      }
 125          //*******************************************************************************************
 126          unsigned char l_d_m (void)
 127          {
 128   1        unsigned char nbits;
 129   1          for (nbits=0; nbits<8; nbits++)
 130   1        {
 131   2          scl=0;
 132   2            if (sda==1) 
 133   2            {
 134   3            l_data_eeprom = l_data_eeprom| 0x01;
 135   3            if (nbits<=6) 
 136   3            {
 137   4              l_data_eeprom<<=1;
 138   4              scl=1;
 139   4            }
 140   3            }
 141   2            if (sda==0)
 142   2            {
 143   3              l_data_eeprom = l_data_eeprom & 0xFE;
 144   3            if (nbits<=6) 
 145   3            {
 146   4                l_data_eeprom <<=1;
 147   4              scl=1;
 148   4            }
 149   3            }
 150   2          }
 151   1        scl=0;
 152   1        return l_data_eeprom;
 153   1      }
 154          //*******************************************************************************************
 155          //*******************************************************************************************
 156          //  ESCRIBE EN EEPROM                                   *
 157          //*******************************************************************************************
 158          //void wr_eeprom (unsigned char control,unsigned char dir_h,unsigned char dir_l,unsigned char data_eeprom)
 159          void wr_eeprom (unsigned char control,unsigned int Dir, unsigned char data_eeprom)
 160          {
 161   1        unsigned char dir_h, dir_l;
 162   1        dir_l=Dir;
 163   1        Dir>>=8;
 164   1        dir_h=Dir;
 165   1      
 166   1      
 167   1        scl=0;
 168   1        sda=0;
 169   1      //  wait();
 170   1          start();
 171   1        e_d_m(control);
 172   1        ackd();
 173   1        e_d_m(dir_h);
 174   1        ackd();
 175   1        e_d_m(dir_l);
 176   1        ackd();
 177   1        e_d_m(data_eeprom);
 178   1        ackd();
C51 COMPILER V9.59.0.0   EEPROM                                                            08/26/2021 15:40:14 PAGE 4   

 179   1        stop();
 180   1        Delay_1ms(13);
 181   1        
 182   1        scl=1;
 183   1        sda=1;
 184   1        Delay_20us(98);                   /*wait long*/
 185   1        Delay_20us(98);
 186   1      }
 187          //*******************************************************************************************
 188          //  ESCRIBE EN EEPROM                                   *
 189          //*******************************************************************************************
 190          /*
 191          void wrpage_eeprom (unsigned char control,unsigned char dir_h,unsigned char dir_l,unsigned char data_eepro
             -m)  
 192          {
 193            unsigned int j;
 194            scl=0;
 195            sda=0;
 196            wait();
 197          
 198            wait();
 199          
 200              start();
 201            e_d_m(control);
 202            ack();
 203            e_d_m(dir_h);
 204            ack();
 205            e_d_m(dir_l);
 206            ack();
 207            for (j=0; j<=127; j++)
 208            {
 209              e_d_m(data_eeprom);
 210              ack();
 211            }
 212            stop();
 213            Delay_1ms(13);
 214            scl=1;
 215            sda=1;
 216           return;
 217          }                                              */
 218          //******************************************************************************************* 
 219          //******************************************************************************************* 
 220          //  LEE EN EEPROM                                     *
 221          //*******************************************************************************************
 222          //unsigned char rd_eeprom (unsigned char control,unsigned char dir_h,unsigned char dir_l) 
 223          unsigned char rd_eeprom (unsigned char control,unsigned int Dir) 
 224          {
 225   1      
 226   1        unsigned char dir_h, dir_l;
 227   1        dir_l=Dir;
 228   1        Dir>>=8;
 229   1        dir_h=Dir;
 230   1      
 231   1        scl=0;
 232   1        sda=0;
 233   1       // wait();
 234   1        start();
 235   1        e_d_m(control);
 236   1        ack_lect();
 237   1        e_d_m(dir_h);
 238   1          ack_lect();
 239   1        e_d_m(dir_l);
C51 COMPILER V9.59.0.0   EEPROM                                                            08/26/2021 15:40:14 PAGE 5   

 240   1        ack_lect();
 241   1        start();
 242   1        e_d_m(control+0x01);
 243   1        ackd();
 244   1        scl=0;
 245   1        l_d_m();
 246   1        stop();
 247   1          scl=1;
 248   1        sda=1;
 249   1        return l_data_eeprom;
 250   1      }
 251          /*----------------------------------------------------------------------------------
 252          Funcion q recibe el numero de ticket en un arreglo
 253          error=1 valida los 10 digitos del ticket y si no es numerico los escribe en cero
 254          j= proposito general
 255          Noticket= variable de 32 bits tiene el numero del ticket
 256          -----------------------------------------------------------------------------------*/
 257          void graba_serie(unsigned char *buffer)
 258          {
 259   1        
 260   1        unsigned char  j;
 261   1        unsigned char error=0;
 262   1        
 263   1        
 264   1      /*valido q los datos recibidos sean numericos*/
 265   1        
 266   1        *(buffer+10)=0;
 267   1        
 268   1        for (j=0; j<=9; j++)
 269   1        {
 270   2          if  ((*(buffer+j)<0x30)||(*(buffer+j)>0x39))
 271   2          {
 272   3            error=1;
 273   3            
 274   3            Debug_txt_Tibbo((unsigned char *) "Error de ticket");
 275   3            Debug_txt_Tibbo((unsigned char *) buffer);
 276   3            Debug_txt_Tibbo((unsigned char *) "\n\r");
 277   3          }
 278   2        
 279   2        }
 280   1        
 281   1        
 282   1        /* son numericos*/
 283   1          if (error==0)
 284   1          {
 285   2            Write_EEprom_Ticket(buffer);
 286   2              
 287   2          }
 288   1          else
 289   1          {
 290   2            wr_eeprom(0xa8,EE_TICKET_ID,00);
 291   2            wr_eeprom(0xa8,EE_TICKET_ID+1,00);
 292   2            wr_eeprom(0xa8,EE_TICKET_ID+2,00);
 293   2            wr_eeprom(0xa8,EE_TICKET_ID+3,00);  
 294   2            
 295   2          }
 296   1      }
 297          void Write_EEprom_Ticket(unsigned char *buffer)
 298          {
 299   1        unsigned char  cod_3,cod_2,cod_1,cod_0;
 300   1        unsigned long int Noticket,Bnoticket=0;
 301   1        Debug_txt_Tibbo((unsigned char *) "Numero de ticket:");
C51 COMPILER V9.59.0.0   EEPROM                                                            08/26/2021 15:40:14 PAGE 6   

 302   1        Debug_txt_Tibbo((unsigned char *) buffer);
 303   1        Debug_txt_Tibbo((unsigned char *) "\n\r");
 304   1        Noticket= atol(buffer);
 305   1          
 306   1        Debug_txt_Tibbo((unsigned char *) "No de ticket HEX:");
 307   1        Bnoticket=Noticket>>24;
 308   1        cod_3=Bnoticket;
 309   1        Debug_chr_Tibbo(cod_3);
 310   1          
 311   1        Bnoticket=Noticket >>16;
 312   1        cod_2=Bnoticket;
 313   1        Debug_chr_Tibbo(cod_2);
 314   1            
 315   1        Bnoticket=Noticket >>8;
 316   1        cod_1=Bnoticket;
 317   1        Debug_chr_Tibbo(cod_1);
 318   1            
 319   1        cod_0=Noticket;
 320   1        Debug_chr_Tibbo(cod_0);
 321   1        Debug_txt_Tibbo((unsigned char *) "\n\r");
 322   1            
 323   1        wr_eeprom(0xa8,EE_TICKET_ID,cod_3);
 324   1        wr_eeprom(0xa8,EE_TICKET_ID+1,cod_2);
 325   1        wr_eeprom(0xa8,EE_TICKET_ID+2,cod_1);
 326   1        wr_eeprom(0xa8,EE_TICKET_ID+3,cod_0); 
 327   1      }
 328          /*----------------------------------------------------------------------------------
 329          Procedimiento que lee el No de Ticket en EEprom y lo retorna en un strint
 330          -----------------------------------------------------------------------------------*/
 331          unsigned char *Lee_No_Ticket()
 332          {
 333   1        unsigned long int Noticket;
 334   1        unsigned char Lee_No_Ticket[11];
 335   1        unsigned char num_chr;
 336   1        Noticket=Read_EEprom_Ticket();
 337   1        sprintf( Lee_No_Ticket,"%lu",Noticket);
 338   1        num_chr=strlen(Lee_No_Ticket);
 339   1        Lee_No_Ticket[num_chr] = 0;
 340   1        Debug_txt_Tibbo((unsigned char *) Lee_No_Ticket);
 341   1        Debug_txt_Tibbo((unsigned char *) "\n\r");
 342   1        return Lee_No_Ticket;
 343   1      }
 344          /*----------------------------------------------------------------------------------
 345          Procedimiento que lee el No de Ticket en EEprom y lo retorna en un long int
 346          -----------------------------------------------------------------------------------*/
 347          unsigned long int  Read_EEprom_Ticket()
 348          {
 349   1        unsigned char cod3,cod2,cod1,cod0;
 350   1        unsigned long int Noticket=0;
 351   1        cod3=rd_eeprom(0xa8,EE_TICKET_ID);
 352   1        cod2=rd_eeprom(0xa8,EE_TICKET_ID+1);
 353   1        cod1=rd_eeprom(0xa8,EE_TICKET_ID+2);
 354   1        cod0=rd_eeprom(0xa8,EE_TICKET_ID+3);
 355   1        
 356   1        Noticket=((Noticket| cod3)<<8);
 357   1        Noticket=((Noticket| cod2)<<8);
 358   1        Noticket=((Noticket| cod1)<<8);
 359   1        Noticket=Noticket| cod0;
 360   1        return Noticket;
 361   1      }
 362          /*----------------------------------------------------------------------------------
 363          Procedimiento que incrementa en uno el numero del Ticket y la graba en  EEprom 
C51 COMPILER V9.59.0.0   EEPROM                                                            08/26/2021 15:40:14 PAGE 7   

 364          -----------------------------------------------------------------------------------*/
 365          void Incremente_Ticket()
 366          {
 367   1        
 368   1        unsigned long int Noticket;
 369   1        unsigned char Lee_No_Ticket[11];
 370   1        Noticket=Read_EEprom_Ticket();
 371   1        Noticket=Noticket+1;
 372   1        sprintf( Lee_No_Ticket,"%lu",Noticket);
 373   1        Write_EEprom_Ticket(Lee_No_Ticket);
 374   1      }
 375          
 376          //***********************************************************************************************
 377          //Rutina que lee la eeprom 
 378          //***********************************************************************************************
 379          void LeerMemoria(unsigned int addres, unsigned char *res)
 380            {
 381   1      unsigned char i;
 382   1      do {
 383   2        *res=rd_eeprom(0xa8,addres);;
 384   2        i=*res;
 385   2        addres++;
 386   2        res++;
 387   2      }while(i !='\0');
 388   1        *res='\0';
 389   1        }
 390          void EscribirMemoria(unsigned int addres,unsigned char *res)
 391            {
 392   1      
 393   1      
 394   1      while(*res !='\0'){
 395   2        if(*res =='\r'){*res='\0';}  
 396   2        wr_eeprom(0xa8,addres,*res);
 397   2       
 398   2          addres++;
 399   2          res++;
 400   2        }
 401   1       wr_eeprom(0xa8,addres,*res);
 402   1         addres++;
 403   1          res++;
 404   1        wr_eeprom(0xa8,addres,0);
 405   1      
 406   1      }
 407          void Formato_eeprom()
 408          {
 409   1      unsigned char dato=0xff;
 410   1      unsigned int i;
 411   1        for(i=0; i< EE_FECHA_VENCIMIENTO; i++)
 412   1        {
 413   2            wr_eeprom(0xa8,i,dato);
 414   2        }
 415   1            wr_eeprom(0xa8 ,EE_BAUDIO,00);              
 416   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1407    ----
   CONSTANT SIZE    =     59    ----
   XDATA SIZE       =      3      58
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.59.0.0   EEPROM                                                            08/26/2021 15:40:14 PAGE 8   

   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
