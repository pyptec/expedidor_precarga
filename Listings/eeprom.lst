C51 COMPILER V9.59.0.0   EEPROM                                                            09/03/2021 14:20:35 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE EEPROM
OBJECT MODULE PLACED IN .\Objects\eeprom.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE eeprom.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\eeprom.lst) TABS(2) OBJECT(.\Objects\eeprom.obj)

line level    source

   1          
   2          #include <eeprom.h>
   3          #include <reg51.h>
   4          #include <string.h>
   5          
   6          /*funciones externas*/
   7          extern void          _nop_     (void);
   8          extern void Delay (void);
   9          extern void Delay_20us(unsigned int cnt);
  10          extern void Delay_1ms(unsigned int cnt);
  11          extern long   atol (const char *s1);
  12          extern void Debug_txt_Tibbo(unsigned char * str);
  13          extern int sprintf  (char *, const char *, ...);
  14          extern void Debug_chr_Tibbo(unsigned char Dat);
  15          void Formato_eeprom();
  16          extern void Dwload_EEprom_prog(unsigned char *password);
  17          
  18          //******************************************************************************************
  19          //    RUTINAS DE EEPROM 24FC1025
  20          //******************************************************************************************
  21          sbit sda = P1^2;
  22          sbit scl = P1^3;
  23          //******************************************************************************************
  24          
  25          bit memory_flag;
  26          unsigned char byte_rd;
  27          unsigned char l_data_eeprom;
  28          unsigned char l_chr;
  29          
  30          /*define posiciones de memoria*/
  31          #define EE_ID_CLIENTE   0x0000
  32          
  33          #define EE_TICKET_ID          0X0200
  34          #define EE_FECHA_VENCIMIENTO    0X0350
  35          #define EE_BAUDIO               0X0800
  36          
  37          
  38          //*******************************************************************************************
  39          void ackd(void)
  40          {
  41   1        unsigned int i;
  42   1        memory_flag=1;
  43   1        scl=1;
  44   1        sda=1;
  45   1        for (i=0; i<1100; i++)             //500
  46   1        {
  47   2          if (sda==0)
  48   2          {
  49   3            memory_flag=0;
  50   3          scl=0;
  51   3      
  52   3          break;
  53   3          }
  54   2        }
C51 COMPILER V9.59.0.0   EEPROM                                                            09/03/2021 14:20:35 PAGE 2   

  55   1        
  56   1        if (memory_flag==1)
  57   1        { 
  58   2      
  59   2        }  
  60   1      } 
  61          //*******************************************************************************************
  62          //*******************************************************************************************
  63          void ack_lect(void)
  64          {
  65   1        int i;
  66   1        scl=1;
  67   1        sda=1;
  68   1        memory_flag=1;
  69   1        for (i=0; i<650; i++)
  70   1        {
  71   2          if (sda==0)
  72   2          {
  73   3            memory_flag=0;
  74   3          scl=0;
  75   3          break;
  76   3          }
  77   2        }
  78   1      } 
  79          //*******************************************************************************************
  80          void p_me (void)
  81          {
  82   1          scl=1;
  83   1          _nop_();
  84   1          scl=0;
  85   1      }
  86          //*******************************************************************************************
  87          void e_d_m (unsigned char a_serial_eeprom)
  88          {
  89   1        unsigned char nbits;
  90   1          for (nbits=0; nbits<8; nbits++)
  91   1        {
  92   2          a_serial_eeprom <<=1;
  93   2          if (CY==1)
  94   2          { 
  95   3            sda=1;
  96   3          }
  97   2          else
  98   2          {
  99   3            sda=0;
 100   3          }
 101   2          scl=1;
 102   2          p_me();         
 103   2        }
 104   1        return;
 105   1      }
 106          //********************************************************************************************
 107          void start (void)
 108          {
 109   1        sda=1;
 110   1        scl=1;
 111   1        _nop_();
 112   1        sda=0;
 113   1        scl=0;
 114   1        return;
 115   1      }
 116          //*******************************************************************************************
C51 COMPILER V9.59.0.0   EEPROM                                                            09/03/2021 14:20:35 PAGE 3   

 117          void stop (void)
 118          {
 119   1        scl=0;
 120   1        sda=0;
 121   1        _nop_();
 122   1        scl=1;
 123   1        sda=1;
 124   1        return;
 125   1      }
 126          //*******************************************************************************************
 127          unsigned char l_d_m (void)
 128          {
 129   1        unsigned char nbits;
 130   1          for (nbits=0; nbits<8; nbits++)
 131   1        {
 132   2          scl=0;
 133   2            if (sda==1) 
 134   2            {
 135   3            l_data_eeprom = l_data_eeprom| 0x01;
 136   3            if (nbits<=6) 
 137   3            {
 138   4              l_data_eeprom<<=1;
 139   4              scl=1;
 140   4            }
 141   3            }
 142   2            if (sda==0)
 143   2            {
 144   3              l_data_eeprom = l_data_eeprom & 0xFE;
 145   3            if (nbits<=6) 
 146   3            {
 147   4                l_data_eeprom <<=1;
 148   4              scl=1;
 149   4            }
 150   3            }
 151   2          }
 152   1        scl=0;
 153   1        return l_data_eeprom;
 154   1      }
 155          //*******************************************************************************************
 156          //*******************************************************************************************
 157          //  ESCRIBE EN EEPROM                                   *
 158          //*******************************************************************************************
 159          //void wr_eeprom (unsigned char control,unsigned char dir_h,unsigned char dir_l,unsigned char data_eeprom)
 160          void wr_eeprom (unsigned char control,unsigned int Dir, unsigned char data_eeprom)
 161          {
 162   1        unsigned char dir_h, dir_l;
 163   1        dir_l=Dir;
 164   1        Dir>>=8;
 165   1        dir_h=Dir;
 166   1      
 167   1      
 168   1        scl=0;
 169   1        sda=0;
 170   1      //  wait();
 171   1          start();
 172   1        e_d_m(control);
 173   1        ackd();
 174   1        e_d_m(dir_h);
 175   1        ackd();
 176   1        e_d_m(dir_l);
 177   1        ackd();
 178   1        e_d_m(data_eeprom);
C51 COMPILER V9.59.0.0   EEPROM                                                            09/03/2021 14:20:35 PAGE 4   

 179   1        ackd();
 180   1        stop();
 181   1        Delay_1ms(13);
 182   1        
 183   1        scl=1;
 184   1        sda=1;
 185   1        Delay_20us(98);                   /*wait long*/
 186   1        Delay_20us(98);
 187   1      }
 188          //*******************************************************************************************
 189          //  ESCRIBE EN EEPROM                                   *
 190          //*******************************************************************************************
 191          /*
 192          void wrpage_eeprom (unsigned char control,unsigned char dir_h,unsigned char dir_l,unsigned char data_eepro
             -m)  
 193          {
 194            unsigned int j;
 195            scl=0;
 196            sda=0;
 197            wait();
 198          
 199            wait();
 200          
 201              start();
 202            e_d_m(control);
 203            ack();
 204            e_d_m(dir_h);
 205            ack();
 206            e_d_m(dir_l);
 207            ack();
 208            for (j=0; j<=127; j++)
 209            {
 210              e_d_m(data_eeprom);
 211              ack();
 212            }
 213            stop();
 214            Delay_1ms(13);
 215            scl=1;
 216            sda=1;
 217           return;
 218          }                                              */
 219          //******************************************************************************************* 
 220          //******************************************************************************************* 
 221          //  LEE EN EEPROM                                     *
 222          //*******************************************************************************************
 223          //unsigned char rd_eeprom (unsigned char control,unsigned char dir_h,unsigned char dir_l) 
 224          unsigned char rd_eeprom (unsigned char control,unsigned int Dir) 
 225          {
 226   1      
 227   1        unsigned char dir_h, dir_l;
 228   1        dir_l=Dir;
 229   1        Dir>>=8;
 230   1        dir_h=Dir;
 231   1      
 232   1        scl=0;
 233   1        sda=0;
 234   1       // wait();
 235   1        start();
 236   1        e_d_m(control);
 237   1        ack_lect();
 238   1        e_d_m(dir_h);
 239   1          ack_lect();
C51 COMPILER V9.59.0.0   EEPROM                                                            09/03/2021 14:20:35 PAGE 5   

 240   1        e_d_m(dir_l);
 241   1        ack_lect();
 242   1        start();
 243   1        e_d_m(control+0x01);
 244   1        ackd();
 245   1        scl=0;
 246   1        l_d_m();
 247   1        stop();
 248   1          scl=1;
 249   1        sda=1;
 250   1        return l_data_eeprom;
 251   1      }
 252          /*----------------------------------------------------------------------------------
 253          Funcion q recibe el numero de ticket en un arreglo
 254          error=1 valida los 10 digitos del ticket y si no es numerico los escribe en cero
 255          j= proposito general
 256          Noticket= variable de 32 bits tiene el numero del ticket
 257          -----------------------------------------------------------------------------------*/
 258          void graba_serie(unsigned char *buffer)
 259          {
 260   1        
 261   1        unsigned char  j;
 262   1        unsigned char error=0;
 263   1        
 264   1        
 265   1      /*valido q los datos recibidos sean numericos*/
 266   1        
 267   1        *(buffer+10)=0;
 268   1        
 269   1        for (j=0; j<=9; j++)
 270   1        {
 271   2          if  ((*(buffer+j)<0x30)||(*(buffer+j)>0x39))
 272   2          {
 273   3            error=1;
 274   3            
 275   3            Debug_txt_Tibbo((unsigned char *) "Error de ticket");
 276   3            Debug_txt_Tibbo((unsigned char *) buffer);
 277   3            Debug_txt_Tibbo((unsigned char *) "\n\r");
 278   3          }
 279   2        
 280   2        }
 281   1        
 282   1        
 283   1        /* son numericos*/
 284   1          if (error==0)
 285   1          {
 286   2            Write_EEprom_Ticket(buffer);
 287   2              
 288   2          }
 289   1          else
 290   1          {
 291   2            wr_eeprom(0xa8,EE_TICKET_ID,00);
 292   2            wr_eeprom(0xa8,EE_TICKET_ID+1,00);
 293   2            wr_eeprom(0xa8,EE_TICKET_ID+2,00);
 294   2            wr_eeprom(0xa8,EE_TICKET_ID+3,00);  
 295   2            
 296   2          }
 297   1      }
 298          void Write_EEprom_Ticket(unsigned char *buffer)
 299          {
 300   1        unsigned char  cod_3,cod_2,cod_1,cod_0;
 301   1        unsigned long int Noticket,Bnoticket=0;
C51 COMPILER V9.59.0.0   EEPROM                                                            09/03/2021 14:20:35 PAGE 6   

 302   1        Debug_txt_Tibbo((unsigned char *) "Numero de ticket:");
 303   1        Debug_txt_Tibbo((unsigned char *) buffer);
 304   1        Debug_txt_Tibbo((unsigned char *) "\n\r");
 305   1        Noticket= atol(buffer);
 306   1          
 307   1        Debug_txt_Tibbo((unsigned char *) "No de ticket HEX:");
 308   1        Bnoticket=Noticket>>24;
 309   1        cod_3=Bnoticket;
 310   1        Debug_chr_Tibbo(cod_3);
 311   1          
 312   1        Bnoticket=Noticket >>16;
 313   1        cod_2=Bnoticket;
 314   1        Debug_chr_Tibbo(cod_2);
 315   1            
 316   1        Bnoticket=Noticket >>8;
 317   1        cod_1=Bnoticket;
 318   1        Debug_chr_Tibbo(cod_1);
 319   1            
 320   1        cod_0=Noticket;
 321   1        Debug_chr_Tibbo(cod_0);
 322   1        Debug_txt_Tibbo((unsigned char *) "\n\r");
 323   1            
 324   1        wr_eeprom(0xa8,EE_TICKET_ID,cod_3);
 325   1        wr_eeprom(0xa8,EE_TICKET_ID+1,cod_2);
 326   1        wr_eeprom(0xa8,EE_TICKET_ID+2,cod_1);
 327   1        wr_eeprom(0xa8,EE_TICKET_ID+3,cod_0); 
 328   1      }
 329          /*----------------------------------------------------------------------------------
 330          Procedimiento que lee el No de Ticket en EEprom y lo retorna en un strint
 331          -----------------------------------------------------------------------------------*/
 332          unsigned char *Lee_No_Ticket()
 333          {
 334   1        unsigned long int Noticket;
 335   1        unsigned char Lee_No_Ticket[11];
 336   1        unsigned char num_chr;
 337   1        Noticket=Read_EEprom_Ticket();
 338   1        sprintf( Lee_No_Ticket,"%lu",Noticket);
 339   1        num_chr=strlen(Lee_No_Ticket);
 340   1        Lee_No_Ticket[num_chr] = 0;
 341   1        Debug_txt_Tibbo((unsigned char *) Lee_No_Ticket);
 342   1        Debug_txt_Tibbo((unsigned char *) "\n\r");
 343   1        return Lee_No_Ticket;
 344   1      }
 345          /*----------------------------------------------------------------------------------
 346          Procedimiento que lee el No de Ticket en EEprom y lo retorna en un long int
 347          -----------------------------------------------------------------------------------*/
 348          unsigned long int  Read_EEprom_Ticket()
 349          {
 350   1        unsigned char cod3,cod2,cod1,cod0;
 351   1        unsigned long int Noticket=0;
 352   1        cod3=rd_eeprom(0xa8,EE_TICKET_ID);
 353   1        cod2=rd_eeprom(0xa8,EE_TICKET_ID+1);
 354   1        cod1=rd_eeprom(0xa8,EE_TICKET_ID+2);
 355   1        cod0=rd_eeprom(0xa8,EE_TICKET_ID+3);
 356   1        
 357   1        Noticket=((Noticket| cod3)<<8);
 358   1        Noticket=((Noticket| cod2)<<8);
 359   1        Noticket=((Noticket| cod1)<<8);
 360   1        Noticket=Noticket| cod0;
 361   1        return Noticket;
 362   1      }
 363          /*----------------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   EEPROM                                                            09/03/2021 14:20:35 PAGE 7   

 364          Procedimiento que incrementa en uno el numero del Ticket y la graba en  EEprom 
 365          -----------------------------------------------------------------------------------*/
 366          void Incremente_Ticket()
 367          {
 368   1        
 369   1        unsigned long int Noticket;
 370   1        unsigned char Lee_No_Ticket[11];
 371   1        Noticket=Read_EEprom_Ticket();
 372   1        Noticket=Noticket+1;
 373   1        sprintf( Lee_No_Ticket,"%lu",Noticket);
 374   1        Write_EEprom_Ticket(Lee_No_Ticket);
 375   1      }
 376          
 377          //***********************************************************************************************
 378          //Rutina que lee la eeprom 
 379          //***********************************************************************************************
 380          void LeerMemoria(unsigned int addres, unsigned char *res)
 381            {
 382   1      unsigned char i;
 383   1      do {
 384   2        *res=rd_eeprom(0xa8,addres);;
 385   2        i=*res;
 386   2        addres++;
 387   2        res++;
 388   2      }while(i !='\0');
 389   1        *res='\0';
 390   1        }
 391          void EscribirMemoria(unsigned int addres,unsigned char *res)
 392            {
 393   1      
 394   1      
 395   1      while(*res !='\0'){
 396   2        if(*res =='\r'){*res='\0';}  
 397   2        wr_eeprom(0xa8,addres,*res);
 398   2       
 399   2          addres++;
 400   2          res++;
 401   2        }
 402   1       wr_eeprom(0xa8,addres,*res);
 403   1         addres++;
 404   1          res++;
 405   1        wr_eeprom(0xa8,addres,0);
 406   1      
 407   1      }
 408          /*void Formato_eeprom()
 409          {
 410          unsigned char dato=0xff;
 411          unsigned int i;
 412          unsigned char password[7] ;
 413            for(i=0; i< EE_FECHA_VENCIMIENTO; i++)
 414            {
 415                wr_eeprom(0xa8,i,dato);
 416            }
 417                wr_eeprom(0xa8 ,EE_BAUDIO,00);  
 418              strcpy(password, "nataly");
 419              Dwload_EEprom_prog(password); 
 420          }*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1344    ----
   CONSTANT SIZE    =     59    ----
C51 COMPILER V9.59.0.0   EEPROM                                                            09/03/2021 14:20:35 PAGE 8   

   XDATA SIZE       =      3      55
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
