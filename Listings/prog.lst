C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE PROG
OBJECT MODULE PLACED IN .\Objects\prog.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE prog.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\prog.lst) TABS(2) OBJECT(.\Objects\prog.obj)

line level    source

   1          
   2          #include "prog.h" 
   3          #include <string.h>
   4          extern int printf   (const char *, ...);
   5          extern char putchar (char);
   6          extern char getchar (void);
   7          extern char  *strtok  (char *str, const char *set);
   8          extern char   strcmp  (const char *s1, const char *s2);
   9          extern char  *strcpy  (char *s1, const char *s2);
  10          extern char _getkey (void);
  11          extern char  *strcat  (char *s1, const char *s2);
  12          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  13          extern void wr_eeprom (unsigned char control,unsigned int Dir, unsigned char data_eeprom);
  14          extern int sprintf  (char *, const char *, ...);
  15          extern int    atoi (const char *s1);
  16          extern unsigned long int  Read_EEprom_Ticket();
  17          extern void LeerMemoria(unsigned int addres, unsigned char *res);
  18          extern void EscribirMemoria(unsigned int addres,unsigned char *res);
  19          extern int   rand ();
  20          extern void Block_read_clock_ascii(unsigned char *datos_clock);
  21          extern char check_fechaOut(char *buffer);
  22          extern void ByteHex_Decimal(unsigned char *buffer,unsigned char valorhex);
  23          extern unsigned char hex_bcd (unsigned char byte);
  24          extern void hex_ascii(unsigned char * datos,unsigned char * fecha_asii);
  25          extern unsigned char *Lee_No_Ticket();
  26          
  27          unsigned char cursor[20] = "/"; //current working directory
  28          unsigned char validacion [11]={"admin"};  //usuario
  29          
  30          
  31          
  32          
  33          
  34          /*define posiciones de memoria*/
  35          #define EE_ID_CLIENTE           0x0000
  36          #define EE_ID_PARK              0x0002
  37          #define EE_TIEMPO_GRACIA        0x0004
  38          #define EE_SIN_COBRO            0x0006
  39          #define EE_DEBUG                0x0008
  40          #define EE_USE_LPR              0x000A
  41          #define EE_TIPO_PANTALLA        0X000E
  42          #define EE_CARD_AUTOMATIC_BOTON 0x000f
  43          #define EE_HABILITA_APB         0x0010
  44          #define EE_PLACA                0X0011
  45          #define EE_ADDRESS_HIGH_BOARD   0X0012
  46          #define EE_JUST_ONE_TIME_CLAVE  0X0013
  47          #define EE_VALIDA_TIPO_VEHICULO_MENSUAL 0X0014
  48          #define EE_HABILITA_APB_MENSUAL 0X0015
  49          #define EE_MENSUAL_BOCA_ON_OFF  0X0016
  50          
  51          #define EE_HORARIO_1            0X0019
  52          #define EE_HORARIO_2            0x0032
  53          #define EE_HORARIO_3            0x004b
  54          #define EE_HORARIO_4            0x0064
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 2   

  55          #define EE_HORARIO_5            0x007d
  56          #define EE_HORARIO_6            0x0096
  57          #define EE_HORARIO_7            0x00af
  58          #define EE_HORARIO_8            0x00c8
  59          #define EE_HORARIO_9            0x00e1
  60          #define EE_HORARIO_10           0x00fa
  61          #define EE_TICKET_ID            0X0200
  62          #define EE_ID_REGISTER          0x0300
  63          #define EE_FECHA_VENCIMIENTO    0X0350
  64          
  65          #define EE_BAUDIO               0X0800
  66          /* Definicion del tamaño de comando y longitud de cmd*/
  67          
  68          #define   NUMCOMMAND 19
  69          #define   LONGSIZE 3
  70          
  71          #define True                    0x01
  72          #define False                   0x00
  73          
  74          
  75          
  76          enum ee_horario_addr{
  77            ee_horario1_addr, ee_horario2_addr, ee_horario3_addr, ee_horario4_addr, ee_horario5_addr,
  78            ee_horario6_addr, ee_horario7_addr, ee_horario8_addr, ee_horario9_addr, ee_horario10_addr,
  79            ee_horarioNULL_addr
  80          };
  81          
  82          
  83          enum Dia_Semana_addr{
  84            Lunes_addr = 1, Martes_addr = 2, Miercoles_addr = 3, Jueves_addr =4, Viernes_addr = 5, 
  85            Sabado_addr = 6, Domingo_addr =0 
  86          };
  87          enum Dia_Semana_data{
  88            Domingo_dato=0x31, Lunes_dato=0x32, Martes_dato=0x33, Miercoles_dato=0x34, Jueves_dato=0x35, Viernes_dato
             -=0x36, Sabado_dato=0x37  
  89          };
  90          enum Hora_Minutos_addr{
  91            Hora_High_addr_Desde = 7, Hora_Low_addr_Desde = 8, Minutos_High_addr_Desde = 9, Minutos_Low_addr_Desde = 
             -10,
  92            Hora_High_addr_Hasta = 11, Hora_Low_addr_Hasta = 12, Minutos_High_addr_Hasta = 13, Minutos_Low_addr_Hasta
             - = 14,
  93            Habilita_addr =15, Segundo_Tiempo=16
  94          };
  95          enum Hora_Minutos_data{
  96              Hora_High_data = 0, Hora_Low_data = 1, Minutos_High_data = 3, Minutos_Low_data =4
  97          };
  98          char comandos[NUMCOMMAND][LONGSIZE]=
  99          {
 100            "0",          //ID_CLIENTEValor del punto cero.
 101            "1",       //COD_PARKTiempo de recolecion entre muestra
 102            "2",    // T_GRACIAInformacion recolectada enviada al rs232
 103            "3",    //SIN_COBROAjuste del cero del sensor
 104            "4",  //DEBUG Calibracion por la curva de la pendiente
 105            "5",    //USE_LPR
 106            "6",      //TIPO_PANTALLA
 107            "7",        // tarjeta automatica o boton
 108            "8",      //habilita apb o inhabilta
 109            "9",      //placa
 110            "10",     // direccion logico
 111            "11",     // prog horario
 112            "12",     // Validar tipo de vehiculo mensual
 113            "13",     // habilita apb para mensual
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 3   

 114            "14",     // configura mensuales
 115            "15",     // ver comandos programados
 116            "16",     //AYUDA Ayuda!muestra todos los comandos
 117            "17",     //SALIRSalir de programacion
 118            "18",     //cmd escondido fecha de vencimiento password
 119            
 120          };
 121          
 122          /*------------------------------------------------------------------------------
 123          Rutina que encripta la clave q se le envie
 124          len_clave= longitud de la clave a encriptar
 125          aleatorio=numero aleatoria para escoger el dato a sumar y para la or
 126          
 127          ------------------------------------------------------------------------------*/
 128          unsigned char *hash_id(unsigned char *clave)
 129          {
 130   1        unsigned char len_clave,i;
 131   1        static unsigned int temp, temp1;
 132   1        unsigned char aleatorio []={":[<%?XT]=)" };
 133   1        //unsigned char aleatorio2 []={"@#!\`Fb^&*" };
 134   1        unsigned char suma []={"#*YJAIMEcamiltK"};/*caracteres q se le suman a la trama */
 135   1        unsigned char xxor []={"wrz25q68-91fS.@" };
 136   1        unsigned char usuario1[11];
 137   1        unsigned char vencimiento_password [4];
 138   1        
 139   1        LeerMemoria(EE_FECHA_VENCIMIENTO,vencimiento_password); 
 140   1        if (check_fechaOut(vencimiento_password) != True)
 141   1          
 142   1        {
 143   2          strcpy(aleatorio,"@#!$`Fb^&*");
 144   2        }
 145   1        else
 146   1        {
 147   2          strcpy(aleatorio, ":[<%?XT]=)");
 148   2        }
 149   1        len_clave=strlen(clave);                      /*longitud de la clave a encriptar*/
 150   1          for (i=0; i<10;i++)
 151   1          {
 152   2            temp=*(clave+i)+aleatorio[i];               /*el primer caracter de la clave se le suma con el primero de los 
             -aleatorios*/
 153   2            temp1=temp & 15;                            /*al  resultado se le hace una and con (0x0f)*/
 154   2            if (temp1==0)temp1++; 
 155   2            temp=*(clave+i) + suma[temp1-1];            /*se suma la clave  con el arreglo suma y el valor del arreglo bi
             -ene de  aleatorio el resultado q da en temp */
 156   2            temp1=temp & 15;
 157   2            if (temp1==0)temp1++;
 158   2            temp=temp ^ xxor[temp1-1];                  /*temp se le hace uan xor aleatoria*/
 159   2            if (temp > 255)
 160   2            {
 161   3              temp=temp & 255;
 162   3            }     
 163   2            if ((temp >=122)&&(temp<=255))
 164   2            {
 165   3            temp=temp & 122;
 166   3          
 167   3            }
 168   2            if (temp < 48)
 169   2            {
 170   3            temp=temp+64;
 171   3            }
 172   2            if ((temp>=91)&&(temp<=96))
 173   2            {
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 4   

 174   3            temp=temp +7 ;
 175   3            }
 176   2            if ((temp>=58)&&(temp<=64))
 177   2            {
 178   3            temp=temp - 7 ;
 179   3            }
 180   2            usuario1[i]=temp;
 181   2          
 182   2          }
 183   1          usuario1[i]=0;
 184   1        
 185   1        return usuario1;
 186   1      }
 187          
 188          
 189          /*------------------------------------------------------------------------------
 190          Rutina de lista de comandos 
 191          ------------------------------------------------------------------------------*/
 192          
 193          unsigned char ListaComandos(unsigned char *cmd)
 194          {
 195   1         unsigned char buf[LONGSIZE];
 196   1         unsigned char i;
 197   1         
 198   1         for (i=0; i<NUMCOMMAND; i++)
 199   1         {
 200   2            strcpy(buf, &comandos[i][0]);
 201   2            if (strcmp(buf, cmd)==0)
 202   2               return(i);
 203   2         }
 204   1         
 205   1         return(0xFF);
 206   1      }
 207          
 208          
 209          /*------------------------------------------------------------------------------
 210          Rutina que valida la clave
 211          ------------------------------------------------------------------------------*/
 212          unsigned char  ValidarClave(unsigned char *buffer)
 213          {
 214   1      unsigned char buf [11];
 215   1        
 216   1            strcpy(buf, &validacion[0]);
 217   1            if (strcmp(buf, buffer)==0)
 218   1               return(0);
 219   1       
 220   1         
 221   1         return(0xFF);
 222   1      }
 223          
 224          
 225          
 226          /*------------------------------------------------------------------------------
 227          Rutina que busca el \
 228          ------------------------------------------------------------------------------*/
 229          unsigned char * GetCMD(unsigned char *in)
 230          {
 231   1         char tokens[]=" \r\n";
 232   1         return(strtok(in,tokens));
 233   1      }
 234          
 235          /*------------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 5   

 236          Rutina de 
 237          ------------------------------------------------------------------------------*/
 238          unsigned char * GetOption(unsigned char *in)
 239          {
 240   1         unsigned char tokensSpace[]=" \r\n";
 241   1         unsigned char tokensQuote[]="\"\r\n";
 242   1         
 243   1         //trim leading spaces
 244   1         while (*in==' ')
 245   1            in++;
 246   1         
 247   1         //if first char is a quote, then end token on a quote.  ELSE end token on a space
 248   1         if (*in == '\"')
 249   1            return(strtok(in,tokensQuote));
 250   1         else
 251   1            return(strtok(in,tokensSpace));
 252   1      } 
 253          /*------------------------------------------------------------------------------
 254          Rutina de muestra el cursor
 255          ------------------------------------------------------------------------------*/
 256          
 257          void DisplayCursor(void)
 258          {
 259   1         printf("\r\n\n%s> ", cursor);
 260   1      }
 261          
 262          /*------------------------------------------------------------------------------
 263          Rutina que captura los datos pto serie y los muestra en el pto
 264          ------------------------------------------------------------------------------*/
 265          
 266          void IngresaDato(unsigned char  *buffer, unsigned char modo)
 267          {
 268   1      
 269   1       int i;
 270   1       
 271   1        do
 272   1        { 
 273   2          *buffer = _getkey();
 274   2        if (modo == 0) 
 275   2          {
 276   3             printf("%c", *buffer);
 277   3          }
 278   2          else 
 279   2          {
 280   3            putchar('*');
 281   3          }
 282   2           i=*buffer; 
 283   2           buffer++;
 284   2          *buffer='\0'; 
 285   2          
 286   2        } while(i != '\r');
 287   1          
 288   1            
 289   1               
 290   1      } 
 291          /*
 292          void LeerMemoria(unsigned int  addres,unsigned char  *res)
 293          {
 294          unsigned char i;
 295            do {
 296              *res=rd_eeprom(0xa8,addres);
 297              i=*res;
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 6   

 298              addres++;
 299              res++;
 300              }while(i !='\0');
 301              *res='\0';
 302          }
 303          */
 304          /*------------------------------------------------------------------------------
 305          Rutina que programa el id_cliente en eeprom
 306          ------------------------------------------------------------------------------*/
 307          void prog_id_cliente()
 308          {
 309   1        unsigned char buffer[10];
 310   1        unsigned int dataee;
 311   1        
 312   1        dataee=rd_eeprom(0xa8,EE_ID_CLIENTE);                                         /*se lee el id_cliente actual */
 313   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 314   1        
 315   1        printf("\r\n\n ACTUAL ID_CLIENTE=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual en pan
             -talla*/
 316   1        
 317   1        printf("\r\n\n DIGITE SU NUEVO ID_CLIENTE=");                                 /*digite el nuevo id_cliente*/
 318   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 319   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 320   1        wr_eeprom(0xa8,EE_ID_CLIENTE,dataee);                                         /*grabo el dato en la eeprom*/
 321   1        
 322   1        dataee=rd_eeprom(0xa8,EE_ID_CLIENTE);                                         /*leo el dato grabado*/
 323   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 324   1        printf("\r\n\n DATO MODIFICADO ID_CLIENTE=%s\r\n\n",buffer);                  /*lo muetro por la pantalla el dato 
             -grabado*/
 325   1      }
 326          /*------------------------------------------------------------------------------
 327          Rutina que programa el cod_park
 328          ------------------------------------------------------------------------------*/
 329          void prog_cod_park()
 330          {
 331   1        unsigned char buffer[10];
 332   1        unsigned int dataee;
 333   1        
 334   1        dataee=rd_eeprom(0xa8,EE_ID_PARK);                                          /*se lee el id_cliente actual */
 335   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 336   1        
 337   1        printf("\r\n\n ACTUAL COD_PARK=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual en panta
             -lla*/
 338   1        
 339   1        printf("\r\n\n DIGITE SU NUEVO COD_PARK=");                                 /*digite el nuevo id_cliente*/
 340   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 341   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 342   1        wr_eeprom(0xa8,EE_ID_PARK,dataee);                                          /*grabo el dato en la eeprom*/
 343   1        
 344   1        dataee=rd_eeprom(0xa8,EE_ID_PARK);                                          /*leo el dato grabado*/
 345   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 346   1        printf("\r\n\n DATO MODIFICADO COD_PARK=%s\r\n\n",buffer);                  /*lo muetro por la pantalla el dato gr
             -abado*/
 347   1      }
 348          /*------------------------------------------------------------------------------
 349          Rutina que programa el tiempo de gracia de cobro (00) no tiene tiempo de gracia
 350          ------------------------------------------------------------------------------*/
 351          void Prog_tiempo_gracia()
 352          {
 353   1        unsigned char buffer[10];
 354   1        unsigned int dataee;
 355   1        
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 7   

 356   1        dataee=rd_eeprom(0xa8,EE_TIEMPO_GRACIA);                                          /*se lee el id_cliente actual */
 357   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 358   1        
 359   1        printf("\r\n\n ACTUAL TIEMPO_GRACIA=%s\r\n\n",buffer);                            /*se muestra el id_cliente actual en 
             -pantalla*/
 360   1        
 361   1        printf("\r\n\n DIGITE SU NUEVO TIEMPO_GRACIA=");                                  /*digite el nuevo id_cliente*/
 362   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 363   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 364   1        wr_eeprom(0xa8,EE_TIEMPO_GRACIA,dataee);                                          /*grabo el dato en la eeprom*/
 365   1        
 366   1        dataee=rd_eeprom(0xa8,EE_TIEMPO_GRACIA);                                        /*leo el dato grabado*/
 367   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 368   1        printf("\r\n\n DATO MODIFICADO TIEMPO_GRACIA=%s\r\n\n",buffer);               /*lo muetro por la pantalla el dat
             -o grabado*/
 369   1      }
 370          /*------------------------------------------------------------------------------
 371          Rutina que programa SIN COBRO
 372          SIN_COBRO=0 inhabilitado, SIN_COBRO=1 sin cobro, SIN_COBRO=2 sin cobro y salida el mismo dia");
 373          ------------------------------------------------------------------------------*/
 374          void Prog_Sin_Cobro()
 375          {
 376   1        
 377   1      
 378   1        unsigned char buffer[10];
 379   1        unsigned int dataee;
 380   1      
 381   1        dataee=rd_eeprom(0xa8,EE_SIN_COBRO);                                          /*se lee el id_cliente actual */
 382   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 383   1        if(dataee==0)
 384   1        {
 385   2          printf("\r\n\n ACTUAL SIN_COBRO INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente 
             -actual en pantalla*/
 386   2        }
 387   1        else if (dataee==1)
 388   1        {
 389   2          printf("\r\n\n ACTUAL SIN_COBRO GRATIS=%s\r\n\n",buffer);   
 390   2        }
 391   1        else 
 392   1        {
 393   2            printf("\r\n\n ACTUAL SIN_COBRO GRATIS Y SALIDA EL MISMO DIA=%s\r\n\n",buffer);   
 394   2        }
 395   1        
 396   1        printf("\r\n\n DIGITE SU NUEVO SIN_COBRO=");                                  /*digite el nuevo id_cliente*/
 397   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 398   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 399   1        wr_eeprom(0xa8,EE_SIN_COBRO,dataee);                                          /*grabo el dato en la eeprom*/
 400   1        
 401   1        dataee=rd_eeprom(0xa8,EE_SIN_COBRO);                                        /*leo el dato grabado*/
 402   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 403   1        if(dataee==0)
 404   1        {
 405   2          printf("\r\n\n ACTUAL SIN_COBRO INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente 
             -actual en pantalla*/
 406   2        }
 407   1        else if (dataee==1)
 408   1        {
 409   2          printf("\r\n\n ACTUAL SIN_COBRO GRATIS=%s\r\n\n",buffer);   
 410   2        }
 411   1        else 
 412   1        {
 413   2            printf("\r\n\n ACTUAL SIN_COBRO GRATIS Y SALIDA EL MISMO DIA=%s\r\n\n",buffer);   
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 8   

 414   2        }
 415   1        
 416   1      }
 417          /*------------------------------------------------------------------------------------
 418          Rutina que habilita el debuger
 419           Habilita = 1 ; 
 420          inahabilita = 0;
 421          --------------------------------------------------------------------------------------*/
 422          void Prog_debug()
 423          {
 424   1        unsigned char buffer[10];
 425   1        unsigned int dataee;
 426   1      
 427   1        
 428   1        dataee=rd_eeprom(0xa8,EE_DEBUG);                                          /*se lee el id_cliente actual */
 429   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 430   1        if(dataee==0)
 431   1        {
 432   2          printf("\r\n\n ACTUAL DEBUG INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 433   2        }
 434   1        else
 435   1        {
 436   2          printf("\r\n\n ACTUAL DEBUG HABILITADO=%s\r\n\n",buffer);     
 437   2        }
 438   1        
 439   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE DEBUG=");                                  /*digite el nuevo id_cliente*/
 440   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 441   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 442   1        wr_eeprom(0xa8,EE_DEBUG,dataee);                                          /*grabo el dato en la eeprom*/
 443   1        
 444   1        dataee=rd_eeprom(0xa8,EE_DEBUG);                                        /*leo el dato grabado*/
 445   1        sprintf(buffer,"%d",dataee);  
 446   1        if(dataee==0)
 447   1        {
 448   2          printf("\r\n\n ACTUAL DEBUG INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 449   2        }
 450   1        else
 451   1        {
 452   2          printf("\r\n\n ACTUAL DEBUG HABILITADO=%s\r\n\n",buffer);     
 453   2        }
 454   1      }
 455          /*------------------------------------------------------------------------------------
 456          
 457          --------------------------------------------------------------------------------------*/
 458          
 459          void Prog_Use_Lpr()
 460          {
 461   1          unsigned char buffer[10];
 462   1        unsigned int dataee;
 463   1      
 464   1        
 465   1        dataee=rd_eeprom(0xa8,EE_USE_LPR);                                          /*se lee el id_cliente actual */
 466   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 467   1        if(dataee==0)
 468   1        {
 469   2          printf("\r\n\n ACTUAL USE_LPR INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente ac
             -tual en pantalla*/
 470   2        }
 471   1        else
 472   1        {
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 9   

 473   2          printf("\r\n\n ACTUAL USE_LPR HABILITADO=%s\r\n\n",buffer);     
 474   2        }
 475   1        
 476   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE USE_LPR=");                                  /*digite el nuevo id_cliente*/
 477   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 478   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 479   1        wr_eeprom(0xa8,EE_USE_LPR,dataee);                                          /*grabo el dato en la eeprom*/
 480   1        
 481   1        dataee=rd_eeprom(0xa8,EE_USE_LPR);                                        /*leo el dato grabado*/
 482   1        sprintf(buffer,"%d",dataee);  
 483   1        if(dataee==0)
 484   1        {
 485   2          printf("\r\n\n ACTUAL USE_LPR INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente ac
             -tual en pantalla*/
 486   2        }
 487   1        else
 488   1        {
 489   2          printf("\r\n\n ACTUAL USE_LPR HABILITADO=%s\r\n\n",buffer);     
 490   2        }
 491   1      }
 492          
 493          /*------------------------------------------------------------------------------------
 494          cmd del tipo de pantalla a usar
 495          Rasberry = 1
 496          lcd = 0
 497          --------------------------------------------------------------------------------------*/
 498          void tipo_pantalla()
 499          {
 500   1        unsigned char buffer[10];
 501   1        unsigned int dataee;
 502   1      
 503   1        
 504   1        dataee=rd_eeprom(0xa8,EE_TIPO_PANTALLA);                                          /*se lee el id_cliente actual */
 505   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 506   1        if(dataee==0)
 507   1        {
 508   2          printf("\r\n\n PANTALLA LCD HABILITADA=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual
             - en pantalla*/
 509   2        }
 510   1        else
 511   1        {
 512   2          printf("\r\n\n PANTALLA RASPBERRY  HABILITADA=%s\r\n\n",buffer);      
 513   2        }
 514   1        
 515   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE LA PANTALLA =");                                 /*digite el nuevo id_cliente*/
 516   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 517   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 518   1        wr_eeprom(0xa8,EE_TIPO_PANTALLA,dataee);                                          /*grabo el dato en la eeprom*/
 519   1        
 520   1        dataee=rd_eeprom(0xa8,EE_TIPO_PANTALLA);                                        /*leo el dato grabado*/
 521   1        sprintf(buffer,"%d",dataee);  
 522   1        if(dataee==0)
 523   1        {
 524   2          printf("\r\n\n PANTALLA LCD HABILITADA=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual
             - en pantalla*/
 525   2        }
 526   1        else
 527   1        {
 528   2          printf("\r\n\n ACTUAL COMPARACION ACTIVA  HABILITADA=%s\r\n\n",buffer);     
 529   2        }
 530   1        
 531   1      }
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 10  

 532          void Prog_tarjeta_automatica_o_boton()
 533          {
 534   1        unsigned char buffer[10];
 535   1        unsigned int dataee;
 536   1      
 537   1        
 538   1        dataee=rd_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON);                               //se lee LA CONFIGURACION 
 539   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 540   1        if(dataee==0)
 541   1        {
 542   2          printf("\r\n\n EXPIDE TARJETA PULSANDO BOTON\r\n\n");                           /*se muestra el id_cliente actual en 
             -pantalla*/
 543   2        }
 544   1        else
 545   1        {
 546   2          printf("\r\n\n EXPIDE TARJETA AUTOMATICA\r\n\n");     
 547   2        }
 548   1        
 549   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DEL EXPEDIDOR=");                                 /*digite el nuevo id_cliente*/
 550   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 551   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 552   1        wr_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON,dataee);                                         /*grabo el dato en la eeprom*/
 553   1        
 554   1        dataee=rd_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON);                                       /*leo el dato grabado*/
 555   1        sprintf(buffer,"%d",dataee);  
 556   1        if(dataee==0)
 557   1        {
 558   2          printf("\r\n\n EXPIDE TARJETA PULSANDO BOTON\r\n\n");                           /*se muestra el id_cliente actual en 
             -pantalla*/
 559   2        }
 560   1        else
 561   1        {
 562   2          printf("\r\n\n EXPIDE TARJETA AUTOMATICA\r\n\n");     
 563   2        }
 564   1      }
 565          void Prog_AntiPassBack()
 566          {
 567   1        unsigned char buffer[10];
 568   1        unsigned int dataee;
 569   1      
 570   1        
 571   1        dataee=rd_eeprom(0xa8,EE_HABILITA_APB);                                         /*se lee el id_cliente actual */
 572   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 573   1        if(dataee==0)
 574   1        {
 575   2          printf("\r\n\n ACTUAL ANTIPASSBACK INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el id_clien
             -te actual en pantalla*/
 576   2        }
 577   1        else
 578   1        {
 579   2          printf("\r\n\n ACTUAL ANTIPASSBACK HABILITADO=%s\r\n\n",buffer);      
 580   2        }
 581   1        
 582   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE ANTIPASSBACK=");                                 /*digite el nuevo id_cliente*/
 583   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 584   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 585   1        wr_eeprom(0xa8,EE_HABILITA_APB,dataee);                                         /*grabo el dato en la eeprom*/
 586   1        
 587   1        dataee=rd_eeprom(0xa8,EE_HABILITA_APB);                                       /*leo el dato grabado*/
 588   1        sprintf(buffer,"%d",dataee);  
 589   1        if(dataee==0)
 590   1        {
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 11  

 591   2          printf("\r\n\n ACTUAL ANTIPASSBACK INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el id_clien
             -te actual en pantalla*/
 592   2        }
 593   1        else
 594   1        {
 595   2          printf("\r\n\n ACTUAL ANTIPASSBACK HABILITADO=%s\r\n\n",buffer);      
 596   2        }
 597   1      }
 598          void Prog_Placa()
 599          {
 600   1        unsigned char buffer[10];
 601   1        unsigned int dataee;
 602   1      
 603   1        
 604   1        dataee=rd_eeprom(0xa8,EE_PLACA);                                          /*se lee el id_cliente actual */
 605   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 606   1        if(dataee==0)
 607   1        {
 608   2          printf("\r\n\n ACTUAL PLACA INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 609   2        }
 610   1        else
 611   1        {
 612   2          printf("\r\n\n ACTUAL PLACA HABILITADO=%s\r\n\n",buffer);     
 613   2        }
 614   1        
 615   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE PLACA=");                                  /*digite el nuevo id_cliente*/
 616   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 617   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 618   1        wr_eeprom(0xa8,EE_PLACA,dataee);                                          /*grabo el dato en la eeprom*/
 619   1        
 620   1        dataee=rd_eeprom(0xa8,EE_PLACA);                                        /*leo el dato grabado*/
 621   1        sprintf(buffer,"%d",dataee);  
 622   1        if(dataee==0)
 623   1        {
 624   2          printf("\r\n\n ACTUAL PLACA INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 625   2        }
 626   1        else
 627   1        {
 628   2          printf("\r\n\n ACTUAL PLACA HABILITADO=%s\r\n\n",buffer);     
 629   2        }
 630   1      }
 631          void Prog_Address_High_Board()
 632          {
 633   1        unsigned char buffer[10];
 634   1        unsigned int dataee;
 635   1      
 636   1        
 637   1        dataee=rd_eeprom(0xa8,EE_ADDRESS_HIGH_BOARD);                                         /*se lee el id_cliente actual */
 638   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 639   1        if(dataee==0)
 640   1        {
 641   2          printf("\r\n\n ACTUAL ADDRESS_HIGH_BOARD=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 642   2        }
 643   1        else
 644   1        {
 645   2          printf("\r\n\n ACTUAL ADDRESS_HIGH_BOARD=%s\r\n\n",buffer);     
 646   2        }
 647   1        
 648   1        printf("\r\n\n DIGITE LA NUEVA ADDRESS_HIGH_BOARD=");                                 /*digite el nuevo id_cliente*/
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 12  

 649   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 650   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 651   1        wr_eeprom(0xa8,EE_ADDRESS_HIGH_BOARD,dataee);                                         /*grabo el dato en la eeprom*/
 652   1        
 653   1        dataee=rd_eeprom(0xa8,EE_ADDRESS_HIGH_BOARD);                                       /*leo el dato grabado*/
 654   1        sprintf(buffer,"%d",dataee);  
 655   1        if(dataee==0)
 656   1        {
 657   2          printf("\r\n\n ACTUAL ADDRESS_HIGH_BOARD=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 658   2        }
 659   1        else
 660   1        {
 661   2          printf("\r\n\n ACTUAL ADDRESS_HIGH_BOARD=%s\r\n\n",buffer);     
 662   2        }
 663   1      }
 664          
 665          unsigned char *Addr_Horarios()
 666          {
 667   1        unsigned char ee_addr_horario[11];
 668   1          /*direcciones de memoria de almacenamiento*/
 669   1        ee_addr_horario[ee_horario1_addr]= EE_HORARIO_1;
 670   1        ee_addr_horario[ee_horario2_addr]= EE_HORARIO_2;
 671   1        ee_addr_horario[ee_horario3_addr]= EE_HORARIO_3;
 672   1        ee_addr_horario[ee_horario4_addr]= EE_HORARIO_4;
 673   1        ee_addr_horario[ee_horario5_addr]= EE_HORARIO_5;
 674   1        ee_addr_horario[ee_horario6_addr]= EE_HORARIO_6;
 675   1        ee_addr_horario[ee_horario7_addr]= EE_HORARIO_7;
 676   1        ee_addr_horario[ee_horario8_addr]= EE_HORARIO_8;
 677   1        ee_addr_horario[ee_horario9_addr]= EE_HORARIO_9;
 678   1        ee_addr_horario[ee_horario10_addr]= EE_HORARIO_10;
 679   1        ee_addr_horario[ee_horarioNULL_addr] = False;
 680   1        return ee_addr_horario;
 681   1      }
 682          unsigned char Prog_Horarios_on_off(unsigned int addr)
 683          {
 684   1        unsigned char buffer[10];
 685   1        unsigned int dataee,habilitado;
 686   1        dataee = rd_eeprom(0xa8,addr);                                          /*se lee el id_cliente actual */
 687   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 688   1        if(dataee==0)
 689   1        {
 690   2          printf("\r\n\n ACTUAL HORARIO INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente ac
             -tual en pantalla*/
 691   2        }
 692   1        else
 693   1        {
 694   2          printf("\r\n\n ACTUAL HORARIO HABILITADO=%s\r\n\n",buffer);     
 695   2        }
 696   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE HORARIO=");                                  /*digite el nuevo id_cliente*/
 697   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 698   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 699   1        wr_eeprom(0xa8,addr,dataee);                                          /*grabo el dato en la eeprom*/
 700   1        
 701   1        dataee=rd_eeprom(0xa8,addr);                                        /*leo el dato grabado*/
 702   1        sprintf(buffer,"%d",dataee);  
 703   1        if(dataee==0)
 704   1        {
 705   2          habilitado= False;
 706   2          printf("\r\n\n ACTUAL HORARIO INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente ac
             -tual en pantalla*/
 707   2        }
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 13  

 708   1        else
 709   1        {
 710   2          habilitado=True;
 711   2          printf("\r\n\n ACTUAL HORARIO HABILITADO=%s\r\n\n",buffer);     
 712   2        }
 713   1        return habilitado;
 714   1      }
 715          void Prog_Horario_Desde_Hasta(unsigned int addr)
 716          {
 717   1          unsigned char buffer[10];
 718   1          unsigned char dataee;
 719   1        /*la hora de inicio del horario*/
 720   1        
 721   1        printf("\r\n\n Digite Hora 08:00 Minutos Desde: ");
 722   1        IngresaDato(buffer,0);
 723   1        printf("\r\n\n Hora Programada Desde: ");
 724   1        wr_eeprom(0xa8, addr + Hora_High_addr_Desde,buffer[Hora_High_data]);
 725   1        dataee = rd_eeprom(0xa8,addr + Hora_High_addr_Desde);
 726   1        printf("%c",dataee);
 727   1        wr_eeprom(0xa8,addr + Hora_Low_addr_Desde ,buffer[Hora_Low_data]);
 728   1        dataee = rd_eeprom(0xa8,addr + Hora_Low_addr_Desde); //
 729   1        printf("%c:",dataee);
 730   1        wr_eeprom(0xa8,addr + Minutos_High_addr_Desde,buffer[Minutos_High_data]);
 731   1        dataee = rd_eeprom(0xa8,addr + Minutos_High_addr_Desde);
 732   1        printf("%c",dataee);
 733   1        wr_eeprom(0xa8,addr + Minutos_Low_addr_Desde,buffer[Minutos_Low_data]);
 734   1        dataee = rd_eeprom(0xa8,addr +  Minutos_Low_addr_Desde);
 735   1        printf("%c",dataee);
 736   1      
 737   1      /*la hora de final del horario*/
 738   1      
 739   1        printf("\r\n\n Digite Hora:Minutos Hasta: ");
 740   1        IngresaDato(buffer,0);
 741   1        
 742   1        printf("\r\n\n Hora Programada Hasta: ");
 743   1      
 744   1        wr_eeprom(0xa8,addr + Hora_High_addr_Hasta,buffer[Hora_High_data]);
 745   1        dataee = rd_eeprom(0xa8,addr + Hora_High_addr_Hasta);
 746   1        printf("%c",dataee);
 747   1        wr_eeprom(0xa8,addr + Hora_Low_addr_Hasta ,buffer[Hora_Low_data]);
 748   1        dataee = rd_eeprom(0xa8,addr + Hora_Low_addr_Hasta);
 749   1        printf("%c:",dataee);
 750   1        wr_eeprom(0xa8,addr + Minutos_High_addr_Hasta,buffer[Minutos_High_data]);
 751   1        dataee = rd_eeprom(0xa8,addr + Minutos_High_addr_Hasta);
 752   1        printf("%c",dataee);
 753   1        wr_eeprom(0xa8,addr + Minutos_Low_addr_Hasta ,buffer[Minutos_Low_data]);
 754   1        dataee = rd_eeprom(0xa8,addr + Minutos_Low_addr_Hasta);
 755   1        printf("%c",dataee);
 756   1      }
 757          void Ver_Horario_Desde_Hasta(unsigned int addr)
 758          {
 759   1        unsigned char dataee;
 760   1        printf("\r\n Desde  Hasta\r\n");
 761   1        dataee = rd_eeprom(0xa8,addr + Hora_High_addr_Desde);
 762   1        printf(" %c",dataee);
 763   1        dataee = rd_eeprom(0xa8,addr + Hora_Low_addr_Desde); //
 764   1        printf("%c:",dataee);
 765   1        dataee = rd_eeprom(0xa8,addr + Minutos_High_addr_Desde);
 766   1        printf("%c",dataee);
 767   1        dataee = rd_eeprom(0xa8,addr +  Minutos_Low_addr_Desde);
 768   1        printf("%c   ",dataee); 
 769   1          /*hasta*/
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 14  

 770   1        dataee = rd_eeprom(0xa8,addr + Hora_High_addr_Hasta);
 771   1        printf("%c",dataee);
 772   1        
 773   1        dataee = rd_eeprom(0xa8,addr + Hora_Low_addr_Hasta);
 774   1        printf("%c:",dataee);
 775   1        
 776   1        dataee = rd_eeprom(0xa8,addr + Minutos_High_addr_Hasta);
 777   1        printf("%c",dataee);
 778   1        
 779   1        dataee = rd_eeprom(0xa8,addr + Minutos_Low_addr_Hasta);
 780   1        printf("%c",dataee);
 781   1      }
 782          void Prog_Horario_dias(unsigned int addr)
 783          {
 784   1        unsigned char buffer[10];
 785   1        unsigned char dataee, j, temp;
 786   1        /*los dias programados*/
 787   1        printf("\r\n\n Digite los dias a programar Lunes = 2, ");
 788   1        printf("Martes = 3, Miercoles = 4, Jueves = 5, ");
 789   1        printf("Viernes = 6, Sabado = 7, Domingo = 1 : ");
 790   1        IngresaDato(buffer,0);
 791   1        
 792   1        
 793   1        printf("\r\n\n Dias Programados : ");
 794   1        
 795   1        for(j=0; j < 8 ; j++)
 796   1        {
 797   2          
 798   2          if ((temp=buffer[j]) == Lunes_dato) 
 799   2          {
 800   3            printf(" Lunes");
 801   3          
 802   3            wr_eeprom(0xa8,addr+Lunes_addr,Lunes_dato); 
 803   3            dataee=rd_eeprom(0xa8,addr+Lunes_addr); 
 804   3            printf("= %c,",dataee);
 805   3          }
 806   2          
 807   2          if ((temp=buffer[j]) == Martes_dato)
 808   2          {
 809   3            printf(" Martes");
 810   3            wr_eeprom(0xa8,addr+Martes_addr,Martes_dato);
 811   3            dataee=rd_eeprom(0xa8,addr+Martes_addr);  
 812   3            printf("= %c,",dataee);
 813   3          }
 814   2        
 815   2          if ((temp=buffer[j])== Miercoles_dato)
 816   2          {
 817   3            printf(" Miercoles");
 818   3            wr_eeprom(0xa8,addr+Miercoles_addr,Miercoles_dato);
 819   3            dataee=rd_eeprom(0xa8,addr+Miercoles_addr); 
 820   3            printf("= %c,",dataee);
 821   3          }
 822   2          
 823   2          if ((temp=buffer[j]) == Jueves_dato)
 824   2          {
 825   3            printf(" Jueves");
 826   3            wr_eeprom(0xa8,addr+Jueves_addr,Jueves_dato);
 827   3            dataee=rd_eeprom(0xa8,addr+Jueves_addr);  
 828   3            printf("= %c,",dataee);
 829   3          }
 830   2          
 831   2          if ((temp=buffer[j]) == Viernes_dato)
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 15  

 832   2          { 
 833   3            printf(" Viernes");
 834   3            wr_eeprom(0xa8,addr+Viernes_addr,Viernes_dato);
 835   3            dataee=rd_eeprom(0xa8,addr+Viernes_addr); 
 836   3            printf("= %c,",dataee);
 837   3          }
 838   2          
 839   2          if ((temp=buffer[j]) == Sabado_dato) 
 840   2          {
 841   3            printf(" Sabado");
 842   3            wr_eeprom(0xa8,addr+Sabado_addr,Sabado_dato);
 843   3            dataee=rd_eeprom(0xa8,addr+Sabado_addr);  
 844   3            printf("= %c,",dataee);
 845   3          }
 846   2          
 847   2          if ((temp=buffer[j]) == Domingo_dato)
 848   2          {
 849   3            printf(" Domingo");
 850   3            wr_eeprom(0xa8,addr+Domingo_addr,Domingo_dato);
 851   3            dataee = rd_eeprom(0xa8,addr+Domingo_addr); 
 852   3            printf("= %c",dataee);
 853   3          }
 854   2        }
 855   1        
 856   1      }
 857          void Ver_Horario_dias(unsigned int addr)
 858          {
 859   1        unsigned char dataee;
 860   1        /*Lunes*/
 861   1        dataee=rd_eeprom(0xa8,addr+Lunes_addr); 
 862   1          if(dataee == Lunes_dato)
 863   1          {
 864   2          printf(" Lunes = Programado\r\n");
 865   2          }
 866   1          else
 867   1          {
 868   2          printf(" Lunes = No programado\r\n");
 869   2          }
 870   1          /*Martes*/
 871   1          
 872   1          dataee=rd_eeprom(0xa8,addr+Martes_addr);  
 873   1          if(dataee == Martes_dato)
 874   1          {
 875   2          printf(" Martes = Programado\r\n");
 876   2          }
 877   1          else
 878   1          {
 879   2          printf(" Martes = No programado\r\n");
 880   2          }
 881   1          
 882   1          /*Miercoles*/
 883   1          dataee=rd_eeprom(0xa8,addr+Miercoles_addr); 
 884   1          if(dataee == Miercoles_dato)
 885   1          {
 886   2          printf(" Miercoles = Programado\r\n");
 887   2          }
 888   1          else
 889   1          {
 890   2          printf(" Miercoles = No programado\r\n");
 891   2          }
 892   1          /*Jueves*/
 893   1            dataee=rd_eeprom(0xa8,addr+Jueves_addr);  
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 16  

 894   1          if(dataee == Jueves_dato)
 895   1          {
 896   2          printf(" Jueves = Programado\r\n");
 897   2          }
 898   1          else
 899   1          {
 900   2          printf(" Jueves = No programado\r\n");
 901   2          }
 902   1          /*Viernes*/
 903   1            dataee=rd_eeprom(0xa8,addr+Viernes_addr); 
 904   1          if(dataee == Viernes_dato)
 905   1          {
 906   2          printf(" Viernes = Programado\r\n");
 907   2          }
 908   1          else
 909   1          {
 910   2          printf(" Viernes = No programado\r\n");
 911   2          }
 912   1          /*Sabado*/
 913   1          
 914   1            dataee=rd_eeprom(0xa8,addr+Sabado_addr);  
 915   1          if(dataee == Sabado_dato)
 916   1          {
 917   2          printf(" Sabado = Programado\r\n");
 918   2          }
 919   1          else
 920   1          {
 921   2          printf(" Sabado = No programado\r\n");
 922   2          }
 923   1          /*Domingo*/
 924   1          dataee=rd_eeprom(0xa8,addr+Domingo_addr); 
 925   1          if(dataee == Domingo_dato)
 926   1          {
 927   2          printf(" Domingo = Programado\r\n");
 928   2          }
 929   1          else
 930   1          {
 931   2          printf(" Domingo = No programado\r\n");
 932   2          }
 933   1      }
 934          void Prog_Horarios()
 935          {
 936   1        unsigned char buffer[10];
 937   1        unsigned char ee_addr_horario[11];
 938   1        unsigned int addr,temp;
 939   1        unsigned char dataee;
 940   1        unsigned char j;
 941   1        
 942   1        /*direcciones de memoria de almacenamiento*/
 943   1        
 944   1          strcpy (ee_addr_horario,(Addr_Horarios()));
 945   1          
 946   1        /*se programa el banco de horarios del 1 al 10*/
 947   1        
 948   1        printf("\r\n\n Digite el numero del Horario a programar = ");   
 949   1        IngresaDato(buffer,0);  
 950   1        
 951   1        j=(atoi(buffer)) - 1;
 952   1        
 953   1        /*mi direccion eeprom*/
 954   1        
 955   1        addr= ee_addr_horario[j];
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 17  

 956   1        temp= addr;
 957   1        
 958   1        /*habilita o desabilita el uso del horario*/
 959   1        
 960   1        addr =addr + Habilita_addr ;
 961   1        if (Prog_Horarios_on_off(addr) == True);
 962   1        {
 963   2          /*limpiar la memoria*/
 964   2        addr= temp;
 965   2          for(j=Lunes_addr; j < 8 ; j++)
 966   2          {
 967   3            wr_eeprom(0xa8,addr+j,0xff);
 968   3          }
 969   2        
 970   2        addr= temp;
 971   2        /*los dias programados*/
 972   2        
 973   2        Prog_Horario_dias(addr);
 974   2          
 975   2        /*la hora de inicio del horario*/
 976   2        
 977   2        Prog_Horario_Desde_Hasta(addr);
 978   2        
 979   2        /*programo si hay segundo horario*/
 980   2        printf("\r\n\n Programar segundo Horario si=(1) no=(0)= ");   
 981   2        IngresaDato(buffer,0);
 982   2        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 983   2        wr_eeprom(0xa8,addr+Segundo_Tiempo,dataee);                                         /*grabo el dato en la eeprom*/
 984   2        
 985   2        dataee=rd_eeprom(0xa8,addr+Segundo_Tiempo);                                       /*leo el dato grabado*/
 986   2        sprintf(buffer,"%d",dataee);  
 987   2          if(dataee==True)
 988   2          {
 989   3            /*la hora de inicio del segundo horario*/
 990   3            addr =addr + Minutos_Low_addr_Desde ;
 991   3            Prog_Horario_Desde_Hasta(addr);
 992   3          }
 993   2        }
 994   1        
 995   1      }
 996          void Prog_Validar_Tipo_Vehiculo_Mensual() 
 997          {
 998   1        unsigned char buffer[10];
 999   1        unsigned int dataee;
1000   1      
1001   1        
1002   1        dataee=rd_eeprom(0xa8,EE_VALIDA_TIPO_VEHICULO_MENSUAL);                                         /*se lee el id_cliente actual
             - */
1003   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1004   1        if(dataee==0)
1005   1        {
1006   2          printf("\r\n\n ACTUAL TIPO_VEHICULO MENSUAL INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el
             - id_cliente actual en pantalla*/
1007   2        }
1008   1        else
1009   1        {
1010   2          printf("\r\n\n ACTUAL TIPO_VEHICULO MENSUAL HABILITADO=%s\r\n\n",buffer);     
1011   2        }
1012   1        
1013   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE TIPO_VEHICULO MENSUAL=");                                  /*digite el nuevo id_c
             -liente*/
1014   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 18  

1015   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
1016   1        wr_eeprom(0xa8,EE_VALIDA_TIPO_VEHICULO_MENSUAL,dataee);                                         /*grabo el dato en la eeprom*
             -/
1017   1        
1018   1        dataee=rd_eeprom(0xa8,EE_VALIDA_TIPO_VEHICULO_MENSUAL);                                       /*leo el dato grabado*/
1019   1        sprintf(buffer,"%d",dataee);  
1020   1        if(dataee==0)
1021   1        {
1022   2          printf("\r\n\n ACTUAL TIPO_VEHICULO MENSUAL INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el
             - id_cliente actual en pantalla*/
1023   2        }
1024   1        else
1025   1        {
1026   2          printf("\r\n\n ACTUAL TIPO_VEHICULO  MENSUAL HABILITADO=%s\r\n\n",buffer);      
1027   2        }
1028   1      }
1029          void Prog_Apb_Mensual()
1030          {
1031   1        unsigned char buffer[10];
1032   1        unsigned int dataee;
1033   1      
1034   1        
1035   1        dataee=rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL);                                         /*se lee el id_cliente actual */
1036   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1037   1        if(dataee==0)
1038   1        {
1039   2          printf("\r\n\n ACTUAL ANTIPASSBACK MENSUAL INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el 
             -id_cliente actual en pantalla*/
1040   2        }
1041   1        else
1042   1        {
1043   2          printf("\r\n\n ACTUAL ANTIPASSBACK MENSUAL HABILITADO=%s\r\n\n",buffer);      
1044   2        }
1045   1        
1046   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE ANTIPASSBACK MENSUAL=");                                 /*digite el nuevo id_cl
             -iente*/
1047   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
1048   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
1049   1        wr_eeprom(0xa8,EE_HABILITA_APB_MENSUAL,dataee);                                         /*grabo el dato en la eeprom*/
1050   1        
1051   1        dataee=rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL);                                       /*leo el dato grabado*/
1052   1        sprintf(buffer,"%d",dataee);  
1053   1        if(dataee==0)
1054   1        {
1055   2          printf("\r\n\n ACTUAL ANTIPASSBACK MENSUAL INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el 
             -id_cliente actual en pantalla*/
1056   2        }
1057   1        else
1058   1        {
1059   2          printf("\r\n\n ACTUAL ANTIPASSBACK  MENSUAL HABILITADO=%s\r\n\n",buffer);     
1060   2        }
1061   1      }
1062          
1063          void Prog_fecha_vencimiento()
1064          {
1065   1        unsigned char buffer[11];
1066   1        unsigned char *cmd;
1067   1        
1068   1        unsigned char fecha[7];
1069   1        unsigned int dataee;
1070   1      
1071   1        LeerMemoria(EE_FECHA_VENCIMIENTO,buffer);   
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 19  

1072   1           hex_ascii(buffer,fecha);
1073   1                                    
1074   1        
1075   1        printf("\r\n\n ACTUAL FECHA VENCIMIENTO PASSWORD:%s\r\n\n",fecha);                            /*se muestra el id_client
             -e actual en pantalla*/
1076   1          
1077   1         do{
1078   2        printf("\r\n\n/>Id Registro:");
1079   2        LeerMemoria(EE_ID_REGISTER,buffer);
1080   2        printf("%s", buffer);
1081   2        strcpy (validacion,hash_id(buffer));
1082   2        printf("\r\n\n/>Password:");
1083   2        
1084   2          /*para pruebas*/
1085   2        //printf("\r\n\%s ", validacion);
1086   2          
1087   2        IngresaDato(buffer,1);          //ingreso el password por teclado 
1088   2        cmd = GetCMD(buffer);         //quita el carri return 
1089   2        EscribirMemoria(EE_ID_REGISTER,validacion);
1090   2      
1091   2        }while(ValidarClave(cmd)!=0);
1092   1        
1093   1        
1094   1        printf("\r\n\n DIGITE LA NUEVA FECHA DE VENCIMIENTO=");                                 /*digite el nuevo id_cliente*/
1095   1        IngresaDato(buffer,0);  
1096   1        printf("\r\n\n %s\r\n\n",buffer); 
1097   1        
1098   1          fecha[0]=buffer[0]; 
1099   1          fecha[1]=buffer[1]; 
1100   1          fecha[2]=0; 
1101   1          
1102   1          dataee=atoi(fecha);
1103   1          printf("\r\n\n %X",dataee); 
1104   1        /*lo convierto a un dato hex*/
1105   1         wr_eeprom(0xa8,EE_FECHA_VENCIMIENTO,dataee);                                         /*grabo el dato en la eeprom*/
1106   1          fecha[0]=buffer[2]; 
1107   1          fecha[1]=buffer[3]; 
1108   1          fecha[2]=0; 
1109   1          dataee=atoi(fecha);
1110   1          printf("\r\n\n %X",dataee); 
1111   1          wr_eeprom(0xa8,EE_FECHA_VENCIMIENTO+1,dataee);
1112   1          fecha[0]=buffer[4]; 
1113   1          fecha[1]=buffer[5]; 
1114   1          fecha[2]=0; 
1115   1          dataee=atoi(fecha); 
1116   1          printf("\r\n\n %X",dataee);     
1117   1          wr_eeprom(0xa8,EE_FECHA_VENCIMIENTO+2,dataee);
1118   1          wr_eeprom(0xa8,EE_FECHA_VENCIMIENTO+3,0);
1119   1          
1120   1          LeerMemoria(EE_FECHA_VENCIMIENTO,buffer);
1121   1          
1122   1          hex_ascii(buffer,fecha);  
1123   1          printf("\r\n\n ACTUAL FECHA DE VENCIMIENTO PROGRAMADA =%s\r\n\n",fecha);  
1124   1        
1125   1      }
1126          void Ver_Horario()
1127          {
1128   1        unsigned char buffer[10];
1129   1        unsigned char ee_addr_horario[11];
1130   1        unsigned char conta;
1131   1        
1132   1        unsigned int addr,temp;
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 20  

1133   1        unsigned char dataee;
1134   1        /*direcciones de memoria de almacenamiento*/
1135   1        
1136   1        strcpy (ee_addr_horario,(Addr_Horarios()));
1137   1        for (conta=0;conta < 10 ; conta++)
1138   1        {
1139   2        
1140   2        printf("\r\n numero del Horario  programado = %c\r\n",conta+49);
1141   2          
1142   2        /*HORARIO HABILITADO O INHABILITADO*/
1143   2        addr= ee_addr_horario[conta];
1144   2        temp= addr;
1145   2          /*habilita o desabilita el uso del horario*/
1146   2        
1147   2        addr =addr + Habilita_addr ;
1148   2        dataee = rd_eeprom(0xa8,addr);                                          /*se lee el id_cliente actual */
1149   2        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1150   2          if(dataee == 1)
1151   2          {
1152   3          printf("\r\n  HORARIO HABILITADO  = ON\r\n");                           /*se muestra el id_cliente actual en pantalla
             -*/
1153   3          
1154   3          printf("\r\n Dias Programados\r\n");
1155   3        addr=temp;
1156   3        Ver_Horario_dias(addr);
1157   3        
1158   3        Ver_Horario_Desde_Hasta(addr);
1159   3        dataee=rd_eeprom(0xa8,addr+Segundo_Tiempo);                                       /*leo el dato grabado*/
1160   3        sprintf(buffer,"%d",dataee);  
1161   3            if(dataee==True)
1162   3            {
1163   4            printf("\r\n  SEGUNDO HORARIO HABILITADO  = ON\r\n");
1164   4            /*la hora de inicio del segundo horario*/
1165   4            addr =addr + Minutos_Low_addr_Desde ;
1166   4            Ver_Horario_Desde_Hasta(addr);
1167   4            }
1168   3            else
1169   3            {
1170   4            printf("\r\n SEGUNDO HORARIO HABILITADO  = OFF\r\n");
1171   4            }
1172   3          }
1173   2          else
1174   2          {
1175   3          printf("\r\n  HORARIO HABILITADO  = OFF\r\n");      
1176   3          }
1177   2          
1178   2        }
1179   1        
1180   1          
1181   1      }
1182          void Prog_mensuales()
1183          {
1184   1        unsigned char buffer[10];
1185   1        unsigned int dataee;
1186   1      
1187   1        
1188   1        dataee=rd_eeprom(0xa8,EE_MENSUAL_BOCA_ON_OFF);                                          /*se lee el id_cliente actual */
1189   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1190   1        if(dataee==0)
1191   1        {
1192   2          printf("\r\n\n ACTUAL MENSUAL POR BOCA INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el id_c
             -liente actual en pantalla*/
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 21  

1193   2        }
1194   1        else
1195   1        {
1196   2          printf("\r\n\n ACTUAL MENSUAL POR BOCA HABILITADO=%s\r\n\n",buffer);      
1197   2        }
1198   1        
1199   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DEL MENSUAL=");                                 /*digite el nuevo id_cliente*/
1200   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
1201   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
1202   1        wr_eeprom(0xa8,EE_MENSUAL_BOCA_ON_OFF,dataee);                                          /*grabo el dato en la eeprom*/
1203   1        
1204   1        dataee=rd_eeprom(0xa8,EE_MENSUAL_BOCA_ON_OFF);                                        /*leo el dato grabado*/
1205   1        sprintf(buffer,"%d",dataee);  
1206   1        if(dataee==0)
1207   1        {
1208   2          printf("\r\n\n ACTUAL MENSUAL POR BOCA INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el id_c
             -liente actual en pantalla*/
1209   2        }
1210   1        else
1211   1        {
1212   2          printf("\r\n\n ACTUAL MENSUAL POR BOCA HABILITADO=%s\r\n\n",buffer);      
1213   2        }
1214   1        
1215   1      }
1216          
1217          void Ver_Prog()
1218          {
1219   1        unsigned char buffer[10];
1220   1        unsigned int dataee;
1221   1        unsigned char fecha[7];
1222   1        
1223   1        
1224   1        dataee=rd_eeprom(0xa8,EE_ID_CLIENTE);                                         /*se lee el id_cliente actual */
1225   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1226   1        /*ID programado*/
1227   1        printf("\r\n ID_CLIENTE_PROGRAMADO = %s\r\n",buffer);   
1228   1        /*codigo de parkeadero*/
1229   1        dataee=rd_eeprom(0xa8,EE_ID_PARK);                                          /*se lee el id_cliente actual */
1230   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1231   1        
1232   1        printf("\r\n COD_PARK_PROGRAMADO = %s\r\n",buffer);     
1233   1        /*estado de debug*/
1234   1        dataee=rd_eeprom(0xa8,EE_DEBUG);                                          /*se lee el id_cliente actual */
1235   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1236   1        if(dataee==1)
1237   1        {
1238   2          printf("\r\n PROGRAMADO DEBUG = ON\r\n"); 
1239   2        } 
1240   1        else
1241   1        {
1242   2          printf("\r\n PROGRAMADO DEBUG = OFF\r\n");  
1243   2        } 
1244   1        /*Estado del lpr*/
1245   1        dataee=rd_eeprom(0xa8,EE_USE_LPR);                                          /*se lee el id_cliente actual */
1246   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1247   1        if(dataee==0)
1248   1        {
1249   2          printf("\r\n USE_LPR = OFF\r\n");                           /*se muestra el id_cliente actual en pantalla*/
1250   2        }
1251   1        else
1252   1        {
1253   2          printf("\r\n USE_LPR = ON\r\n");      
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 22  

1254   2        }
1255   1        /*Tipo de pantalla*/
1256   1        dataee=rd_eeprom(0xa8,EE_TIPO_PANTALLA);                                          /*se lee el id_cliente actual */
1257   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1258   1        if(dataee==0)
1259   1        {
1260   2          printf("\r\n PANTALLA LCD PROGRAMADA\r\n");                           /*se muestra el id_cliente actual en pantalla*/
1261   2        }
1262   1        else
1263   1        {
1264   2          printf("\r\n PANTALLA RASPBERRY  PROGRAMADA\r\n");      
1265   2        }
1266   1        /*MODOde expedicion de tarjeta*/
1267   1        dataee=rd_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON);                               //se lee LA CONFIGURACION 
1268   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1269   1        if(dataee==0)
1270   1        {
1271   2          printf("\r\n EXPIDE TARJETA PULSANDO BOTON\r\n");                           /*se muestra el id_cliente actual en pant
             -alla*/
1272   2        }
1273   1        else
1274   1        {
1275   2          printf("\r\n EXPIDE TARJETA AUTOMATICA\r\n");     
1276   2        }
1277   1        /*APB*/
1278   1        dataee=rd_eeprom(0xa8,EE_HABILITA_APB);                                         /*se lee el id_cliente actual */
1279   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1280   1        if(dataee==0)
1281   1        {
1282   2          printf("\r\n  ANTIPASSBACK = OFF\r\n");                           /*se muestra el id_cliente actual en pantalla*/
1283   2        }
1284   1        else
1285   1        {
1286   2          printf("\r\n ANTIPASSBACK = ON\r\n");     
1287   2        }
1288   1        /*PLACA*/
1289   1        dataee=rd_eeprom(0xa8,EE_PLACA);                                          /*se lee el id_cliente actual */
1290   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1291   1        if(dataee==0)
1292   1        {
1293   2          printf("\r\n PLACA = OFF\r\n");                           /*se muestra el id_cliente actual en pantalla*/
1294   2        }
1295   1        else
1296   1        {
1297   2          printf("\r\n PLACA = ON\r\n");      
1298   2        }
1299   1        
1300   1        /*DIRECCION*/
1301   1        dataee=rd_eeprom(0xa8,EE_ADDRESS_HIGH_BOARD);                                         /*se lee el id_cliente actual */
1302   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1303   1        
1304   1          printf("\r\n ACTUAL ADDRESS_HIGH_BOARD = %s\r\n",buffer);                           /*se muestra el id_cliente actual
             - en pantalla*/
1305   1        /*horarios Programados*/
1306   1         Ver_Horario();
1307   1        
1308   1        /*VALIDA TIPO DE VEHICULO EN MENSUAL*/
1309   1        
1310   1        dataee=rd_eeprom(0xa8,EE_VALIDA_TIPO_VEHICULO_MENSUAL);                                         /*se lee el id_cliente actual
             - */
1311   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1312   1        if(dataee==0)
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 23  

1313   1        {
1314   2          printf("\r\n TIPO_VEHICULO MENSUAL = OFF\r\n");                           /*se muestra el id_cliente actual en pantal
             -la*/
1315   2        }
1316   1        else
1317   1        {
1318   2          printf("\r\n TIPO_VEHICULO MENSUAL = ON\r\n");      
1319   2        }
1320   1        /*APB MENSUAL*/
1321   1        dataee=rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL);                                         /*se lee el id_cliente actual */
1322   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1323   1        if(dataee==0)
1324   1        {
1325   2          printf("\r\n ANTIPASSBACK MENSUAL = OFF\r\n");                            /*se muestra el id_cliente actual en pantall
             -a*/
1326   2        }
1327   1        else
1328   1        {
1329   2          printf("\r\n  ANTIPASSBACK MENSUAL = ON\r\n");      
1330   2        }
1331   1          
1332   1        /*MENSUAL POR BOCA */
1333   1        dataee=rd_eeprom(0xa8,EE_MENSUAL_BOCA_ON_OFF);                                          /*se lee el id_cliente actual */
1334   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1335   1        if(dataee==0)
1336   1        {
1337   2          printf("\r\nMENSUAL POR BOCA = OFF\r\n");                           /*se muestra el id_cliente actual en pantalla*/
1338   2        }
1339   1        else
1340   1        {
1341   2          printf("\r\n  MENSUAL POR BOCA = ON\r\n");      
1342   2        }
1343   1        
1344   1        /*Fecha de vencimiento clave*/
1345   1        LeerMemoria(EE_FECHA_VENCIMIENTO,buffer);
1346   1          
1347   1          hex_ascii(buffer,fecha);  
1348   1          printf("\r\n ACTUAL FECHA DE VENCIMIENTO PROGRAMADA =%s\r\n",fecha);  
1349   1        /*numero de ticket programado*/
1350   1        
1351   1        strcpy(buffer, Lee_No_Ticket());
1352   1        printf("\r\n Numero de ticket =%s\r\n",buffer); 
1353   1      
1354   1      }
1355          
1356          /*------------------------------------------------------------------------------
1357          Rutina que muestra la lista de comandos
1358          ------------------------------------------------------------------------------*/
1359          void Show()
1360          {
1361   1         printf("\r\n ID_CLIENTE         --- CMD 0 Identificador del cliente maximo 255");
1362   1         printf("\r\n COD_PARK           --- CMD 1 El numero del parqueadero maximo 255");
1363   1         printf("\r\n T_GRACIA           --- CMD 2 Tiempo sin cobro 00,  maximo 255");
1364   1         printf("\r\n SIN_COBRO          --- CMD 3 Inhabilitado= 0, Gratis= 1 , Gratis y salida el mismo dia= 2"
             -);
1365   1         printf("\r\n DEBUG              --- CMD 4 Habilitar = 1, Inhabilitar = 0");
1366   1         printf("\r\n USE_LPR            --- CMD 5 Habilitar = 1, Inhabilitar = 0");
1367   1         printf("\r\n TIPO_PANTALLA      --- CMD 6 PANTALLA LCD =0 PANTALLA RASPBERRI=1");
1368   1         printf("\r\n CARD_AUTOMATICA    --- CMD 7 BOTTON=0 AUTOMATICA=1");
1369   1         printf("\r\n ANTIPASSBACK       --- CMD 8 Habilitar = 1, Inhabilitar = 0");
1370   1         printf("\r\n PLACA              --- CMD 9 Habilitar = 1, Inhabilitar = 0");
1371   1         printf("\r\n ADDRESS_HIGH_BOARD --- CMD 10 La direccion alta del board del numero 5 al 9 sino se usa deb
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 24  

             -e ir en 0");
1372   1         printf("\r\n HORARIO            --- CMD 11 Progama 10 horarios del 1 al 10");
1373   1         printf("\r\n VALIDA_VEHI_MENSUAL--- CMD 12 Habilitar = 1, Inhabilitar = 0");
1374   1         printf("\r\n USE_APB_MENSUAL    --- CMD 13 Habilitar = 1, Inhabilitar = 0");
1375   1         printf("\r\n MENSUALES          --- CMD 14 Habilitar = 1, Inhabilitar = 0");
1376   1         printf("\r\n VER_PROGRAMACION   --- CMD 15 Muestra la programacion");
1377   1         printf("\r\n AYUDA              --- CMD 16 Muestra los comandos");
1378   1         printf("\r\n SALIR              --- CMD 17 Salir de programacion");
1379   1      
1380   1      }
1381          
1382          /*------------------------------------------------------------------------------
1383          Rutina de principal de programacion
1384          ------------------------------------------------------------------------------*/
1385          void  First_Clave()
1386          {
1387   1        unsigned char clave[11];
1388   1        
1389   1        
1390   1          Block_read_clock_ascii(clave);
1391   1          clave[10] = 0;
1392   1          strcpy (validacion,hash_id(clave));
1393   1          EscribirMemoria(EE_ID_REGISTER,validacion);
1394   1          validacion[0]=0x14;
1395   1          validacion[0]=0x0B;
1396   1          validacion[0]=0x14;
1397   1          validacion[0]=0;
1398   1          
1399   1          EscribirMemoria(EE_FECHA_VENCIMIENTO,validacion);
1400   1        
1401   1        
1402   1      }
1403          void menu(void)
1404          {
1405   1      
1406   1      unsigned char *cmd,*option1,*option2;
1407   1      unsigned char opt_buffer[40];
1408   1      unsigned char buffer[20];
1409   1      unsigned char dato;
1410   1      
1411   1      
1412   1      
1413   1        
1414   1        printf("\r\n\nSistema de Programacion Expedidor \r\n\r\n");
1415   1      
1416   1      
1417   1        
1418   1        
1419   1        if(rd_eeprom(0xa8,EE_JUST_ONE_TIME_CLAVE) != False) 
1420   1        {
1421   2          First_Clave();  
1422   2          wr_eeprom(0xa8,EE_JUST_ONE_TIME_CLAVE,0x0);
1423   2          //printf("%s", buffer);
1424   2        
1425   2        }
1426   1       
1427   1        do{
1428   2        printf("\r\n\n/>Id Registro:");
1429   2        LeerMemoria(EE_ID_REGISTER,buffer);
1430   2        buffer[10]=0;
1431   2        printf("%s", buffer);
1432   2        strcpy (validacion,hash_id(buffer));
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 25  

1433   2        printf("\r\n\n/>Password:");
1434   2        
1435   2          /*para pruebas*/
1436   2        //printf("\r\n\%s ", validacion);
1437   2          
1438   2        IngresaDato(buffer,0);          //ingreso el password por teclado 
1439   2        cmd = GetCMD(buffer);         //quita el carri return 
1440   2        EscribirMemoria(EE_ID_REGISTER,validacion);
1441   2      
1442   2        }while(ValidarClave(cmd)!=0);       //
1443   1      
1444   1        //EscribirMemoria(EE_ID_REGISTER,validacion);
1445   1        dato=rd_eeprom(0xa8,EE_BAUDIO);
1446   1        if(dato == 0xff )
1447   1        {
1448   2        Show();
1449   2        }
1450   1        else
1451   1        {
1452   2          printf("\r\nValidando Comandos");
1453   2          wr_eeprom(0xa8,EE_BAUDIO,0);
1454   2        }
1455   1        while(1)
1456   1        {
1457   2        DisplayCursor();
1458   2      
1459   2      
1460   2          IngresaDato(buffer,0);  
1461   2          cmd = GetCMD(buffer); 
1462   2          option1 = GetOption(cmd + strlen(cmd) + 1);
1463   2          option2 = GetOption(option1 + strlen(option1) + 1);  
1464   2      
1465   2         //si empieza con un '/', eso significa que incluye el caminoa
1466   2            //al archivo.  si el archivo no empieza con un '/', debe agregarce 
1467   2            //la ruta del archivo.
1468   2            if (option1 && (option1[0]=='/'))
1469   2            {
1470   3               //option1 is a full path
1471   3               strcpy(opt_buffer, option1);
1472   3            }
1473   2            else if (option1)
1474   2            {
1475   3               // tack on the current working directory to option1
1476   3               strcpy(opt_buffer, cursor);
1477   3               strcat(opt_buffer, option1);
1478   3            }         
1479   2      
1480   2      
1481   2      
1482   2      
1483   2      
1484   2          if (cmd)
1485   2            {
1486   3               switch(ListaComandos(cmd))
1487   3               {
1488   4                  case 0:                     /*Se programa la identificacion del cliente*/
1489   4                    prog_id_cliente();
1490   4                  
1491   4                   break;
1492   4                  
1493   4                  case 1:  //Tiempo de recolecion entre muestra
1494   4                    prog_cod_park();
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 26  

1495   4                  break;
1496   4                  case 2:  //Informacion recolectada enviada al rs232
1497   4                    Prog_tiempo_gracia();
1498   4                  break;
1499   4                  case 3:  //Ajuste del cero del sensor
1500   4                    Prog_Sin_Cobro();
1501   4                  break;
1502   4                  case 4:  //Ajuste de calibracion por medio de la pendiente
1503   4                    Prog_debug();
1504   4                  break;
1505   4                  case 5:  //help me
1506   4                    Prog_Use_Lpr();
1507   4                     break;
1508   4                  case 6:     //tipo de pantalla
1509   4                    tipo_pantalla();
1510   4                  break;
1511   4                  case 7:     //tarjeta automatica o pulsador
1512   4                    Prog_tarjeta_automatica_o_boton();
1513   4                  break;
1514   4                  case 8:  //cmd antipassback
1515   4                    Prog_AntiPassBack();
1516   4                  break;
1517   4                  case 9:   //cmd placa
1518   4                    Prog_Placa();
1519   4                  break;
1520   4                  case 10:    //cmd configuracion de la direccion del board
1521   4                    Prog_Address_High_Board();
1522   4                  break;
1523   4                  case 11:    //cmd configuracion los horarios
1524   4                    Prog_Horarios();
1525   4                  break;
1526   4                  case 12:    //cmd configuracion los horarios
1527   4                    Prog_Validar_Tipo_Vehiculo_Mensual();
1528   4                  break;
1529   4                  case 13:    //cmd configuracion los horarios
1530   4                    Prog_Apb_Mensual();
1531   4                  break;
1532   4                  
1533   4                  case 14:  //configura los mensuales por boca
1534   4                    Prog_mensuales();
1535   4                  break;
1536   4                  case 15:  //help me
1537   4                    Ver_Prog();
1538   4                  break;
1539   4                  case 16:  //help me
1540   4                    Show();
1541   4                  break;
1542   4                  case 17:  //salir
1543   4                    return;
1544   4                  break;
1545   4                  case 18:
1546   4                    Prog_fecha_vencimiento();
1547   4                    break;
1548   4                
1549   4                
1550   4                  default:
1551   4                     printf("\r\nComando no existe '%s'", cmd);
1552   4                     break;
1553   4              }
1554   3            }
1555   2        }
1556   1      }
C51 COMPILER V9.59.0.0   PROG                                                              09/02/2021 16:32:26 PAGE 27  

1557          
1558            
1559          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   9400    ----
   CONSTANT SIZE    =   5168    ----
   XDATA SIZE       =     92     509
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
