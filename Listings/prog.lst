C51 COMPILER V9.59.0.0   PROG                                                              05/21/2020 14:05:11 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE PROG
OBJECT MODULE PLACED IN .\Objects\prog.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE prog.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\prog.lst) TABS(2) OBJECT(.\Objects\prog.obj)

line level    source

   1          
   2          #include "prog.h" 
   3          #include <string.h>
   4          extern int printf   (const char *, ...);
   5          extern char putchar (char);
   6          extern char getchar (void);
   7          extern char  *strtok  (char *str, const char *set);
   8          extern char   strcmp  (const char *s1, const char *s2);
   9          extern char  *strcpy  (char *s1, const char *s2);
  10          extern char _getkey (void);
  11          extern char  *strcat  (char *s1, const char *s2);
  12          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  13          extern void wr_eeprom (unsigned char control,unsigned int Dir, unsigned char data_eeprom);
  14          extern int sprintf  (char *, const char *, ...);
  15          extern int    atoi (const char *s1);
  16          
  17          unsigned char cursor[20] = "/"; //current working directory
  18          unsigned char validacion [9]={"admin"}; //usuario
  19          
  20          
  21          
  22          
  23          /*define posiciones de memoria*/
  24          #define EE_ID_CLIENTE           0x0000
  25          #define EE_ID_PARK              0x0002
  26          #define EE_TIEMPO_GRACIA        0x0004
  27          #define EE_SIN_COBRO            0x0006
  28          #define EE_DEBUG                0x0008
  29          #define EE_USE_LPR              0x000A
  30          #define EE_CPRCN_ACTIVA         0x000C
  31          #define EE_TIPO_PANTALLA        0X000E
  32          #define EE_CARD_AUTOMATIC_BOTON 0x000f
  33          #define EE_HABILITA_APB         0x0010
  34          #define EE_TICKET_ID            0X0100
  35          
  36          /* Definicion del tamaño de comando y longitud de cmd*/
  37          
  38          #define   NUMCOMMAND 12
  39          #define   LONGSIZE 3
  40          
  41          
  42          
  43          char comandos[NUMCOMMAND][LONGSIZE]=
  44          {
  45            "0",          //ID_CLIENTEValor del punto cero.
  46            "1",       //COD_PARKTiempo de recolecion entre muestra
  47            "2",    // T_GRACIAInformacion recolectada enviada al rs232
  48            "3",    //SIN_COBROAjuste del cero del sensor
  49            "4",  //DEBUG Calibracion por la curva de la pendiente
  50            "5",    //USE_LPR
  51            "6",//COMPARACION_ACTIVA
  52            "7",      //TIPO_PANTALLA
  53            "8",        // tarjeta automatica o boton
  54            "9",      //habilita apb o inhabilta
C51 COMPILER V9.59.0.0   PROG                                                              05/21/2020 14:05:11 PAGE 2   

  55            "10",     //AYUDA Ayuda!muestra todos los comandos
  56            "11"    //SALIRSalir de programacion
  57          };
  58          
  59          /*------------------------------------------------------------------------------
  60          Rutina que encripta la clave q se le envie
  61          len_clave= longitud de la clave a encriptar
  62          aleatorio=numero aleatoria para escoger el dato a sumar y para la or
  63          
  64          ------------------------------------------------------------------------------*/
  65          unsigned char *hash_id(unsigned char *clave)
  66          {
  67   1        unsigned char len_clave,i;
  68   1        static unsigned int temp, temp1;
  69   1        unsigned char aleatorio []={":[<%?XT]=)" };
  70   1        unsigned char suma []={"#*YJAIMEcamiltK"};/*caracteres q se le suman a la trama */
  71   1        unsigned char xxor []={"wrz25q68-91fS.@" };
  72   1        unsigned char usuario1[6];
  73   1        
  74   1        len_clave=strlen(clave);                      /*longitud de la clave a encriptar*/
  75   1        for (i=0; i<len_clave;i++)
  76   1        {
  77   2          temp=*(clave+i)+aleatorio[i];               /*el primer caracter de la clave se le suma con el primero de los a
             -leatorios*/
  78   2          temp1=temp & 15;                            /*al  resultado se le hace una and con (0x0f)*/
  79   2          if (temp1==0)temp1++; 
  80   2          temp=*(clave+i) + suma[temp1-1];            /*se suma la clave  con el arreglo suma y el valor del arreglo bie
             -ne de  aleatorio el resultado q da en temp */
  81   2          temp1=temp & 15;
  82   2          if (temp1==0)temp1++;
  83   2          temp=temp ^ xxor[temp1-1];                  /*temp se le hace uan xor aleatoria*/
  84   2          if (temp > 255)
  85   2          {
  86   3            temp=temp & 255;
  87   3          }     
  88   2          if ((temp >=122)&&(temp<=255))
  89   2          {
  90   3          temp=temp & 122;
  91   3          
  92   3          }
  93   2          if (temp < 48)
  94   2          {
  95   3            temp=temp+64;
  96   3          }
  97   2          if ((temp>=91)&&(temp<=96))
  98   2          {
  99   3            temp=temp +7 ;
 100   3          }
 101   2          if ((temp>=58)&&(temp<=64))
 102   2          {
 103   3            temp=temp - 7 ;
 104   3          }
 105   2          usuario1[i]=temp;
 106   2          
 107   2        }
 108   1        return usuario1;
 109   1      }
 110          
 111          
 112          /*------------------------------------------------------------------------------
 113          Rutina de lista de comandos 
 114          ------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   PROG                                                              05/21/2020 14:05:11 PAGE 3   

 115          
 116          unsigned char ListaComandos(unsigned char *cmd)
 117          {
 118   1         unsigned char buf[LONGSIZE];
 119   1         unsigned char i;
 120   1         
 121   1         for (i=0; i<NUMCOMMAND; i++)
 122   1         {
 123   2            strcpy(buf, &comandos[i][0]);
 124   2            if (strcmp(buf, cmd)==0)
 125   2               return(i);
 126   2         }
 127   1         
 128   1         return(0xFF);
 129   1      }
 130          
 131          
 132          /*------------------------------------------------------------------------------
 133          Rutina que valida la clave
 134          ------------------------------------------------------------------------------*/
 135          unsigned char  ValidarClave(unsigned char *buffer)
 136          {
 137   1      unsigned char buf [7];
 138   1        
 139   1            strcpy(buf, &validacion[0]);
 140   1            if (strcmp(buf, buffer)==0)
 141   1               return(0);
 142   1       
 143   1         
 144   1         return(0xFF);
 145   1      }
 146          
 147          
 148          
 149          /*------------------------------------------------------------------------------
 150          Rutina que busca el \
 151          ------------------------------------------------------------------------------*/
 152          unsigned char * GetCMD(unsigned char *in)
 153          {
 154   1         char tokens[]=" \r\n";
 155   1         return(strtok(in,tokens));
 156   1      }
 157          
 158          /*------------------------------------------------------------------------------
 159          Rutina de 
 160          ------------------------------------------------------------------------------*/
 161          unsigned char * GetOption(unsigned char *in)
 162          {
 163   1         unsigned char tokensSpace[]=" \r\n";
 164   1         unsigned char tokensQuote[]="\"\r\n";
 165   1         
 166   1         //trim leading spaces
 167   1         while (*in==' ')
 168   1            in++;
 169   1         
 170   1         //if first char is a quote, then end token on a quote.  ELSE end token on a space
 171   1         if (*in == '\"')
 172   1            return(strtok(in,tokensQuote));
 173   1         else
 174   1            return(strtok(in,tokensSpace));
 175   1      } 
 176          /*------------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   PROG                                                              05/21/2020 14:05:11 PAGE 4   

 177          Rutina de muestra el cursor
 178          ------------------------------------------------------------------------------*/
 179          
 180          void DisplayCursor(void)
 181          {
 182   1         printf("\r\n\n%s> ", cursor);
 183   1      }
 184          
 185          /*------------------------------------------------------------------------------
 186          Rutina que captura los datos pto serie y los muestra en el pto
 187          ------------------------------------------------------------------------------*/
 188          
 189          void IngresaDato(unsigned char  *buffer, unsigned char modo)
 190          {
 191   1      
 192   1       int i;
 193   1       
 194   1        do
 195   1        { 
 196   2          *buffer = _getkey();
 197   2        if (modo == 0) 
 198   2          {
 199   3             printf("%c", *buffer);
 200   3          }
 201   2          else 
 202   2          {
 203   3            putchar('*');
 204   3          }
 205   2           i=*buffer; 
 206   2           buffer++;
 207   2          *buffer='\0'; 
 208   2          
 209   2        } while(i != '\r');
 210   1          
 211   1            
 212   1               
 213   1      } 
 214          /*
 215          void LeerMemoria(unsigned int  addres,unsigned char  *res)
 216          {
 217          unsigned char i;
 218            do {
 219              *res=rd_eeprom(0xa8,addres);
 220              i=*res;
 221              addres++;
 222              res++;
 223              }while(i !='\0');
 224              *res='\0';
 225          }
 226          */
 227          /*------------------------------------------------------------------------------
 228          Rutina que programa el id_cliente en eeprom
 229          ------------------------------------------------------------------------------*/
 230          void prog_id_cliente()
 231          {
 232   1        unsigned char buffer[10];
 233   1        unsigned int dataee;
 234   1        
 235   1        dataee=rd_eeprom(0xa8,EE_ID_CLIENTE);                                         /*se lee el id_cliente actual */
 236   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 237   1        
 238   1        printf("\r\n\n ACTUAL ID_CLIENTE=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual en pan
C51 COMPILER V9.59.0.0   PROG                                                              05/21/2020 14:05:11 PAGE 5   

             -talla*/
 239   1        
 240   1        printf("\r\n\n DIGITE SU NUEVO ID_CLIENTE=");                                 /*digite el nuevo id_cliente*/
 241   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 242   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 243   1        wr_eeprom(0xa8,EE_ID_CLIENTE,dataee);                                         /*grabo el dato en la eeprom*/
 244   1        
 245   1        dataee=rd_eeprom(0xa8,EE_ID_CLIENTE);                                         /*leo el dato grabado*/
 246   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 247   1        printf("\r\n\n DATO MODIFICADO ID_CLIENTE=%s\r\n\n",buffer);                  /*lo muetro por la pantalla el dato 
             -grabado*/
 248   1      }
 249          /*------------------------------------------------------------------------------
 250          Rutina que programa el cod_park
 251          ------------------------------------------------------------------------------*/
 252          void prog_cod_park()
 253          {
 254   1        unsigned char buffer[10];
 255   1        unsigned int dataee;
 256   1        
 257   1        dataee=rd_eeprom(0xa8,EE_ID_PARK);                                          /*se lee el id_cliente actual */
 258   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 259   1        
 260   1        printf("\r\n\n ACTUAL COD_PARK=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual en panta
             -lla*/
 261   1        
 262   1        printf("\r\n\n DIGITE SU NUEVO COD_PARK=");                                 /*digite el nuevo id_cliente*/
 263   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 264   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 265   1        wr_eeprom(0xa8,EE_ID_PARK,dataee);                                          /*grabo el dato en la eeprom*/
 266   1        
 267   1        dataee=rd_eeprom(0xa8,EE_ID_PARK);                                          /*leo el dato grabado*/
 268   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 269   1        printf("\r\n\n DATO MODIFICADO COD_PARK=%s\r\n\n",buffer);                  /*lo muetro por la pantalla el dato gr
             -abado*/
 270   1      }
 271          /*------------------------------------------------------------------------------
 272          Rutina que programa el tiempo de gracia de cobro (00) no tiene tiempo de gracia
 273          ------------------------------------------------------------------------------*/
 274          void Prog_tiempo_gracia()
 275          {
 276   1        unsigned char buffer[10];
 277   1        unsigned int dataee;
 278   1        
 279   1        dataee=rd_eeprom(0xa8,EE_TIEMPO_GRACIA);                                          /*se lee el id_cliente actual */
 280   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 281   1        
 282   1        printf("\r\n\n ACTUAL TIEMPO_GRACIA=%s\r\n\n",buffer);                            /*se muestra el id_cliente actual en 
             -pantalla*/
 283   1        
 284   1        printf("\r\n\n DIGITE SU NUEVO TIEMPO_GRACIA=");                                  /*digite el nuevo id_cliente*/
 285   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 286   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 287   1        wr_eeprom(0xa8,EE_TIEMPO_GRACIA,dataee);                                          /*grabo el dato en la eeprom*/
 288   1        
 289   1        dataee=rd_eeprom(0xa8,EE_TIEMPO_GRACIA);                                        /*leo el dato grabado*/
 290   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 291   1        printf("\r\n\n DATO MODIFICADO TIEMPO_GRACIA=%s\r\n\n",buffer);               /*lo muetro por la pantalla el dat
             -o grabado*/
 292   1      }
 293          /*------------------------------------------------------------------------------
 294          Rutina que programa SIN COBRO
C51 COMPILER V9.59.0.0   PROG                                                              05/21/2020 14:05:11 PAGE 6   

 295          SIN_COBRO=0 inhabilitado, SIN_COBRO=1 sin cobro, SIN_COBRO=2 sin cobro y salida el mismo dia");
 296          ------------------------------------------------------------------------------*/
 297          void Prog_Sin_Cobro()
 298          {
 299   1        
 300   1      
 301   1        unsigned char buffer[10];
 302   1        unsigned int dataee;
 303   1      
 304   1        dataee=rd_eeprom(0xa8,EE_SIN_COBRO);                                          /*se lee el id_cliente actual */
 305   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 306   1        if(dataee==0)
 307   1        {
 308   2          printf("\r\n\n ACTUAL SIN_COBRO INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente 
             -actual en pantalla*/
 309   2        }
 310   1        else if (dataee==1)
 311   1        {
 312   2          printf("\r\n\n ACTUAL SIN_COBRO GRATIS=%s\r\n\n",buffer);   
 313   2        }
 314   1        else 
 315   1        {
 316   2            printf("\r\n\n ACTUAL SIN_COBRO GRATIS Y SALIDA EL MISMO DIA=%s\r\n\n",buffer);   
 317   2        }
 318   1        
 319   1        printf("\r\n\n DIGITE SU NUEVO SIN_COBRO=");                                  /*digite el nuevo id_cliente*/
 320   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 321   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 322   1        wr_eeprom(0xa8,EE_SIN_COBRO,dataee);                                          /*grabo el dato en la eeprom*/
 323   1        
 324   1        dataee=rd_eeprom(0xa8,EE_SIN_COBRO);                                        /*leo el dato grabado*/
 325   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 326   1        if(dataee==0)
 327   1        {
 328   2          printf("\r\n\n ACTUAL SIN_COBRO INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente 
             -actual en pantalla*/
 329   2        }
 330   1        else if (dataee==1)
 331   1        {
 332   2          printf("\r\n\n ACTUAL SIN_COBRO GRATIS=%s\r\n\n",buffer);   
 333   2        }
 334   1        else 
 335   1        {
 336   2            printf("\r\n\n ACTUAL SIN_COBRO GRATIS Y SALIDA EL MISMO DIA=%s\r\n\n",buffer);   
 337   2        }
 338   1        
 339   1      }
 340          /*------------------------------------------------------------------------------------
 341          Rutina que habilita el debuger
 342           Habilita = 1 ; 
 343          inahabilita = 0;
 344          --------------------------------------------------------------------------------------*/
 345          void Prog_debug()
 346          {
 347   1        unsigned char buffer[10];
 348   1        unsigned int dataee;
 349   1      
 350   1        
 351   1        dataee=rd_eeprom(0xa8,EE_DEBUG);                                          /*se lee el id_cliente actual */
 352   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 353   1        if(dataee==0)
 354   1        {
C51 COMPILER V9.59.0.0   PROG                                                              05/21/2020 14:05:11 PAGE 7   

 355   2          printf("\r\n\n ACTUAL DEBUG INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 356   2        }
 357   1        else
 358   1        {
 359   2          printf("\r\n\n ACTUAL DEBUG HABILITADO=%s\r\n\n",buffer);     
 360   2        }
 361   1        
 362   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE DEBUG=");                                  /*digite el nuevo id_cliente*/
 363   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 364   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 365   1        wr_eeprom(0xa8,EE_DEBUG,dataee);                                          /*grabo el dato en la eeprom*/
 366   1        
 367   1        dataee=rd_eeprom(0xa8,EE_DEBUG);                                        /*leo el dato grabado*/
 368   1        sprintf(buffer,"%d",dataee);  
 369   1        if(dataee==0)
 370   1        {
 371   2          printf("\r\n\n ACTUAL DEBUG INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 372   2        }
 373   1        else
 374   1        {
 375   2          printf("\r\n\n ACTUAL DEBUG HABILITADO=%s\r\n\n",buffer);     
 376   2        }
 377   1      }
 378          /*------------------------------------------------------------------------------------
 379          
 380          --------------------------------------------------------------------------------------*/
 381          
 382          void Prog_Use_Lpr()
 383          {
 384   1          unsigned char buffer[10];
 385   1        unsigned int dataee;
 386   1      
 387   1        
 388   1        dataee=rd_eeprom(0xa8,EE_USE_LPR);                                          /*se lee el id_cliente actual */
 389   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 390   1        if(dataee==0)
 391   1        {
 392   2          printf("\r\n\n ACTUAL USE_LPR INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente ac
             -tual en pantalla*/
 393   2        }
 394   1        else
 395   1        {
 396   2          printf("\r\n\n ACTUAL USE_LPR HABILITADO=%s\r\n\n",buffer);     
 397   2        }
 398   1        
 399   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE USE_LPR=");                                  /*digite el nuevo id_cliente*/
 400   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 401   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 402   1        wr_eeprom(0xa8,EE_USE_LPR,dataee);                                          /*grabo el dato en la eeprom*/
 403   1        
 404   1        dataee=rd_eeprom(0xa8,EE_USE_LPR);                                        /*leo el dato grabado*/
 405   1        sprintf(buffer,"%d",dataee);  
 406   1        if(dataee==0)
 407   1        {
 408   2          printf("\r\n\n ACTUAL USE_LPR INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente ac
             -tual en pantalla*/
 409   2        }
 410   1        else
 411   1        {
 412   2          printf("\r\n\n ACTUAL USE_LPR HABILITADO=%s\r\n\n",buffer);     
C51 COMPILER V9.59.0.0   PROG                                                              05/21/2020 14:05:11 PAGE 8   

 413   2        }
 414   1      }
 415          /*------------------------------------------------------------------------------------
 416          Compara la placa de la tarjeta y la del software
 417          --------------------------------------------------------------------------------------*/
 418          void Prog_Comparacion_Activa()
 419          {
 420   1        unsigned char buffer[10];
 421   1        unsigned int dataee;
 422   1      
 423   1        
 424   1        dataee=rd_eeprom(0xa8,EE_CPRCN_ACTIVA);                                         /*se lee el id_cliente actual */
 425   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 426   1        if(dataee==0)
 427   1        {
 428   2          printf("\r\n\n ACTUAL COMPARACION ACTIVA INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el id
             -_cliente actual en pantalla*/
 429   2        }
 430   1        else
 431   1        {
 432   2          printf("\r\n\n ACTUAL COMPARACION ACTIVA  HABILITADO=%s\r\n\n",buffer);     
 433   2        }
 434   1        
 435   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE COMPARACION ACTIVA =");                                  /*digite el nuevo id_cli
             -ente*/
 436   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 437   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 438   1        wr_eeprom(0xa8,EE_CPRCN_ACTIVA,dataee);                                         /*grabo el dato en la eeprom*/
 439   1        
 440   1        dataee=rd_eeprom(0xa8,EE_CPRCN_ACTIVA);                                       /*leo el dato grabado*/
 441   1        sprintf(buffer,"%d",dataee);  
 442   1        if(dataee==0)
 443   1        {
 444   2          printf("\r\n\n ACTUAL COMPARACION ACTIVA  INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el i
             -d_cliente actual en pantalla*/
 445   2        }
 446   1        else
 447   1        {
 448   2          printf("\r\n\n ACTUAL COMPARACION ACTIVA  HABILITADO=%s\r\n\n",buffer);     
 449   2        }
 450   1      }
 451          /*------------------------------------------------------------------------------------
 452          cmd del tipo de pantalla a usar
 453          Rasberry = 1
 454          lcd = 0
 455          --------------------------------------------------------------------------------------*/
 456          void tipo_pantalla()
 457          {
 458   1        unsigned char buffer[10];
 459   1        unsigned int dataee;
 460   1      
 461   1        
 462   1        dataee=rd_eeprom(0xa8,EE_TIPO_PANTALLA);                                          /*se lee el id_cliente actual */
 463   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 464   1        if(dataee==0)
 465   1        {
 466   2          printf("\r\n\n PANTALLA LCD HABILITADA=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual
             - en pantalla*/
 467   2        }
 468   1        else
 469   1        {
 470   2          printf("\r\n\n PANTALLA RASPBERRY  HABILITADA=%s\r\n\n",buffer);      
C51 COMPILER V9.59.0.0   PROG                                                              05/21/2020 14:05:11 PAGE 9   

 471   2        }
 472   1        
 473   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE LA PANTALLA =");                                 /*digite el nuevo id_cliente*/
 474   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 475   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 476   1        wr_eeprom(0xa8,EE_TIPO_PANTALLA,dataee);                                          /*grabo el dato en la eeprom*/
 477   1        
 478   1        dataee=rd_eeprom(0xa8,EE_TIPO_PANTALLA);                                        /*leo el dato grabado*/
 479   1        sprintf(buffer,"%d",dataee);  
 480   1        if(dataee==0)
 481   1        {
 482   2          printf("\r\n\n PANTALLA LCD HABILITADA=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual
             - en pantalla*/
 483   2        }
 484   1        else
 485   1        {
 486   2          printf("\r\n\n ACTUAL COMPARACION ACTIVA  HABILITADA=%s\r\n\n",buffer);     
 487   2        }
 488   1        
 489   1      }
 490          void Prog_tarjeta_automatica_o_boton()
 491          {
 492   1        unsigned char buffer[10];
 493   1        unsigned int dataee;
 494   1      
 495   1        
 496   1        dataee=rd_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON);                               //se lee LA CONFIGURACION 
 497   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 498   1        if(dataee==0)
 499   1        {
 500   2          printf("\r\n\n EXPIDE TARJETA PULSANDO BOTON\r\n\n");                           /*se muestra el id_cliente actual en 
             -pantalla*/
 501   2        }
 502   1        else
 503   1        {
 504   2          printf("\r\n\n EXPIDE TARJETA AUTOMATICA\r\n\n");     
 505   2        }
 506   1        
 507   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DEL EXPEDIDOR=");                                 /*digite el nuevo id_cliente*/
 508   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 509   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 510   1        wr_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON,dataee);                                         /*grabo el dato en la eeprom*/
 511   1        
 512   1        dataee=rd_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON);                                       /*leo el dato grabado*/
 513   1        sprintf(buffer,"%d",dataee);  
 514   1        if(dataee==0)
 515   1        {
 516   2          printf("\r\n\n EXPIDE TARJETA PULSANDO BOTON\r\n\n");                           /*se muestra el id_cliente actual en 
             -pantalla*/
 517   2        }
 518   1        else
 519   1        {
 520   2          printf("\r\n\n EXPIDE TARJETA AUTOMATICA\r\n\n");     
 521   2        }
 522   1      }
 523          void Prog_AntiPassBack()
 524          {
 525   1        unsigned char buffer[10];
 526   1        unsigned int dataee;
 527   1      
 528   1        
 529   1        dataee=rd_eeprom(0xa8,EE_HABILITA_APB);                                         /*se lee el id_cliente actual */
C51 COMPILER V9.59.0.0   PROG                                                              05/21/2020 14:05:11 PAGE 10  

 530   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 531   1        if(dataee==0)
 532   1        {
 533   2          printf("\r\n\n ACTUAL ANTIPASSBACK INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el id_clien
             -te actual en pantalla*/
 534   2        }
 535   1        else
 536   1        {
 537   2          printf("\r\n\n ACTUAL ANTIPASSBACK HABILITADO=%s\r\n\n",buffer);      
 538   2        }
 539   1        
 540   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE ANTIPASSBACK=");                                 /*digite el nuevo id_cliente*/
 541   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 542   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 543   1        wr_eeprom(0xa8,EE_HABILITA_APB,dataee);                                         /*grabo el dato en la eeprom*/
 544   1        
 545   1        dataee=rd_eeprom(0xa8,EE_HABILITA_APB);                                       /*leo el dato grabado*/
 546   1        sprintf(buffer,"%d",dataee);  
 547   1        if(dataee==0)
 548   1        {
 549   2          printf("\r\n\n ACTUAL ANTIPASSBACK INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el id_clien
             -te actual en pantalla*/
 550   2        }
 551   1        else
 552   1        {
 553   2          printf("\r\n\n ACTUAL ANTIPASSBACK HABILITADO=%s\r\n\n",buffer);      
 554   2        }
 555   1      }
 556          
 557          /*------------------------------------------------------------------------------
 558          Rutina que muestra la lista de comandos
 559          ------------------------------------------------------------------------------*/
 560          void Show()
 561          {
 562   1         printf("\r\n ID_CLIENTE    --- CMD 0 Identificador del cliente maximo 255");
 563   1         printf("\r\n COD_PARK      --- CMD 1 El numero del parqueadero maximo 255");
 564   1         printf("\r\n T_GRACIA      --- CMD 2 Tiempo sin cobro 00,  maximo 255");
 565   1         printf("\r\n SIN_COBRO     --- CMD 3 Inhabilitado= 0, Gratis= 1 , Gratis y salida el mismo dia= 2");
 566   1         printf("\r\n DEBUG         --- CMD 4 Habilitar = 1, Inhabilitar = 0");
 567   1         printf("\r\n USE_LPR       --- CMD 5 Habilitar = 1, Inhabilitar = 0");
 568   1         printf("\r\n COMPARACION_ACTIVA --- CMD 6 Habilitar = 1, Inhabilitar = 0");
 569   1         printf("\r\n TIPO_PANTALLA     --- CMD 7 PANTALLA LCD =0 PANTALLA RASPBERRI=1");
 570   1         printf("\r\n CARD_AUTOMATICA   --- CMD 8 BOTTON=0 AUTOMATICA=1");
 571   1         printf("\r\n ANTIPASSBACK        --- CMD 9 Habilitar = 1, Inhabilitar = 0");
 572   1         printf("\r\n AYUDA         --- CMD 10 Muestra los comandos");
 573   1         printf("\r\n SALIR         --- CMD 11 Salir de programacion");
 574   1      
 575   1      }
 576          
 577          /*------------------------------------------------------------------------------
 578          Rutina de principal de programacion
 579          ------------------------------------------------------------------------------*/
 580          
 581          void menu(void)
 582          {
 583   1      
 584   1      unsigned char *cmd,*option1,*option2,*usuario;
 585   1      unsigned char opt_buffer[40];
 586   1      unsigned char buffer[40];
 587   1      
 588   1      
 589   1      
C51 COMPILER V9.59.0.0   PROG                                                              05/21/2020 14:05:11 PAGE 11  

 590   1        
 591   1        printf("\r\n\nSistema de Programacion Expedidor \r\n\r\n");
 592   1      
 593   1       
 594   1        
 595   1        
 596   1        do{
 597   2        printf("\r\n\n/>Usuario:");
 598   2        
 599   2        // main loop
 600   2        IngresaDato(buffer,0);          //ingreso el usuario por teclado 
 601   2        cmd = GetCMD(buffer);         //quita el carri return 
 602   2        usuario=hash_id(buffer);        //el usuario es encriptado
 603   2      }while(ValidarClave(cmd)!=0);       //validamos el usuario
 604   1      
 605   1      
 606   1        do{
 607   2      printf("\r\n\n/>Password:");
 608   2      
 609   2        IngresaDato(buffer,1);          //ingreso el password por teclado 
 610   2        cmd = GetCMD(buffer);         //quita el carri return 
 611   2        strcpy (validacion,"123456");
 612   2        //strcpy (validacion,usuario);    /*valida el valor encriptado*/
 613   2      
 614   2        }while(ValidarClave(cmd)!=0);       //
 615   1      
 616   1        
 617   1        Show();
 618   1        while(1)
 619   1        {
 620   2        DisplayCursor();
 621   2      
 622   2      
 623   2          IngresaDato(buffer,0);  
 624   2          cmd = GetCMD(buffer); 
 625   2          option1 = GetOption(cmd + strlen(cmd) + 1);
 626   2          option2 = GetOption(option1 + strlen(option1) + 1);  
 627   2      
 628   2         //si empieza con un '/', eso significa que incluye el caminoa
 629   2            //al archivo.  si el archivo no empieza con un '/', debe agregarce 
 630   2            //la ruta del archivo.
 631   2            if (option1 && (option1[0]=='/'))
 632   2            {
 633   3               //option1 is a full path
 634   3               strcpy(opt_buffer, option1);
 635   3            }
 636   2            else if (option1)
 637   2            {
 638   3               // tack on the current working directory to option1
 639   3               strcpy(opt_buffer, cursor);
 640   3               strcat(opt_buffer, option1);
 641   3            }         
 642   2      
 643   2      
 644   2      
 645   2      
 646   2      
 647   2          if (cmd)
 648   2            {
 649   3               switch(ListaComandos(cmd))
 650   3               {
 651   4                  case 0:                     /*Se programa la identificacion del cliente*/
C51 COMPILER V9.59.0.0   PROG                                                              05/21/2020 14:05:11 PAGE 12  

 652   4                    prog_id_cliente();
 653   4                  
 654   4                   break;
 655   4                  
 656   4                  case 1:  //Tiempo de recolecion entre muestra
 657   4                  prog_cod_park();
 658   4                     break;
 659   4                  
 660   4                  case 2:  //Informacion recolectada enviada al rs232
 661   4          
 662   4                  Prog_tiempo_gracia();
 663   4                
 664   4                     break;
 665   4                  
 666   4                  case 3:  //Ajuste del cero del sensor
 667   4                  Prog_Sin_Cobro();
 668   4      
 669   4                     break;
 670   4                  
 671   4                  case 4:  //Ajuste de calibracion por medio de la pendiente
 672   4                    Prog_debug();
 673   4                     break;
 674   4                  case 5:  //help me
 675   4                    Prog_Use_Lpr();
 676   4                     break;
 677   4                  case 6:  //help me
 678   4                 Prog_Comparacion_Activa();
 679   4      
 680   4                     break;
 681   4                  case 7:     //tipo de pantalla
 682   4                  tipo_pantalla();
 683   4                    break;
 684   4                  case 8:     //tarjeta automatica o pulsador
 685   4                  Prog_tarjeta_automatica_o_boton();
 686   4                  break;
 687   4                  case 9:  //cmd antipassback
 688   4                 
 689   4                    Prog_AntiPassBack();
 690   4                     break;
 691   4                  case 0x0a:  //help me
 692   4                 
 693   4                    Show();
 694   4                     break;
 695   4                  case 0x0b:  //salir
 696   4                  return;
 697   4      
 698   4                     break;
 699   4                 
 700   4          
 701   4                
 702   4                  default:
 703   4                     printf("\r\nComando no existe '%s'", cmd);
 704   4                     break;
 705   4              }
 706   3            }
 707   2        }
 708   1      }
 709          
 710            
 711          


C51 COMPILER V9.59.0.0   PROG                                                              05/21/2020 14:05:11 PAGE 13  

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3865    ----
   CONSTANT SIZE    =   2191    ----
   XDATA SIZE       =     69     305
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
